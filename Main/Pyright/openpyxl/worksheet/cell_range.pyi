"""
This type stub file was generated by pyright.
"""

from openpyxl.descriptors import Strict
from openpyxl.descriptors.serialisable import Serialisable

class CellRange(Serialisable):
    """
    Represents a range in a sheet: title and coordinates.

    This object is used to perform operations on ranges, like:

    - shift, expand or shrink
    - union/intersection with another sheet range,

    We can check whether a range is:

    - equal or not equal to another,
    - disjoint of another,
    - contained in another.

    We can get:

    - the size of a range.
    - the range bounds (vertices)
    - the coordinates,
    - the string representation,

    """
    min_col = ...
    min_row = ...
    max_col = ...
    max_row = ...
    def __init__(self, range_string=..., min_col=..., min_row=..., max_col=..., max_row=..., title=...) -> None:
        ...
    
    @property
    def bounds(self): # -> tuple[MinMax | int | Any | None, MinMax | int | Any | None, MinMax | int | Any | None, MinMax | int | Any | None]:
        """
        Vertices of the range as a tuple
        """
        ...
    
    @property
    def coord(self): # -> str:
        """
        Excel-style representation of the range
        """
        ...
    
    @property
    def rows(self): # -> Generator[list[tuple[int, int]], Any, None]:
        """
        Return cell coordinates as rows
        """
        ...
    
    @property
    def cols(self): # -> Generator[list[tuple[int, int]], Any, None]:
        """
        Return cell coordinates as columns
        """
        ...
    
    @property
    def cells(self): # -> product[tuple[int, int]]:
        ...
    
    def __repr__(self): # -> str:
        ...
    
    def __hash__(self) -> int:
        ...
    
    def __str__(self) -> str:
        ...
    
    def __copy__(self): # -> Self:
        ...
    
    def shift(self, col_shift=..., row_shift=...): # -> None:
        """
        Shift the focus of the range according to the shift values (*col_shift*, *row_shift*).

        :type col_shift: int
        :param col_shift: number of columns to be moved by, can be negative
        :type row_shift: int
        :param row_shift: number of rows to be moved by, can be negative
        :raise: :class:`ValueError` if any row or column index < 1
        """
        ...
    
    def __ne__(self, other) -> bool:
        """
        Test whether the ranges are not equal.

        :type other: openpyxl.worksheet.cell_range.CellRange
        :param other: Other sheet range
        :return: ``True`` if *range* != *other*.
        """
        ...
    
    def __eq__(self, other) -> bool:
        """
        Test whether the ranges are equal.

        :type other: openpyxl.worksheet.cell_range.CellRange
        :param other: Other sheet range
        :return: ``True`` if *range* == *other*.
        """
        ...
    
    def issubset(self, other):
        """
        Test whether every cell in this range is also in *other*.

        :type other: openpyxl.worksheet.cell_range.CellRange
        :param other: Other sheet range
        :return: ``True`` if *range* <= *other*.
        """
        ...
    
    __le__ = ...
    def __lt__(self, other) -> bool:
        """
        Test whether *other* contains every cell of this range, and more.

        :type other: openpyxl.worksheet.cell_range.CellRange
        :param other: Other sheet range
        :return: ``True`` if *range* < *other*.
        """
        ...
    
    def issuperset(self, other):
        """
        Test whether every cell in *other* is in this range.

        :type other: openpyxl.worksheet.cell_range.CellRange
        :param other: Other sheet range
        :return: ``True`` if *range* >= *other* (or *other* in *range*).
        """
        ...
    
    __ge__ = ...
    def __contains__(self, coord):
        """
        Check whether the range contains a particular cell coordinate
        """
        ...
    
    def __gt__(self, other) -> bool:
        """
        Test whether this range contains every cell in *other*, and more.

        :type other: openpyxl.worksheet.cell_range.CellRange
        :param other: Other sheet range
        :return: ``True`` if *range* > *other*.
        """
        ...
    
    def isdisjoint(self, other): # -> Any | bool:
        """
        Return ``True`` if this range has no cell in common with *other*.
        Ranges are disjoint if and only if their intersection is the empty range.

        :type other: openpyxl.worksheet.cell_range.CellRange
        :param other: Other sheet range.
        :return: ``True`` if the range has no cells in common with other.
        """
        ...
    
    def intersection(self, other): # -> CellRange:
        """
        Return a new range with cells common to this range and *other*

        :type other: openpyxl.worksheet.cell_range.CellRange
        :param other: Other sheet range.
        :return: the intersecting sheet range.
        :raise: :class:`ValueError` if the *other* range doesn't intersect
            with this range.
        """
        ...
    
    __and__ = ...
    def union(self, other): # -> CellRange:
        """
        Return the minimal superset of this range and *other*. This new range
        will contain all cells from this range, *other*, and any additional
        cells required to form a rectangular ``CellRange``.

        :type other: openpyxl.worksheet.cell_range.CellRange
        :param other: Other sheet range.
        :return: a ``CellRange`` that is a superset of this and *other*.
        """
        ...
    
    __or__ = ...
    def __iter__(self): # -> Generator[tuple[Any, Any], Any, None]:
        """
        For use as a dictionary elsewhere in the library.
        """
        ...
    
    def expand(self, right=..., down=..., left=..., up=...): # -> None:
        """
        Expand the range by the dimensions provided.

        :type right: int
        :param right: expand range to the right by this number of cells
        :type down: int
        :param down: expand range down by this number of cells
        :type left: int
        :param left: expand range to the left by this number of cells
        :type up: int
        :param up: expand range up by this number of cells
        """
        ...
    
    def shrink(self, right=..., bottom=..., left=..., top=...): # -> None:
        """
        Shrink the range by the dimensions provided.

        :type right: int
        :param right: shrink range from the right by this number of cells
        :type down: int
        :param down: shrink range from the top by this number of cells
        :type left: int
        :param left: shrink range from the left by this number of cells
        :type up: int
        :param up: shrink range from the bottom by this number of cells
        """
        ...
    
    @property
    def size(self): # -> dict[str, Any | int]:
        """ Return the size of the range as a dictionary of rows and columns. """
        ...
    
    @property
    def top(self): # -> list[tuple[MinMax | int | Any | None, int]]:
        """A list of cell coordinates that comprise the top of the range"""
        ...
    
    @property
    def bottom(self): # -> list[tuple[MinMax | int | Any | None, int]]:
        """A list of cell coordinates that comprise the bottom of the range"""
        ...
    
    @property
    def left(self): # -> list[tuple[int, MinMax | int | Any | None]]:
        """A list of cell coordinates that comprise the left-side of the range"""
        ...
    
    @property
    def right(self): # -> list[tuple[int, MinMax | int | Any | None]]:
        """A list of cell coordinates that comprise the right-side of the range"""
        ...
    


class MultiCellRange(Strict):
    ranges = ...
    def __init__(self, ranges=...) -> None:
        ...
    
    def __contains__(self, coord): # -> bool:
        ...
    
    def __repr__(self): # -> str:
        ...
    
    def __str__(self) -> str:
        ...
    
    def __hash__(self) -> int:
        ...
    
    def sorted(self):
        """
        Return a sorted list of items
        """
        ...
    
    def add(self, coord): # -> None:
        """
        Add a cell coordinate or CellRange
        """
        ...
    
    def __iadd__(self, coord): # -> Self:
        ...
    
    def __eq__(self, other) -> bool:
        ...
    
    def __ne__(self, other) -> bool:
        ...
    
    def __bool__(self): # -> bool:
        ...
    
    def remove(self, coord): # -> None:
        ...
    
    def __iter__(self): # -> Generator[Any, Any, None]:
        ...
    
    def __copy__(self): # -> MultiCellRange:
        ...
    


