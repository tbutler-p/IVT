"""
This type stub file was generated by pyright.
"""

import docx.types as t
from typing import Any, Callable, Generic, Iterator, TYPE_CHECKING, Tuple, TypeVar
from docx.opc.part import XmlPart
from docx.oxml.xmlchemy import BaseOxmlElement
from docx.parts.story import StoryPart

"""Objects shared by docx modules."""
if TYPE_CHECKING:
    ...
class Length(int):
    """Base class for length constructor classes Inches, Cm, Mm, Px, and Emu.

    Behaves as an int count of English Metric Units, 914,400 to the inch, 36,000 to the
    mm. Provides convenience unit conversion methods in the form of read-only
    properties. Immutable.
    """
    _EMUS_PER_INCH = ...
    _EMUS_PER_CM = ...
    _EMUS_PER_MM = ...
    _EMUS_PER_PT = ...
    _EMUS_PER_TWIP = ...
    def __new__(cls, emu: int): # -> Self:
        ...
    
    @property
    def cm(self): # -> float:
        """The equivalent length expressed in centimeters (float)."""
        ...
    
    @property
    def emu(self): # -> Self:
        """The equivalent length expressed in English Metric Units (int)."""
        ...
    
    @property
    def inches(self): # -> float:
        """The equivalent length expressed in inches (float)."""
        ...
    
    @property
    def mm(self): # -> float:
        """The equivalent length expressed in millimeters (float)."""
        ...
    
    @property
    def pt(self): # -> float:
        """Floating point length in points."""
        ...
    
    @property
    def twips(self): # -> int:
        """The equivalent length expressed in twips (int)."""
        ...
    


class Inches(Length):
    """Convenience constructor for length in inches, e.g. ``width = Inches(0.5)``."""
    def __new__(cls, inches: float): # -> Self:
        ...
    


class Cm(Length):
    """Convenience constructor for length in centimeters, e.g. ``height = Cm(12)``."""
    def __new__(cls, cm: float): # -> Self:
        ...
    


class Emu(Length):
    """Convenience constructor for length in English Metric Units, e.g. ``width =
    Emu(457200)``."""
    def __new__(cls, emu: int): # -> Self:
        ...
    


class Mm(Length):
    """Convenience constructor for length in millimeters, e.g. ``width = Mm(240.5)``."""
    def __new__(cls, mm: float): # -> Self:
        ...
    


class Pt(Length):
    """Convenience value class for specifying a length in points."""
    def __new__(cls, points: float): # -> Self:
        ...
    


class Twips(Length):
    """Convenience constructor for length in twips, e.g. ``width = Twips(42)``.

    A twip is a twentieth of a point, 635 EMU.
    """
    def __new__(cls, twips: float): # -> Self:
        ...
    


class RGBColor(Tuple[int, int, int]):
    """Immutable value object defining a particular RGB color."""
    def __new__(cls, r: int, g: int, b: int): # -> Self:
        ...
    
    def __repr__(self): # -> str:
        ...
    
    def __str__(self) -> str:
        """Return a hex string rgb value, like '3C2F80'."""
        ...
    
    @classmethod
    def from_string(cls, rgb_hex_str: str) -> RGBColor:
        """Return a new instance from an RGB color hex string like ``'3C2F80'``."""
        ...
    


T = TypeVar("T")
class lazyproperty(Generic[T]):
    """Decorator like @property, but evaluated only on first access.

    Like @property, this can only be used to decorate methods having only a `self`
    parameter, and is accessed like an attribute on an instance, i.e. trailing
    parentheses are not used. Unlike @property, the decorated method is only evaluated
    on first access; the resulting value is cached and that same value returned on
    second and later access without re-evaluation of the method.

    Like @property, this class produces a *data descriptor* object, which is stored in
    the __dict__ of the *class* under the name of the decorated method ('fget'
    nominally). The cached value is stored in the __dict__ of the *instance* under that
    same name.

    Because it is a data descriptor (as opposed to a *non-data descriptor*), its
    `__get__()` method is executed on each access of the decorated attribute; the
    __dict__ item of the same name is "shadowed" by the descriptor.

    While this may represent a performance improvement over a property, its greater
    benefit may be its other characteristics. One common use is to construct
    collaborator objects, removing that "real work" from the constructor, while still
    only executing once. It also de-couples client code from any sequencing
    considerations; if it's accessed from more than one location, it's assured it will
    be ready whenever needed.

    Loosely based on: https://stackoverflow.com/a/6849299/1902513.

    A lazyproperty is read-only. There is no counterpart to the optional "setter" (or
    deleter) behavior of an @property. This is critically important to maintaining its
    immutability and idempotence guarantees. Attempting to assign to a lazyproperty
    raises AttributeError unconditionally.

    The parameter names in the methods below correspond to this usage example::

        class Obj(object)

            @lazyproperty
            def fget(self):
                return 'some result'

        obj = Obj()

    Not suitable for wrapping a function (as opposed to a method) because it is not
    callable."""
    def __init__(self, fget: Callable[..., T]) -> None:
        """*fget* is the decorated method (a "getter" function).

        A lazyproperty is read-only, so there is only an *fget* function (a regular
        @property can also have an fset and fdel function). This name was chosen for
        consistency with Python's `property` class which uses this name for the
        corresponding parameter.
        """
        ...
    
    def __get__(self, obj: Any, type: Any = ...) -> T:
        """Called on each access of 'fget' attribute on class or instance.

        *self* is this instance of a lazyproperty descriptor "wrapping" the property
        method it decorates (`fget`, nominally).

        *obj* is the "host" object instance when the attribute is accessed from an
        object instance, e.g. `obj = Obj(); obj.fget`. *obj* is None when accessed on
        the class, e.g. `Obj.fget`.

        *type* is the class hosting the decorated getter method (`fget`) on both class
        and instance attribute access.
        """
        ...
    
    def __set__(self, obj: Any, value: Any) -> None:
        """Raises unconditionally, to preserve read-only behavior.

        This decorator is intended to implement immutable (and idempotent) object
        attributes. For that reason, assignment to this property must be explicitly
        prevented.

        If this __set__ method was not present, this descriptor would become a
        *non-data descriptor*. That would be nice because the cached value would be
        accessed directly once set (__dict__ attrs have precedence over non-data
        descriptors on instance attribute lookup). The problem is, there would be
        nothing to stop assignment to the cached value, which would overwrite the result
        of `fget()` and break both the immutability and idempotence guarantees of this
        decorator.

        The performance with this __set__() method in place was roughly 0.4 usec per
        access when measured on a 2.8GHz development machine; so quite snappy and
        probably not a rich target for optimization efforts.
        """
        ...
    


def write_only_property(f: Callable[[Any, Any], None]): # -> property:
    """@write_only_property decorator.

    Creates a property (descriptor attribute) that accepts assignment, but not getattr
    (use in an expression).
    """
    ...

class ElementProxy:
    """Base class for lxml element proxy classes.

    An element proxy class is one whose primary responsibilities are fulfilled by
    manipulating the attributes and child elements of an XML element. They are the most
    common type of class in python-docx other than custom element (oxml) classes.
    """
    def __init__(self, element: BaseOxmlElement, parent: t.ProvidesXmlPart | None = ...) -> None:
        ...
    
    def __eq__(self, other: object) -> bool:
        """Return |True| if this proxy object refers to the same oxml element as does
        `other`.

        ElementProxy objects are value objects and should maintain no mutable local
        state. Equality for proxy objects is defined as referring to the same XML
        element, whether or not they are the same proxy object instance.
        """
        ...
    
    def __ne__(self, other: object) -> bool:
        ...
    
    @property
    def element(self): # -> BaseOxmlElement:
        """The lxml element proxied by this object."""
        ...
    
    @property
    def part(self) -> XmlPart:
        """The package part containing this object."""
        ...
    


class Parented:
    """Provides common services for document elements that occur below a part but may
    occasionally require an ancestor object to provide a service, such as add or drop a
    relationship.

    Provides ``self._parent`` attribute to subclasses.
    """
    def __init__(self, parent: t.ProvidesXmlPart) -> None:
        ...
    
    @property
    def part(self) -> XmlPart:
        """The package part containing this object."""
        ...
    


class StoryChild:
    """A document element within a story part.

    Story parts include DocumentPart and Header/FooterPart and can contain block items
    (paragraphs and tables). Items from the block-item subtree occasionally require an
    ancestor object to provide access to part-level or package-level items like styles
    or images or to add or drop a relationship.

    Provides `self._parent` attribute to subclasses.
    """
    def __init__(self, parent: t.ProvidesStoryPart) -> None:
        ...
    
    @property
    def part(self) -> StoryPart:
        """The package part containing this object."""
        ...
    


class TextAccumulator:
    """Accepts `str` fragments and joins them together, in order, on `.pop().

    Handy when text in a stream is broken up arbitrarily and you want to join it back
    together within certain bounds. The optional `separator` argument determines how
    the text fragments are punctuated, defaulting to the empty string.
    """
    def __init__(self, separator: str = ...) -> None:
        ...
    
    def push(self, text: str) -> None:
        """Add a text fragment to the accumulator."""
        ...
    
    def pop(self) -> Iterator[str]:
        """Generate sero-or-one str from those accumulated.

        Using `yield from accum.pop()` in a generator setting avoids producing an empty
        string when no text is in the accumulator.
        """
        ...
    


