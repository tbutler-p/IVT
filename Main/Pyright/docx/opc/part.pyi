"""
This type stub file was generated by pyright.
"""

from typing import Callable, TYPE_CHECKING, Type
from docx.opc.packuri import PackURI
from docx.shared import lazyproperty
from docx.oxml.xmlchemy import BaseOxmlElement
from docx.package import Package

"""Open Packaging Convention (OPC) objects related to package parts."""
if TYPE_CHECKING:
    ...
class Part:
    """Base class for package parts.

    Provides common properties and methods, but intended to be subclassed in client code
    to implement specific part behaviors.
    """
    def __init__(self, partname: PackURI, content_type: str, blob: bytes | None = ..., package: Package | None = ...) -> None:
        ...
    
    def after_unmarshal(self): # -> None:
        """Entry point for post-unmarshaling processing, for example to parse the part
        XML.

        May be overridden by subclasses without forwarding call to super.
        """
        ...
    
    def before_marshal(self): # -> None:
        """Entry point for pre-serialization processing, for example to finalize part
        naming if necessary.

        May be overridden by subclasses without forwarding call to super.
        """
        ...
    
    @property
    def blob(self) -> bytes:
        """Contents of this package part as a sequence of bytes.

        May be text or binary. Intended to be overridden by subclasses. Default behavior
        is to return load blob.
        """
        ...
    
    @property
    def content_type(self): # -> str:
        """Content type of this part."""
        ...
    
    def drop_rel(self, rId: str): # -> None:
        """Remove the relationship identified by `rId` if its reference count is less
        than 2.

        Relationships with a reference count of 0 are implicit relationships.
        """
        ...
    
    @classmethod
    def load(cls, partname: PackURI, content_type: str, blob: bytes, package: Package): # -> Self:
        ...
    
    def load_rel(self, reltype: str, target: Part | str, rId: str, is_external: bool = ...): # -> _Relationship:
        """Return newly added |_Relationship| instance of `reltype`.

        The new relationship relates the `target` part to this part with key `rId`.

        Target mode is set to ``RTM.EXTERNAL`` if `is_external` is |True|. Intended for
        use during load from a serialized package, where the rId is well-known. Other
        methods exist for adding a new relationship to a part when manipulating a part.
        """
        ...
    
    @property
    def package(self): # -> Package | None:
        """|OpcPackage| instance this part belongs to."""
        ...
    
    @property
    def partname(self): # -> PackURI:
        """|PackURI| instance holding partname of this part, e.g.
        '/ppt/slides/slide1.xml'."""
        ...
    
    @partname.setter
    def partname(self, partname: str): # -> None:
        ...
    
    def part_related_by(self, reltype: str) -> Part:
        """Return part to which this part has a relationship of `reltype`.

        Raises |KeyError| if no such relationship is found and |ValueError| if more than
        one such relationship is found. Provides ability to resolve implicitly related
        part, such as Slide -> SlideLayout.
        """
        ...
    
    def relate_to(self, target: Part | str, reltype: str, is_external: bool = ...) -> str:
        """Return rId key of relationship of `reltype` to `target`.

        The returned `rId` is from an existing relationship if there is one, otherwise a
        new relationship is created.
        """
        ...
    
    @property
    def related_parts(self): # -> dict[str, Any]:
        """Dictionary mapping related parts by rId, so child objects can resolve
        explicit relationships present in the part XML, e.g. sldIdLst to a specific
        |Slide| instance."""
        ...
    
    @lazyproperty
    def rels(self): # -> Relationships:
        """|Relationships| instance holding the relationships for this part."""
        ...
    
    def target_ref(self, rId: str) -> str:
        """Return URL contained in target ref of relationship identified by `rId`."""
        ...
    


class PartFactory:
    """Provides a way for client code to specify a subclass of |Part| to be constructed
    by |Unmarshaller| based on its content type and/or a custom callable.

    Setting ``PartFactory.part_class_selector`` to a callable object will cause that
    object to be called with the parameters ``content_type, reltype``, once for each
    part in the package. If the callable returns an object, it is used as the class for
    that part. If it returns |None|, part class selection falls back to the content type
    map defined in ``PartFactory.part_type_for``. If no class is returned from either of
    these, the class contained in ``PartFactory.default_part_type`` is used to construct
    the part, which is by default ``opc.package.Part``.
    """
    part_class_selector: Callable[[str, str], Type[Part] | None] | None
    part_type_for: dict[str, Type[Part]] = ...
    default_part_type = Part
    def __new__(cls, partname: PackURI, content_type: str, reltype: str, blob: bytes, package: Package): # -> Part:
        ...
    


class XmlPart(Part):
    """Base class for package parts containing an XML payload, which is most of them.

    Provides additional methods to the |Part| base class that take care of parsing and
    reserializing the XML payload and managing relationships to other parts.
    """
    def __init__(self, partname: PackURI, content_type: str, element: BaseOxmlElement, package: Package) -> None:
        ...
    
    @property
    def blob(self): # -> bytes:
        ...
    
    @property
    def element(self): # -> BaseOxmlElement:
        """The root XML element of this XML part."""
        ...
    
    @classmethod
    def load(cls, partname: PackURI, content_type: str, blob: bytes, package: Package): # -> Self:
        ...
    
    @property
    def part(self): # -> Self:
        """Part of the parent protocol, "children" of the document will not know the
        part that contains them so must ask their parent object.

        That chain of delegation ends here for child objects.
        """
        ...
    


