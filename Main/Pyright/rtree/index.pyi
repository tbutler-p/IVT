"""
This type stub file was generated by pyright.
"""

import ctypes
from collections.abc import Iterator, Sequence
from typing import Any, Literal, overload

RT_Memory = ...
RT_Disk = ...
RT_Custom = ...
RT_Linear = ...
RT_Quadratic = ...
RT_Star = ...
RT_RTree = ...
RT_MVRTree = ...
RT_TPRTree = ...
__c_api_version__ = ...
if (major_version, minor_version, patch_version) < (1, 8, 5):
    ...
__all__ = ["Rtree", "Index", "Property"]
class Index:
    """An R-Tree, MVR-Tree, or TPR-Tree indexing object"""
    def __init__(self, *args: Any, **kwargs: Any) -> None:
        """Creates a new index

        :param filename:
            The first argument in the constructor is assumed to be a filename
            determining that a file-based storage for the index should be used.
            If the first argument is not of type basestring, it is then assumed
            to be an instance of ICustomStorage or derived class.
            If the first argument is neither of type basestring nor an instance
            of ICustomStorage, it is then assumed to be an input index item
            stream.

        :param stream:
            If the first argument in the constructor is not of type basestring,
            it is assumed to be an iterable stream of data that will raise a
            StopIteration.  It must be in the form defined by the
            :attr:`interleaved` attribute of the index. The following example
            would assume :attr:`interleaved` is False::

                (id,
                 (minx, maxx, miny, maxy, minz, maxz, ..., ..., mink, maxk),
                 object)

            The object can be None, but you must put a place holder of
            ``None`` there.

            For a TPR-Tree, this would be in the form::

                (id,
                 ((minx, maxx, miny, maxy, ..., ..., mink, maxk),
                  (minvx, maxvx, minvy, maxvy, ..., ..., minvk, maxvk),
                  time),
                 object)

        :param storage:
            If the first argument in the constructor is an instance of
            ICustomStorage then the given custom storage is used.

        :param interleaved: True or False, defaults to True.
            This parameter determines the coordinate order for all methods that
            take in coordinates.

        :param properties: An :class:`index.Property` object.
            This object sets both the creation and instantiation properties
            for the object and they are passed down into libspatialindex.
            A few properties are curried from instantiation parameters
            for you like ``pagesize`` and ``overwrite``
            to ensure compatibility with previous versions of the library.  All
            other properties must be set on the object.

        .. warning::
            The coordinate ordering for all functions are sensitive the
            index's :attr:`interleaved` data member.  If :attr:`interleaved`
            is False, the coordinates must be in the form
            [xmin, xmax, ymin, ymax, ..., ..., kmin, kmax]. If
            :attr:`interleaved` is True, the coordinates must be in the form
            [xmin, ymin, ..., kmin, xmax, ymax, ..., kmax]. This also applies
            to velocities when using a TPR-Tree.

        A basic example
        ::

            >>> from rtree import index
            >>> p = index.Property()

            >>> idx = index.Index(properties=p)
            >>> idx  # doctest: +NORMALIZE_WHITESPACE
            rtree.index.Index(bounds=[1.7976931348623157e+308,
                                    1.7976931348623157e+308,
                                    -1.7976931348623157e+308,
                                    -1.7976931348623157e+308],
                                    size=0)

        Insert an item into the index::

            >>> idx.insert(4321,
            ...            (34.3776829412, 26.7375853734, 49.3776829412,
            ...             41.7375853734),
            ...            obj=42)

        Query::

            >>> hits = idx.intersection((0, 0, 60, 60), objects=True)
            >>> for i in hits:
            ...     if i.id == 4321:
            ...         i.object
            ...         i.bbox
            ... # doctest: +ELLIPSIS
            42
            [34.37768294..., 26.73758537..., 49.37768294..., 41.73758537...]


        Using custom serializers::

            >>> class JSONIndex(index.Index):
            ...     def dumps(self, obj):
            ...         # This import is nested so that the doctest doesn't
            ...         # require simplejson.
            ...         import simplejson
            ...         return simplejson.dumps(obj).encode('ascii')
            ...
            ...     def loads(self, string):
            ...         import simplejson
            ...         return simplejson.loads(string.decode('ascii'))

            >>> stored_obj = {"nums": [23, 45], "letters": "abcd"}
            >>> json_idx = JSONIndex()
            >>> try:
            ...     json_idx.insert(1, (0, 1, 0, 1), stored_obj)
            ...     list(json_idx.nearest((0, 0), 1,
            ...                           objects="raw")) == [stored_obj]
            ... except ImportError:
            ...     True
            True

        """
        ...
    
    def get_size(self) -> int:
        ...
    
    def __len__(self) -> int:
        """The number of entries in the index.

        :return: number of entries
        """
        ...
    
    def __repr__(self) -> str:
        ...
    
    def __getstate__(self) -> dict[str, Any]:
        ...
    
    def __setstate__(self, state: dict[str, Any]) -> None:
        ...
    
    def dumps(self, obj: object) -> bytes:
        ...
    
    def loads(self, string: bytes) -> object:
        ...
    
    def close(self) -> None:
        """Force a flush of the index to storage. Renders index
        inaccessible."""
        ...
    
    def flush(self) -> None:
        """Force a flush of the index to storage."""
        ...
    
    def get_coordinate_pointers(self, coordinates: Sequence[float]) -> tuple[float, float]:
        ...
    
    def set_result_limit(self, value): # -> Any:
        ...
    
    def get_result_limit(self): # -> Any:
        ...
    
    result_limit = ...
    def set_result_offset(self, value): # -> Any:
        ...
    
    def get_result_offset(self): # -> Any:
        ...
    
    result_offset = ...
    def insert(self, id: int, coordinates: Any, obj: object = ...) -> None:
        """Inserts an item into the index with the given coordinates.

        :param id: A long integer that is the identifier for this index entry.  IDs
            need not be unique to be inserted into the index, and it is up
            to the user to ensure they are unique if this is a requirement.

        :param coordinates: This may be an object that satisfies the numpy array
            protocol, providing the index's dimension * 2 coordinate
            pairs representing the `mink` and `maxk` coordinates in
            each dimension defining the bounds of the query window.
            For a TPR-Tree, this must be a 3-element sequence including
            not only the positional coordinate pairs but also the
            velocity pairs `minvk` and `maxvk` and a time value as a float.

        :param obj: a pickleable object.  If not None, this object will be
            stored in the index with the :attr:`id`.

        The following example inserts an entry into the index with id `4321`,
        and the object it stores with that id is the number `42`.  The
        coordinate ordering in this instance is the default (interleaved=True)
        ordering::

            >>> from rtree import index
            >>> idx = index.Index()
            >>> idx.insert(4321,
            ...            (34.3776829412, 26.7375853734, 49.3776829412,
            ...             41.7375853734),
            ...            obj=42)

        This example is inserting the same object for a TPR-Tree, additionally
        including a set of velocities at time `3`::

            >>> p = index.Property(type=index.RT_TPRTree)  # doctest: +SKIP
            >>> idx = index.Index(properties=p)  # doctest: +SKIP
            >>> idx.insert(4321,
            ...            ((34.3776829412, 26.7375853734, 49.3776829412,
            ...             41.7375853734),
            ...             (0.5, 2, 1.5, 2.5),
            ...            3.0),
            ...            obj=42)  # doctest: +SKIP

        """
        ...
    
    add = ...
    def count(self, coordinates: Any) -> int:
        """Return number of objects that intersect the given coordinates.

        :param coordinates: This may be an object that satisfies the numpy array
            protocol, providing the index's dimension * 2 coordinate
            pairs representing the `mink` and `maxk` coordinates in
            each dimension defining the bounds of the query window.
            For a TPR-Tree, this must be a 3-element sequence including
            not only the positional coordinate pairs but also the
            velocity pairs `minvk` and `maxvk` and a time pair for the
            time range as a float.

        The following example queries the index for any objects any objects
        that were stored in the index intersect the bounds given in the
        coordinates::

            >>> from rtree import index
            >>> idx = index.Index()
            >>> idx.insert(4321,
            ...            (34.3776829412, 26.7375853734, 49.3776829412,
            ...             41.7375853734),
            ...            obj=42)

            >>> print(idx.count((0, 0, 60, 60)))
            1

        This example is similar for a TPR-Tree::

            >>> p = index.Property(type=index.RT_TPRTree)  # doctest: +SKIP
            >>> idx = index.Index(properties=p)  # doctest: +SKIP
            >>> idx.insert(4321,
            ...            ((34.3776829412, 26.7375853734, 49.3776829412,
            ...             41.7375853734),
            ...             (0.5, 2, 1.5, 2.5),
            ...             3.0),
            ...            obj=42)  # doctest: +SKIP

            >>> print(idx.count(((0, 0, 60, 60), (0, 0, 0, 0), (3, 5))))
            ... # doctest: +SKIP
            1

        """
        ...
    
    @overload
    def contains(self, coordinates: Any, objects: Literal[True]) -> Iterator[Item]:
        ...
    
    @overload
    def contains(self, coordinates: Any, objects: Literal[False] = ...) -> Iterator[int] | None:
        ...
    
    @overload
    def contains(self, coordinates: Any, objects: Literal["raw"]) -> Iterator[object]:
        ...
    
    def contains(self, coordinates: Any, objects: bool | Literal["raw"] = ...) -> Iterator[Item | int | object] | None:
        """Return ids or objects in the index that contains within the given
        coordinates.

        :param coordinates: This may be an object that satisfies the numpy array
            protocol, providing the index's dimension * 2 coordinate
            pairs representing the `mink` and `maxk` coordinates in
            each dimension defining the bounds of the query window.

        :param objects: If True, the intersection method will return index objects that
            were pickled when they were stored with each index entry, as well
            as the id and bounds of the index entries. If 'raw', the objects
            will be returned without the :class:`rtree.index.Item` wrapper.

        The following example queries the index for any objects any objects
        that were stored in the index intersect the bounds given in the
        coordinates::

            >>> from rtree import index
            >>> idx = index.Index()
            >>> idx.insert(4321,
            ...            (34.3776829412, 26.7375853734, 49.3776829412,
            ...             41.7375853734),
            ...            obj=42)

            >>> hits = list(idx.contains((0, 0, 60, 60), objects=True))
            ... # doctest: +NORMALIZE_WHITESPACE +ELLIPSIS +SKIP
            >>> [(item.object, item.bbox) for item in hits if item.id == 4321]
            ... # doctest: +NORMALIZE_WHITESPACE +ELLIPSIS +SKIP
            [(42, [34.37768294..., 26.73758537..., 49.37768294...,
                   41.73758537...])]

        If the :class:`rtree.index.Item` wrapper is not used, it is faster to
        request the 'raw' objects::

            >>> list(idx.contains((0, 0, 60, 60), objects="raw"))
            ... # doctest: +NORMALIZE_WHITESPACE +ELLIPSIS +SKIP
            [42]

        """
        ...
    
    def __and__(self, other: Index) -> Index:
        """Take the intersection of two Index objects.

        :param other: another index
        :return: a new index
        :raises AssertionError: if self and other have different interleave or dimension
        """
        ...
    
    def __or__(self, other: Index) -> Index:
        """Take the union of two Index objects.

        :param other: another index
        :return: a new index
        :raises AssertionError: if self and other have different interleave or dimension
        """
        ...
    
    @overload
    def intersection(self, coordinates: Any, objects: Literal[True]) -> Iterator[Item]:
        ...
    
    @overload
    def intersection(self, coordinates: Any, objects: Literal[False] = ...) -> Iterator[int]:
        ...
    
    @overload
    def intersection(self, coordinates: Any, objects: Literal["raw"]) -> Iterator[object]:
        ...
    
    def intersection(self, coordinates: Any, objects: bool | Literal["raw"] = ...) -> Iterator[Item | int | object]:
        """Return ids or objects in the index that intersect the given
        coordinates.

        :param coordinates: This may be an object that satisfies the numpy array
            protocol, providing the index's dimension * 2 coordinate
            pairs representing the `mink` and `maxk` coordinates in
            each dimension defining the bounds of the query window.
            For a TPR-Tree, this must be a 3-element sequence including
            not only the positional coordinate pairs but also the
            velocity pairs `minvk` and `maxvk` and a time pair for the
            time range as a float.

        :param objects: If True, the intersection method will return index objects that
            were pickled when they were stored with each index entry, as well
            as the id and bounds of the index entries. If 'raw', the objects
            will be returned without the :class:`rtree.index.Item` wrapper.

        The following example queries the index for any objects any objects
        that were stored in the index intersect the bounds given in the
        coordinates::

            >>> from rtree import index
            >>> idx = index.Index()
            >>> idx.insert(4321,
            ...            (34.3776829412, 26.7375853734, 49.3776829412,
            ...             41.7375853734),
            ...            obj=42)

            >>> hits = list(idx.intersection((0, 0, 60, 60), objects=True))
            >>> [(item.object, item.bbox) for item in hits if item.id == 4321]
            ... # doctest: +NORMALIZE_WHITESPACE +ELLIPSIS
            [(42, [34.37768294..., 26.73758537..., 49.37768294...,
                   41.73758537...])]

        If the :class:`rtree.index.Item` wrapper is not used, it is faster to
        request the 'raw' objects::

            >>> list(idx.intersection((0, 0, 60, 60), objects="raw"))
            [42]

        Similar for the TPR-Tree::

            >>> p = index.Property(type=index.RT_TPRTree)  # doctest: +SKIP
            >>> idx = index.Index(properties=p)  # doctest: +SKIP
            >>> idx.insert(4321,
            ...            ((34.3776829412, 26.7375853734, 49.3776829412,
            ...             41.7375853734),
            ...             (0.5, 2, 1.5, 2.5),
            ...             3.0),
            ...            obj=42)  # doctest: +SKIP

            >>> hits = list(idx.intersection(
            ...     ((0, 0, 60, 60), (0, 0, 0, 0), (3, 5)), objects=True))
            ...  # doctest: +SKIP
            >>> [(item.object, item.bbox) for item in hits if item.id == 4321]
            ... # doctest: +SKIP
            [(42, [34.37768294..., 26.73758537..., 49.37768294...,
                   41.73758537...])]

        """
        ...
    
    @overload
    def nearest(self, coordinates: Any, num_results: int, objects: Literal[True]) -> Iterator[Item]:
        ...
    
    @overload
    def nearest(self, coordinates: Any, num_results: int, objects: Literal[False] = ...) -> Iterator[int]:
        ...
    
    @overload
    def nearest(self, coordinates: Any, num_results: int, objects: Literal["raw"]) -> Iterator[object]:
        ...
    
    def nearest(self, coordinates: Any, num_results: int = ..., objects: bool | Literal["raw"] = ...) -> Iterator[Item | int | object]:
        """Returns the ``k``-nearest objects to the given coordinates.

        :param coordinates: This may be an object that satisfies the numpy array
            protocol, providing the index's dimension * 2 coordinate
            pairs representing the `mink` and `maxk` coordinates in
            each dimension defining the bounds of the query window.
            For a TPR-Tree, this must be a 3-element sequence including
            not only the positional coordinate pairs but also the
            velocity pairs `minvk` and `maxvk` and a time pair for the
            time range as a float.

        :param num_results: The number of results to return nearest to the given
            coordinates. If two index entries are equidistant, *both* are returned.
            This property means that :attr:`num_results` may return more
            items than specified

        :param objects: If True, the nearest method will return index objects that
            were pickled when they were stored with each index entry, as
            well as the id and bounds of the index entries.
            If 'raw', it will return the object as entered into the database
            without the :class:`rtree.index.Item` wrapper.

        .. warning::
            This is currently not implemented for the TPR-Tree.

        Example of finding the three items nearest to this one::

            >>> from rtree import index
            >>> idx = index.Index()
            >>> idx.insert(4321, (34.37, 26.73, 49.37, 41.73), obj=42)
            >>> hits = idx.nearest((0, 0, 10, 10), 3, objects=True)
        """
        ...
    
    def intersection_v(self, mins, maxs): # -> tuple[ndarray[_Shape, dtype[signedinteger[_64Bit]]], _Array1D[unsignedinteger[_64Bit]]]:
        """Bulk intersection query for obtaining the ids of entries
        which intersect with the provided bounding boxes.  The return
        value is a tuple consisting of two 1D NumPy arrays: one of
        intersecting ids and another containing the counts for each
        bounding box.

        :param mins: A NumPy array of shape `(n, d)` containing the
            minima to query.

        :param maxs: A NumPy array of shape `(n, d)` containing the
            maxima to query.
        """
        ...
    
    def nearest_v(self, mins, maxs, *, num_results=..., max_dists=..., strict=..., return_max_dists=...): # -> tuple[ndarray[_Shape, dtype[signedinteger[_64Bit]]], _Array1D[unsignedinteger[_64Bit]], NDArray[float64] | _Array1D[float64] | None] | tuple[ndarray[_Shape, dtype[signedinteger[_64Bit]]], _Array1D[unsignedinteger[_64Bit]]]:
        """Bulk ``k``-nearest query for the given bounding boxes.  The
        return value is a tuple consisting of, by default, two 1D NumPy
        arrays: one of intersecting ids and another containing the
        counts for each bounding box.

        :param mins: A NumPy array of shape `(n, d)` containing the
            minima to query.

        :param maxs: A NumPy array of shape `(n, d)` containing the
            maxima to query.

        :param num_results: The maximum number of neighbors to return
            for each bounding box.  If there are multiple equidistant
            furthest neighbors then, by default, they are *all*
            returned.  Hence, the actual number of results can be
            greater than requested.

        :param max_dists: Optional; a NumPy array of shape `(n,)`
            containing the maximum distance to consider for each
            bounding box.

        :param strict: If True then each point will never return more
            than `num_results` even in cases of equidistant furthest
            neighbors.

        :param return_max_dists: If True, the distance of the furthest
            neighbor for each bounding box will also be returned.
        """
        ...
    
    def get_bounds(self, coordinate_interleaved=...): # -> list[Any] | list[object] | None:
        """Returns the bounds of the index

        :param coordinate_interleaved: If True, the coordinates are turned
            in the form [xmin, ymin, ..., kmin, xmax, ymax, ..., kmax],
            otherwise they are returned as
            [xmin, xmax, ymin, ymax, ..., ..., kmin, kmax].  If not specified,
            the :attr:`interleaved` member of the index is used, which
            defaults to True.
        """
        ...
    
    bounds = ...
    def delete(self, id: int, coordinates: Any) -> None:
        """Deletes an item from the index with the given ``'id'`` and
           coordinates given by the ``coordinates`` sequence. As the index can
           contain multiple items with the same ID and coordinates, deletion
           is not guaranteed to delete all items in the index with the given ID
           and coordinates.

        :param id: A long integer ID for the entry, which need not be unique. The
            index can contain multiple entries with identical IDs and
            coordinates. Uniqueness of items should be enforced at the
            application level by the user.

        :param coordinates: Dimension * 2 coordinate pairs, representing the min
            and max coordinates in each dimension of the item to be
            deleted from the index. Their ordering will depend on the
            index's :attr:`interleaved` data member.
            These are not the coordinates of a space containing the
            item, but those of the item itself. Together with the
            id parameter, they determine which item will be deleted.
            This may be an object that satisfies the numpy array protocol.
            For a TPR-Tree, this must be a 3-element sequence including
            not only the positional coordinate pairs but also the
            velocity pairs `minvk` and `maxvk` and a time pair for the
            original time the object was inserted and the current time
            as a float.

        Example::

            >>> from rtree import index
            >>> idx = index.Index()
            >>> idx.delete(4321,
            ...            (34.3776829412, 26.7375853734, 49.3776829412,
            ...             41.7375853734))

        For the TPR-Tree::

            >>> p = index.Property(type=index.RT_TPRTree)  # doctest: +SKIP
            >>> idx = index.Index(properties=p)  # doctest: +SKIP
            >>> idx.delete(4321,
            ...            ((34.3776829412, 26.7375853734, 49.3776829412,
            ...             41.7375853734),
            ...             (0.5, 2, 1.5, 2.5),
            ...             (3.0, 5.0)))  # doctest: +SKIP

        """
        ...
    
    def valid(self) -> bool:
        ...
    
    def clearBuffer(self): # -> Any:
        ...
    
    @classmethod
    def deinterleave(self, interleaved: Sequence[object]) -> list[object]:
        """
        [xmin, ymin, xmax, ymax] => [xmin, xmax, ymin, ymax]

        >>> Index.deinterleave([0, 10, 1, 11])
        [0, 1, 10, 11]

        >>> Index.deinterleave([0, 1, 2, 10, 11, 12])
        [0, 10, 1, 11, 2, 12]

        """
        ...
    
    @classmethod
    def interleave(self, deinterleaved: Sequence[float]) -> list[float]:
        """
        [xmin, xmax, ymin, ymax, zmin, zmax]
            => [xmin, ymin, zmin, xmax, ymax, zmax]

        >>> Index.interleave([0, 1, 10, 11])
        [0, 10, 1, 11]

        >>> Index.interleave([0, 10, 1, 11, 2, 12])
        [0, 1, 2, 10, 11, 12]

        >>> Index.interleave((-1, 1, 58, 62, 22, 24))
        [-1, 58, 22, 1, 62, 24]

        """
        ...
    
    def leaves(self): # -> list[Any]:
        ...
    


Rtree = Index
class Item:
    """A container for index entries"""
    __slots__ = ...
    def __init__(self, loads, handle, owned=...) -> None:
        """There should be no reason to instantiate these yourself. Items are
        created automatically when you call
        :meth:`rtree.index.Index.intersection` (or other index querying
        methods) with objects=True given the parameters of the function."""
        ...
    
    def __lt__(self, other: Item) -> bool:
        ...
    
    def __gt__(self, other: Item) -> bool:
        ...
    
    @property
    def bbox(self) -> list[float]:
        """Returns the bounding box of the index entry"""
        ...
    
    def get_object(self, loads): # -> None:
        ...
    


class InvalidHandleException(Exception):
    """Handle has been destroyed and can no longer be used"""
    ...


class Handle:
    def __init__(self, *args: Any, **kwargs: Any) -> None:
        ...
    
    def destroy(self) -> None:
        ...
    
    def __del__(self) -> None:
        ...
    


class IndexHandle(Handle):
    _create = ...
    _destroy = ...
    def flush(self) -> None:
        ...
    


class IndexStreamHandle(IndexHandle):
    _create = ...


class IndexArrayHandle(IndexHandle):
    _create = ...


class PropertyHandle(Handle):
    _create = ...
    _destroy = ...


class Property:
    """An index property object is a container that contains a number of
    settable index properties.  Many of these properties must be set at
    index creation times, while others can be used to adjust performance
    or behavior."""
    pkeys = ...
    def __init__(self, handle=..., owned: bool = ..., **kwargs: Any) -> None:
        ...
    
    def initialize_from_dict(self, state: dict[str, Any]) -> None:
        ...
    
    def __getstate__(self) -> dict[Any, Any]:
        ...
    
    def __setstate__(self, state): # -> None:
        ...
    
    def as_dict(self) -> dict[str, Any]:
        ...
    
    def __repr__(self) -> str:
        ...
    
    def __str__(self) -> str:
        ...
    
    def get_index_type(self) -> int:
        ...
    
    def set_index_type(self, value: int) -> None:
        ...
    
    type = ...
    def get_variant(self) -> int:
        ...
    
    def set_variant(self, value: int) -> None:
        ...
    
    variant = ...
    def get_dimension(self) -> int:
        ...
    
    def set_dimension(self, value: int) -> None:
        ...
    
    dimension = ...
    def get_storage(self) -> int:
        ...
    
    def set_storage(self, value: int) -> None:
        ...
    
    storage = ...
    def get_pagesize(self) -> int:
        ...
    
    def set_pagesize(self, value: int) -> None:
        ...
    
    pagesize = ...
    def get_index_capacity(self) -> int:
        ...
    
    def set_index_capacity(self, value: int) -> None:
        ...
    
    index_capacity = ...
    def get_leaf_capacity(self) -> int:
        ...
    
    def set_leaf_capacity(self, value: int) -> None:
        ...
    
    leaf_capacity = ...
    def get_index_pool_capacity(self) -> int:
        ...
    
    def set_index_pool_capacity(self, value: int) -> None:
        ...
    
    index_pool_capacity = ...
    def get_point_pool_capacity(self) -> int:
        ...
    
    def set_point_pool_capacity(self, value: int) -> None:
        ...
    
    point_pool_capacity = ...
    def get_region_pool_capacity(self) -> int:
        ...
    
    def set_region_pool_capacity(self, value: int) -> None:
        ...
    
    region_pool_capacity = ...
    def get_buffering_capacity(self) -> int:
        ...
    
    def set_buffering_capacity(self, value: int) -> None:
        ...
    
    buffering_capacity = ...
    def get_tight_mbr(self): # -> bool:
        ...
    
    def set_tight_mbr(self, value): # -> bool:
        ...
    
    tight_mbr = ...
    def get_overwrite(self): # -> bool:
        ...
    
    def set_overwrite(self, value): # -> bool:
        ...
    
    overwrite = ...
    def get_near_minimum_overlap_factor(self) -> int:
        ...
    
    def set_near_minimum_overlap_factor(self, value: int) -> None:
        ...
    
    near_minimum_overlap_factor = ...
    def get_writethrough(self): # -> bool:
        ...
    
    def set_writethrough(self, value): # -> bool:
        ...
    
    writethrough = ...
    def get_fill_factor(self) -> int:
        ...
    
    def set_fill_factor(self, value: int) -> None:
        ...
    
    fill_factor = ...
    def get_split_distribution_factor(self) -> int:
        ...
    
    def set_split_distribution_factor(self, value: int) -> None:
        ...
    
    split_distribution_factor = ...
    def get_tpr_horizon(self): # -> Any:
        ...
    
    def set_tpr_horizon(self, value): # -> Any:
        ...
    
    tpr_horizon = ...
    def get_reinsert_factor(self): # -> Any:
        ...
    
    def set_reinsert_factor(self, value): # -> Any:
        ...
    
    reinsert_factor = ...
    def get_filename(self): # -> Any:
        ...
    
    def set_filename(self, value): # -> Any:
        ...
    
    filename = ...
    def get_dat_extension(self): # -> Any:
        ...
    
    def set_dat_extension(self, value): # -> Any:
        ...
    
    dat_extension = ...
    def get_idx_extension(self): # -> Any:
        ...
    
    def set_idx_extension(self, value): # -> Any:
        ...
    
    idx_extension = ...
    def get_custom_storage_callbacks_size(self) -> int:
        ...
    
    def set_custom_storage_callbacks_size(self, value: int) -> None:
        ...
    
    custom_storage_callbacks_size = ...
    def get_custom_storage_callbacks(self): # -> Any:
        ...
    
    def set_custom_storage_callbacks(self, value): # -> Any:
        ...
    
    custom_storage_callbacks = ...
    def get_index_id(self): # -> Any:
        ...
    
    def set_index_id(self, value): # -> Any:
        ...
    
    index_id = ...


id_type = ctypes.c_int64
class CustomStorageCallbacks(ctypes.Structure):
    createCallbackType = ...
    destroyCallbackType = ...
    flushCallbackType = ...
    loadCallbackType = ...
    storeCallbackType = ...
    deleteCallbackType = ...
    _fields_ = ...
    def __init__(self, context, createCallback, destroyCallback, flushCallback, loadCallback, storeCallback, deleteCallback) -> None:
        ...
    


class ICustomStorage:
    NoError = ...
    InvalidPageError = ...
    IllegalStateError = ...
    EmptyPage = ...
    NewPage = ...
    def allocateBuffer(self, length): # -> Any:
        ...
    
    def registerCallbacks(self, properties):
        ...
    
    def clear(self):
        ...
    
    hasData = ...


class CustomStorageBase(ICustomStorage):
    """Derive from this class to create your own storage manager with access
    to the raw C buffers."""
    def registerCallbacks(self, properties): # -> None:
        ...
    
    def create(self, context, returnError):
        ...
    
    def destroy(self, context, returnError):
        """please override"""
        ...
    
    def loadByteArray(self, context, page, resultLen, resultData, returnError):
        """please override"""
        ...
    
    def storeByteArray(self, context, page, len, data, returnError):
        """please override"""
        ...
    
    def deleteByteArray(self, context, page, returnError):
        """please override"""
        ...
    
    def flush(self, context, returnError):
        """please override"""
        ...
    


class CustomStorage(ICustomStorage):
    """Provides a useful default custom storage implementation which marshals
    the buffers on the C side from/to python strings.
    Derive from this class and override the necessary methods to provide
    your own custom storage manager."""
    def registerCallbacks(self, properties): # -> None:
        ...
    
    def create(self, returnError):
        """Must be overridden. No return value."""
        ...
    
    def destroy(self, returnError):
        """Must be overridden. No return value."""
        ...
    
    def flush(self, returnError):
        """Must be overridden. No return value."""
        ...
    
    def loadByteArray(self, page, returnError):
        """Must be overridden. Must return a string with the loaded data."""
        ...
    
    def storeByteArray(self, page, data, returnError):
        """Must be overridden. Must return the new 64-bit page ID of the stored
        data if a new page had to be created (i.e. page is not NewPage)."""
        ...
    
    def deleteByteArray(self, page, returnError):
        """please override"""
        ...
    


class RtreeContainer(Rtree):
    """An R-Tree, MVR-Tree, or TPR-Tree indexed container for python objects"""
    def __init__(self, *args: Any, **kwargs: Any) -> None:
        """Creates a new index

        :param stream:
            If the first argument in the constructor is not of type basestring,
            it is assumed to be an iterable stream of data that will raise a
            StopIteration.  It must be in the form defined by the
            :attr:`interleaved` attribute of the index. The following example
            would assume :attr:`interleaved` is False::

                (obj,
                 (minx, maxx, miny, maxy, minz, maxz, ..., ..., mink, maxk))

            For a TPR-Tree, this would be in the form::

                (id,
                 ((minx, maxx, miny, maxy, ..., ..., mink, maxk),
                  (minvx, maxvx, minvy, maxvy, ..., ..., minvk, maxvk),
                  time),
                 object)

        :param interleaved: True or False, defaults to True.
            This parameter determines the coordinate order for all methods that
            take in coordinates.

        :param properties: This object sets both the creation and instantiation
            properties for the object and they are passed down into libspatialindex.
            A few properties are curried from instantiation parameters
            for you like ``pagesize`` to ensure compatibility with previous
            versions of the library.  All other properties must be set on the
            object.

        .. warning::
            The coordinate ordering for all functions are sensitive the
            index's :attr:`interleaved` data member.  If :attr:`interleaved`
            is False, the coordinates must be in the form
            [xmin, xmax, ymin, ymax, ..., ..., kmin, kmax]. If
            :attr:`interleaved` is True, the coordinates must be in the form
            [xmin, ymin, ..., kmin, xmax, ymax, ..., kmax]. This also applies
            to velocities when using a TPR-Tree.

        A basic example
        ::

            >>> from rtree import index
            >>> p = index.Property()

            >>> idx = index.RtreeContainer(properties=p)
            >>> idx  # doctest: +NORMALIZE_WHITESPACE
            rtree.index.RtreeContainer(bounds=[1.7976931348623157e+308,
                                     1.7976931348623157e+308,
                                     -1.7976931348623157e+308,
                                     -1.7976931348623157e+308],
                                     size=0)

        Insert an item into the index::

            >>> idx.insert(object(),
            ...            (34.3776829412, 26.7375853734, 49.3776829412,
            ...             41.7375853734))

        Query::

            >>> hits = idx.intersection((0, 0, 60, 60), bbox=True)
            >>> for obj in hits:
            ...     obj.object
            ...     obj.bbox  # doctest: +ELLIPSIS
            <object object at 0x...>
            [34.37768294..., 26.73758537..., 49.37768294..., 41.73758537...]
        """
        ...
    
    def get_size(self) -> int:
        ...
    
    def __repr__(self) -> str:
        ...
    
    def __contains__(self, obj: object) -> bool:
        ...
    
    def __len__(self) -> int:
        ...
    
    def __iter__(self) -> Iterator[object]:
        ...
    
    def insert(self, obj: object, coordinates: Any) -> None:
        """Inserts an item into the index with the given coordinates.

        :param obj: Any object.

        :param coordinates: This may be an object that satisfies the numpy array
            protocol, providing the index's dimension * 2 coordinate
            pairs representing the `mink` and `maxk` coordinates in
            each dimension defining the bounds of the query window.
            For a TPR-Tree, this must be a 3-element sequence including
            not only the positional coordinate pairs but also the
            velocity pairs `minvk` and `maxvk` and a time value as a float.

        The following example inserts a simple object into the container.
        The coordinate ordering in this instance is the default
        (interleaved=True) ordering::

            >>> from rtree import index
            >>> idx = index.RtreeContainer()
            >>> idx.insert(object(),
            ...            (34.3776829412, 26.7375853734, 49.3776829412,
            ...             41.7375853734))

        Similar for TPR-Tree::

            >>> p = index.Property(type=index.RT_TPRTree)  # doctest: +SKIP
            >>> idx = index.RtreeContainer(properties=p)  # doctest: +SKIP
            >>> idx.insert(object(),
            ...            ((34.3776829412, 26.7375853734, 49.3776829412,
            ...             41.7375853734),
            ...             (0.5, 2, 1.5, 2.5),
            ...            3.0))  # doctest: +SKIP

        """
        ...
    
    add = ...
    @overload
    def intersection(self, coordinates: Any, bbox: Literal[True]) -> Iterator[Item]:
        ...
    
    @overload
    def intersection(self, coordinates: Any, bbox: Literal[False] = ...) -> Iterator[object]:
        ...
    
    def intersection(self, coordinates: Any, bbox: bool = ...) -> Iterator[Item | object]:
        """Return ids or objects in the index that intersect the given
        coordinates.

        :param coordinates: This may be an object that satisfies the numpy array
            protocol, providing the index's dimension * 2 coordinate
            pairs representing the `mink` and `maxk` coordinates in
            each dimension defining the bounds of the query window.
            For a TPR-Tree, this must be a 3-element sequence including
            not only the positional coordinate pairs but also the
            velocity pairs `minvk` and `maxvk` and a time pair for the
            time range as a float.

        :param bbox: If True, the intersection method will return the stored objects,
            as well as the bounds of the entry.

        The following example queries the container for any stored objects that
        intersect the bounds given in the coordinates::

            >>> from rtree import index
            >>> idx = index.RtreeContainer()
            >>> idx.insert(object(),
            ...            (34.3776829412, 26.7375853734, 49.3776829412,
            ...             41.7375853734))

            >>> hits = list(idx.intersection((0, 0, 60, 60), bbox=True))
            >>> [(item.object, item.bbox) for item in hits]
            ... # doctest: +ELLIPSIS +NORMALIZE_WHITESPACE
            [(<object object at 0x...>, [34.3776829412, 26.7375853734,
            49.3776829412, 41.7375853734])]

        If the :class:`rtree.index.Item` wrapper is not used, it is faster to
        request only the stored objects::

            >>> list(idx.intersection((0, 0, 60, 60)))   # doctest: +ELLIPSIS
            [<object object at 0x...>]

        Similar for the TPR-Tree::

            >>> p = index.Property(type=index.RT_TPRTree)  # doctest: +SKIP
            >>> idx = index.RtreeContainer(properties=p)  # doctest: +SKIP
            >>> idx.insert(object(),
            ...            ((34.3776829412, 26.7375853734, 49.3776829412,
            ...             41.7375853734),
            ...             (0.5, 2, 1.5, 2.5),
            ...             3.0))  # doctest: +SKIP

            >>> hits = list(idx.intersection(
            ...     ((0, 0, 60, 60), (0, 0, 0, 0), (3, 5)), bbox=True))
            ... # doctest: +SKIP
            >>> [(item.object, item.bbox) for item in hits]
            ... # doctest: +SKIP
            [(<object object at 0x...>, [34.3776829412, 26.7375853734,
            49.3776829412, 41.7375853734])]

        """
        ...
    
    @overload
    def nearest(self, coordinates: Any, num_results: int = ..., bbox: Literal[True] = ...) -> Iterator[Item]:
        ...
    
    @overload
    def nearest(self, coordinates: Any, num_results: int = ..., bbox: Literal[False] = ...) -> Iterator[object]:
        ...
    
    def nearest(self, coordinates: Any, num_results: int = ..., bbox: bool = ...) -> Iterator[Item | object]:
        """Returns the ``k``-nearest objects to the given coordinates
        in increasing distance order.

        :param coordinates: This may be an object that satisfies the numpy array
            protocol, providing the index's dimension * 2 coordinate
            pairs representing the `mink` and `maxk` coordinates in
            each dimension defining the bounds of the query window.
            For a TPR-Tree, this must be a 3-element sequence including
            not only the positional coordinate pairs but also the
            velocity pairs `minvk` and `maxvk` and a time pair for the
            time range as a float.

        :param num_results: The number of results to return nearest to the given
            coordinates. If two entries are equidistant, *both* are returned.
            This property means that :attr:`num_results` may return more
            items than specified.

        :param bbox: If True, the nearest method will return the stored objects, as
            well as the bounds of the entry.

        .. warning::
            This is currently not implemented for the TPR-Tree.

        Example of finding the three items nearest to this one::

            >>> from rtree import index
            >>> idx = index.RtreeContainer()
            >>> idx.insert(object(), (34.37, 26.73, 49.37, 41.73))
            >>> hits = idx.nearest((0, 0, 10, 10), 3, bbox=True)
        """
        ...
    
    def delete(self, obj: object, coordinates: Any) -> None:
        """Deletes the item from the container within the specified
        coordinates.

        :param obj: Any object.

        :param coordinates: Dimension * 2 coordinate pairs, representing the min
            and max coordinates in each dimension of the item to be
            deleted from the index. Their ordering will depend on the
            index's :attr:`interleaved` data member.
            These are not the coordinates of a space containing the
            item, but those of the item itself. Together with the
            id parameter, they determine which item will be deleted.
            This may be an object that satisfies the numpy array protocol.
            For a TPR-Tree, this must be a 3-element sequence including
            not only the positional coordinate pairs but also the
            velocity pairs `minvk` and `maxvk` and a time pair for the
            original time the object was inserted and the current time
            as a float.

        Example::

            >>> from rtree import index
            >>> idx = index.RtreeContainer()
            >>> idx.delete(object(),
            ...            (34.3776829412, 26.7375853734, 49.3776829412,
            ...             41.7375853734))
            Traceback (most recent call last):
             ...
            IndexError: object is not in the index

        For the TPR-Tree::

            >>> p = index.Property(type=index.RT_TPRTree)  # doctest: +SKIP
            >>> idx = index.RtreeContainer(properties=p)  # doctest: +SKIP
            >>> idx.delete(object(),
            ...            ((34.3776829412, 26.7375853734, 49.3776829412,
            ...             41.7375853734),
            ...             (0.5, 2, 1.5, 2.5),
            ...             (3.0, 5.0)))  # doctest: +SKIP
            Traceback (most recent call last):
             ...
            IndexError: object is not in the index

        """
        ...
    
    def leaves(self): # -> list[tuple[object, list[object], Any]]:
        ...
    


