"""
This type stub file was generated by pyright.
"""

from abc import ABC, abstractmethod
from collections import abc
from random import Random
from typing import Any, Callable, ClassVar, Generic, Iterable, TYPE_CHECKING, TypeVar, TypedDict, overload
from faker import Faker
from typing_extensions import Self, TypeGuard
from polyfactory.field_meta import FieldMeta
from polyfactory.persistence import AsyncPersistenceProtocol, SyncPersistenceProtocol

if TYPE_CHECKING:
    ...
T = TypeVar("T")
U = TypeVar("U")
F = TypeVar("F", bound="BaseFactory[Any]")
class BuildContext(TypedDict):
    seen_models: set[type]
    ...


class BaseFactory(ABC, Generic[T]):
    """Base Factory class - this class holds the main logic of the library"""
    __model__: type[T]
    __check_model__: bool = ...
    __allow_none_optionals__: ClassVar[bool] = ...
    __sync_persistence__: type[SyncPersistenceProtocol[T]] | SyncPersistenceProtocol[T] | None = ...
    __async_persistence__: type[AsyncPersistenceProtocol[T]] | AsyncPersistenceProtocol[T] | None = ...
    __set_as_default_factory_for_type__ = ...
    __is_base_factory__: bool = ...
    __base_factory_overrides__: dict[Any, type[BaseFactory[Any]]] | None = ...
    __faker__: ClassVar[Faker] = ...
    __random__: ClassVar[Random] = ...
    __random_seed__: ClassVar[int]
    __randomize_collection_length__: ClassVar[bool] = ...
    __min_collection_length__: ClassVar[int] = ...
    __max_collection_length__: ClassVar[int] = ...
    __use_defaults__: ClassVar[bool] = ...
    __forward_references__: ClassVar[dict[str, Any]] = ...
    __config_keys__: tuple[str, ...] = ...
    _fields_metadata: list[FieldMeta]
    _factory_type_mapping: ClassVar[dict[Any, type[BaseFactory[Any]]]]
    _base_factories: ClassVar[list[type[BaseFactory[Any]]]]
    _providers: ClassVar[dict[Any, Callable[[], Any]]]
    _extra_providers: dict[Any, Callable[[], Any]] | None = ...
    def __init_subclass__(cls, *args: Any, **kwargs: Any) -> None:
        ...
    
    @classmethod
    def add_provider(cls, provider_type: Any, provider_function: Callable[[], Any]) -> None:
        """Add a provider for a custom type to be available to all factories"""
        ...
    
    @classmethod
    def is_factory_type(cls, annotation: Any) -> bool:
        """Determine whether a given field is annotated with a type that is supported by a base factory.

        :param annotation: A type annotation.
        :returns: Boolean dictating whether the annotation is a factory type
        """
        ...
    
    @classmethod
    def is_batch_factory_type(cls, annotation: Any) -> bool:
        """Determine whether a given field is annotated with a sequence of supported factory types.

        :param annotation: A type annotation.
        :returns: Boolean dictating whether the annotation is a batch factory type
        """
        ...
    
    @classmethod
    def extract_field_build_parameters(cls, field_meta: FieldMeta, build_args: dict[str, Any]) -> Any:
        """Extract from the build kwargs any build parameters passed for a given field meta - if it is a factory type.

        :param field_meta: A field meta instance.
        :param build_args: Any kwargs passed to the factory.
        :returns: Any values
        """
        ...
    
    @classmethod
    @abstractmethod
    def is_supported_type(cls, value: Any) -> TypeGuard[type[T]]:
        """Determine whether the given value is supported by the factory.

        :param value: An arbitrary value.
        :returns: A typeguard
        """
        ...
    
    @classmethod
    def seed_random(cls, seed: int) -> None:
        """Seed faker and random with the given integer.

        :param seed: An integer to set as seed.
        :returns: 'None'

        """
        ...
    
    @classmethod
    def is_ignored_type(cls, value: Any) -> bool:
        """Check whether a given value is an ignored type.

        :param value: An arbitrary value.

        :notes:
            - This method is meant to be overwritten by extension factories and other subclasses

        :returns: A boolean determining whether the value should be ignored.

        """
        ...
    
    @classmethod
    def get_provider_map(cls) -> dict[Any, Callable[[], Any]]:
        """Map types to callables which accept no arguments and return a random value of the given type.

        :notes:
            - This method is distinct to allow overriding.


        :returns: a dictionary mapping types to callables.

        """
        ...
    
    @overload
    @classmethod
    def create_factory(cls, model: None = ..., bases: tuple[type[BaseFactory[Any]], ...] | None = ..., **kwargs: Any) -> type[Self]:
        ...
    
    @overload
    @classmethod
    def create_factory(cls, model: type[U], bases: tuple[type[BaseFactory[Any]], ...] | None = ..., **kwargs: Any) -> type[BaseFactory[U]]:
        ...
    
    @classmethod
    def create_factory(cls, model: type[U] | None = ..., bases: tuple[type[BaseFactory[Any]], ...] | None = ..., **kwargs: Any) -> type[Self | BaseFactory[U]]:
        """Generate a factory for the given type dynamically.

        :param model: A type to model. Defaults to current factory __model__ if any.
            Otherwise, raise an error
        :param bases: Base classes to use when generating the new class.
        :param kwargs: Any kwargs.

        :returns: A 'ModelFactory' subclass.

        """
        ...
    
    @classmethod
    def get_constrained_field_value(cls, annotation: Any, field_meta: FieldMeta, field_build_parameters: Any | None = ..., build_context: BuildContext | None = ...) -> Any:
        ...
    
    @classmethod
    def get_field_value(cls, field_meta: FieldMeta, field_build_parameters: Any | None = ..., build_context: BuildContext | None = ...) -> Any:
        """Return a field value on the subclass if existing, otherwise returns a mock value.

        :param field_meta: FieldMeta instance.
        :param field_build_parameters: Any build parameters passed to the factory as kwarg values.
        :param build_context: BuildContext data for current build.

        :returns: An arbitrary value.

        """
        ...
    
    @classmethod
    def get_field_value_coverage(cls, field_meta: FieldMeta, field_build_parameters: Any | None = ..., build_context: BuildContext | None = ...) -> Iterable[Any]:
        """Return a field value on the subclass if existing, otherwise returns a mock value.

        :param field_meta: FieldMeta instance.
        :param field_build_parameters: Any build parameters passed to the factory as kwarg values.
        :param build_context: BuildContext data for current build.

        :returns: An iterable of values.

        """
        ...
    
    @classmethod
    def should_set_none_value(cls, field_meta: FieldMeta) -> bool:
        """Determine whether a given model field_meta should be set to None.

        :param field_meta: Field metadata.

        :notes:
            - This method is distinct to allow overriding.

        :returns: A boolean determining whether 'None' should be set for the given field_meta.

        """
        ...
    
    @classmethod
    def should_use_default_value(cls, field_meta: FieldMeta) -> bool:
        """Determine whether to use the default value for the given field.

        :param field_meta: FieldMeta instance.

        :notes:
            - This method is distinct to allow overriding.

        :returns: A boolean determining whether the default value should be used for the given field_meta.

        """
        ...
    
    @classmethod
    def should_set_field_value(cls, field_meta: FieldMeta, **kwargs: Any) -> bool:
        """Determine whether to set a value for a given field_name.

        :param field_meta: FieldMeta instance.
        :param kwargs: Any kwargs passed to the factory.

        :notes:
            - This method is distinct to allow overriding.

        :returns: A boolean determining whether a value should be set for the given field_meta.

        """
        ...
    
    @classmethod
    @abstractmethod
    def get_model_fields(cls) -> list[FieldMeta]:
        """Retrieve a list of fields from the factory's model.


        :returns: A list of field MetaData instances.

        """
        ...
    
    @classmethod
    def get_factory_fields(cls) -> list[tuple[str, Any]]:
        """Retrieve a list of fields from the factory.

        Trying to be smart about what should be considered a field on the model,
        ignoring dunder methods and some parent class attributes.

        :returns: A list of tuples made of field name and field definition
        """
        ...
    
    @classmethod
    def process_kwargs(cls, **kwargs: Any) -> dict[str, Any]:
        """Process the given kwargs and generate values for the factory's model.

        :param kwargs: Any build kwargs.

        :returns: A dictionary of build results.

        """
        ...
    
    @classmethod
    def process_kwargs_coverage(cls, **kwargs: Any) -> abc.Iterable[dict[str, Any]]:
        """Process the given kwargs and generate values for the factory's model.

        :param kwargs: Any build kwargs.
        :param build_context: BuildContext data for current build.

        :returns: A dictionary of build results.

        """
        ...
    
    @classmethod
    def build(cls, *_: Any, **kwargs: Any) -> T:
        """Build an instance of the factory's __model__

        :param kwargs: Any kwargs. If field names are set in kwargs, their values will be used.

        :returns: An instance of type T.

        """
        ...
    
    @classmethod
    def batch(cls, size: int, **kwargs: Any) -> list[T]:
        """Build a batch of size n of the factory's Meta.model.

        :param size: Size of the batch.
        :param kwargs: Any kwargs. If field_meta names are set in kwargs, their values will be used.

        :returns: A list of instances of type T.

        """
        ...
    
    @classmethod
    def coverage(cls, **kwargs: Any) -> abc.Iterator[T]:
        """Build a batch of the factory's Meta.model with full coverage of the sub-types of the model.

        :param kwargs: Any kwargs. If field_meta names are set in kwargs, their values will be used.

        :returns: A iterator of instances of type T.

        """
        ...
    
    @classmethod
    def create_sync(cls, **kwargs: Any) -> T:
        """Build and persists synchronously a single model instance.

        :param kwargs: Any kwargs. If field_meta names are set in kwargs, their values will be used.

        :returns: An instance of type T.

        """
        ...
    
    @classmethod
    def create_batch_sync(cls, size: int, **kwargs: Any) -> list[T]:
        """Build and persists synchronously a batch of n size model instances.

        :param size: Size of the batch.
        :param kwargs: Any kwargs. If field_meta names are set in kwargs, their values will be used.

        :returns: A list of instances of type T.

        """
        ...
    
    @classmethod
    async def create_async(cls, **kwargs: Any) -> T:
        """Build and persists asynchronously a single model instance.

        :param kwargs: Any kwargs. If field_meta names are set in kwargs, their values will be used.

        :returns: An instance of type T.
        """
        ...
    
    @classmethod
    async def create_batch_async(cls, size: int, **kwargs: Any) -> list[T]:
        """Build and persists asynchronously a batch of n size model instances.


        :param size: Size of the batch.
        :param kwargs: Any kwargs. If field_meta names are set in kwargs, their values will be used.

        :returns: A list of instances of type T.
        """
        ...
    


