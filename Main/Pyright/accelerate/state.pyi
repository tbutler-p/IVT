"""
This type stub file was generated by pyright.
"""

import threading
import torch
from contextlib import contextmanager
from typing import Any, Callable
from .utils import GradientAccumulationPlugin, deepspeed_required, is_mlu_available, is_musa_available, is_npu_available, is_sdaa_available, is_torch_xla_available

if is_torch_xla_available():
    ...
if is_mlu_available(check_device=False):
    ...
if is_sdaa_available(check_device=False):
    ...
if is_musa_available(check_device=False):
    ...
if is_npu_available(check_device=False):
    ...
logger = ...
def is_initialized() -> bool:
    """
    Checks if the `AcceleratorState` has been initialized from `Accelerator`. Same as `AcceleratorState.initialized`,
    but works as a module method.
    """
    ...

def do_nothing(*args, **kwargs): # -> None:
    ...

class ThreadLocalSharedDict(threading.local):
    """
    Descriptor that holds a dict shared between instances of a class in the same thread.

    Note: Descriptors have slightly different semantics than just a dict field on its own.
    `PartialState(...)._shared_state` and `PartialState._shared_state` (instance vs class) give the same value: the
    underlying _storage dict. Likewise, `PartialState(...)._shared_state = {...}` overrides the _storage dict inside
    the descriptor as you would expect. However, `PartialState._shared_state = {}` actually replaces the descriptor
    object with a dict instead Thus, you should modify the _storage dict in-place (e.g. `_shared_state.clear()`).

    See Python documentation for an explanation of descriptors: https://docs.python.org/3/howto/descriptor.html

    This is required for using PyTorch/XLA with PJRT in multithreaded mode (required for TPU v2 and v3).

    See https://github.com/pytorch/xla/blob/r2.0/docs/pjrt.md#multithreading-on-tpu-v2v3
    """
    def __init__(self, thread_local: bool = ...) -> None:
        ...
    
    def __get__(self, obj, objtype=...): # -> dict[Any, Any]:
        ...
    
    def __set__(self, obj, value): # -> None:
        ...
    


SharedDict = ...
class PartialState:
    """
    Singleton class that has information about the current training environment and functions to help with process
    control. Designed to be used when only process control and device execution states are needed. Does *not* need to
    be initialized from `Accelerator`.

    Args:
        cpu (`bool`, *optional*):
            Whether or not to force the script to execute on CPU. Will ignore any accelerators available if set to
            `True` and force the execution on the CPU.
        kwargs (additional keyword arguments, *optional*):
            Additional keyword arguments to pass to the relevant `init_process_group` function. Valid `kwargs` can be
            found in [`utils.InitProcessGroupKwargs`]. See the example section for detailed usage.

    **Available attributes:**

        - **device** (`torch.device`) -- The device to use.
        - **distributed_type** ([`~accelerate.state.DistributedType`]) -- The type of distributed environment currently
          in use.
        - **local_process_index** (`int`) -- The index of the current process on the current server.
        - **mixed_precision** (`str`) -- Whether or not the current script will use mixed precision, and if so the type
          of mixed precision being performed. (Choose from 'no','fp16','bf16 or 'fp8').
        - **num_processes** (`int`) -- The number of processes currently launched in parallel.
        - **process_index** (`int`) -- The index of the current process.
        - **is_last_process** (`bool`) -- Whether or not the current process is the last one.
        - **is_main_process** (`bool`) -- Whether or not the current process is the main one.
        - **is_local_main_process** (`bool`) -- Whether or not the current process is the main one on the local node.
        - **debug** (`bool`) -- Whether or not the current script is being run in debug mode.

    Example:
    ```python
    from accelerate.utils import InitProcessGroupKwargs

    # To include `InitProcessGroupKwargs`, init then call `.to_kwargs()`
    kwargs = InitProcessGroupKwargs(...).to_kwargs()
    state = PartialState(**kwargs)
    ```
    """
    _shared_state = ...
    _known_attrs = ...
    def __init__(self, cpu: bool = ..., **kwargs) -> None:
        ...
    
    def __repr__(self) -> str:
        ...
    
    @property
    def initialized(self) -> bool:
        "Returns whether the `PartialState` has been initialized"
        ...
    
    @property
    def use_distributed(self): # -> bool:
        """
        Whether the Accelerator is configured for distributed training
        """
        ...
    
    @property
    def is_last_process(self) -> bool:
        "Returns whether the current process is the last one"
        ...
    
    @property
    def is_main_process(self) -> bool:
        "Returns whether the current process is the main process"
        ...
    
    @property
    def is_local_main_process(self) -> bool:
        "Returns whether the current process is the main process on the local node"
        ...
    
    def wait_for_everyone(self): # -> None:
        """
        Will stop the execution of the current process until every other process has reached that point (so this does
        nothing when the script is only run in one process). Useful to do before saving a model.

        Example:

        ```python
        >>> # Assuming two GPU processes
        >>> import time
        >>> from accelerate.state import PartialState

        >>> state = PartialState()
        >>> if state.is_main_process:
        ...     time.sleep(2)
        >>> else:
        ...     print("I'm waiting for the main process to finish its sleep...")
        >>> state.wait_for_everyone()
        >>> # Should print on every process at the same time
        >>> print("Everyone is here")
        ```
        """
        ...
    
    @contextmanager
    def split_between_processes(self, inputs: list | tuple | dict | torch.Tensor, apply_padding: bool = ...): # -> Generator[list[Any] | tuple[Any, ...] | dict[Any, Any] | Tensor | Any | Mapping[Any, Any] | Dataset, Any, None]:
        """
        Splits `input` between `self.num_processes` quickly and can be then used on that process. Useful when doing
        distributed inference, such as with different prompts.

        Note that when using a `dict`, all keys need to have the same number of elements.

        Args:
            inputs (`list`, `tuple`, `torch.Tensor`, `dict` of `list`/`tuple`/`torch.Tensor`, or `datasets.Dataset`):
                The input to split between processes.
            apply_padding (`bool`, `optional`, defaults to `False`):
                Whether to apply padding by repeating the last element of the input so that all processes have the same
                number of elements. Useful when trying to perform actions such as `gather()` on the outputs or passing
                in less inputs than there are processes. If so, just remember to drop the padded elements afterwards.


        Example:

        ```python
        # Assume there are two processes
        from accelerate import PartialState

        state = PartialState()
        with state.split_between_processes(["A", "B", "C"]) as inputs:
            print(inputs)
        # Process 0
        ["A", "B"]
        # Process 1
        ["C"]

        with state.split_between_processes(["A", "B", "C"], apply_padding=True) as inputs:
            print(inputs)
        # Process 0
        ["A", "B"]
        # Process 1
        ["C", "C"]
        ```
        """
        ...
    
    @contextmanager
    def main_process_first(self): # -> Generator[None, Any, None]:
        """
        Lets the main process go first inside a with block.

        The other processes will enter the with block after the main process exits.

        Example:

        ```python
        >>> from accelerate import Accelerator

        >>> accelerator = Accelerator()
        >>> with accelerator.main_process_first():
        ...     # This will be printed first by process 0 then in a seemingly
        ...     # random order by the other processes.
        ...     print(f"This will be printed by process {accelerator.process_index}")
        ```
        """
        ...
    
    @contextmanager
    def local_main_process_first(self): # -> Generator[None, Any, None]:
        """
        Lets the local main process go inside a with block.

        The other processes will enter the with block after the main process exits.

        Example:

        ```python
        >>> from accelerate.state import PartialState

        >>> state = PartialState()
        >>> with state.local_main_process_first():
        ...     # This will be printed first by local process 0 then in a seemingly
        ...     # random order by the other processes.
        ...     print(f"This will be printed by process {state.local_process_index}")
        ```
        """
        ...
    
    def on_main_process(self, function: Callable[..., Any] | None = ...): # -> Callable[..., Any] | Callable[..., None] | None:
        """
        Decorator that only runs the decorated function on the main process.

        Args:
            function (`Callable`): The function to decorate.

        Example:

        ```python
        >>> from accelerate.state import PartialState

        >>> state = PartialState()


        >>> @state.on_main_process
        ... def print_something():
        ...     print("This will be printed by process 0 only.")


        >>> print_something()
        "This will be printed by process 0 only"
        ```
        """
        ...
    
    def on_local_main_process(self, function: Callable[..., Any] | None = ...): # -> Callable[..., Any] | Callable[..., None] | None:
        """
        Decorator that only runs the decorated function on the local main process.

        Args:
            function (`Callable`): The function to decorate.

        Example:
        ```python
        # Assume we have 2 servers with 4 processes each.
        from accelerate.state import PartialState

        state = PartialState()


        @state.on_local_main_process
        def print_something():
            print("This will be printed by process 0 only on each server.")


        print_something()
        # On server 1:
        "This will be printed by process 0 only"
        # On server 2:
        "This will be printed by process 0 only"
        ```
        """
        ...
    
    def on_last_process(self, function: Callable[..., Any]): # -> Callable[..., Any] | Callable[..., None]:
        """
        Decorator that only runs the decorated function on the last process.

        Args:
            function (`Callable`): The function to decorate.

        Example:
        ```python
        # Assume we have 4 processes.
        from accelerate.state import PartialState

        state = PartialState()


        @state.on_last_process
        def print_something():
            print(f"Printed on process {state.process_index}")


        print_something()
        "Printed on process 3"
        ```
        """
        ...
    
    def on_process(self, function: Callable[..., Any] | None = ..., process_index: int | None = ...): # -> partial[Any] | Callable[..., Any] | Callable[..., None]:
        """
        Decorator that only runs the decorated function on the process with the given index.

        Args:
            function (`Callable`, `optional`):
                The function to decorate.
            process_index (`int`, `optional`):
                The index of the process on which to run the function.

        Example:
        ```python
        # Assume we have 4 processes.
        from accelerate.state import PartialState

        state = PartialState()


        @state.on_process(process_index=2)
        def print_something():
            print(f"Printed on process {state.process_index}")


        print_something()
        "Printed on process 2"
        ```
        """
        ...
    
    def on_local_process(self, function: Callable[..., Any] | None = ..., local_process_index: int | None = ...): # -> partial[Any] | Callable[..., Any] | Callable[..., None]:
        """
        Decorator that only runs the decorated function on the process with the given index on the current node.

        Args:
            function (`Callable`, *optional*):
                The function to decorate.
            local_process_index (`int`, *optional*):
                The index of the local process on which to run the function.

        Example:
        ```python
        # Assume we have 2 servers with 4 processes each.
        from accelerate import Accelerator

        accelerator = Accelerator()


        @accelerator.on_local_process(local_process_index=2)
        def print_something():
            print(f"Printed on process {accelerator.local_process_index}")


        print_something()
        # On server 1:
        "Printed on process 2"
        # On server 2:
        "Printed on process 2"
        ```
        """
        ...
    
    def print(self, *args, **kwargs): # -> None:
        ...
    
    @property
    def default_device(self) -> torch.device:
        """
        Returns the default device which is:
        - MPS if `torch.backends.mps.is_available()` and `torch.backends.mps.is_built()` both return True.
        - CUDA if `torch.cuda.is_available()`
        - MLU if `is_mlu_available()`
        - SDAA if `is_sdaa_available()`
        - MUSA if `is_musa_available()`
        - NPU if `is_npu_available()`
        - HPU if `is_hpu_available()`
        - CPU otherwise
        """
        ...
    
    def set_device(self): # -> None:
        """
        Sets the device in `self.device` to the current distributed environment.
        """
        ...
    
    def destroy_process_group(self, group=...): # -> None:
        """
        Destroys the process group. If one is not specified, the default process group is destroyed.
        """
        ...
    
    def __getattr__(self, name: str):
        ...
    


class AcceleratorState:
    """
    Singleton class that has information about the current training environment.

    **Available attributes:**

        - **device** (`torch.device`) -- The device to use.
        - **distributed_type** ([`~accelerate.state.DistributedType`]) -- The type of distributed environment currently
          in use.
        - **parallelism_config** ([`~accelerate.utils.ParallelismConfig`]) -- The parallelism configuration for the
          current training environment. This is used to configure the distributed training environment.
        - **initialized** (`bool`) -- Whether or not the `AcceleratorState` has been initialized from `Accelerator`.
        - **local_process_index** (`int`) -- The index of the current process on the current server.
        - **mixed_precision** (`str`) -- Whether or not the current script will use mixed precision, and if so the type
          of mixed precision being performed. (Choose from 'no','fp16','bf16 or 'fp8').
        - **num_processes** (`int`) -- The number of processes currently launched in parallel.
        - **process_index** (`int`) -- The index of the current process.
        - **is_last_process** (`bool`) -- Whether or not the current process is the last one.
        - **is_main_process** (`bool`) -- Whether or not the current process is the main one.
        - **is_local_main_process** (`bool`) -- Whether or not the current process is the main one on the local node.
        - **debug** (`bool`) -- Whether or not the current script is being run in debug mode.
    """
    _shared_state = ...
    _known_attrs = ...
    def __init__(self, mixed_precision: str | None = ..., cpu: bool = ..., dynamo_plugin=..., deepspeed_plugin=..., fsdp_plugin=..., torch_tp_plugin=..., megatron_lm_plugin=..., parallelism_config=..., _from_accelerator: bool = ..., **kwargs) -> None:
        ...
    
    @property
    def initialized(self) -> bool:
        ...
    
    def __repr__(self): # -> str:
        ...
    
    @property
    def mixed_precision(self): # -> str:
        ...
    
    def destroy_process_group(self, group=...): # -> None:
        """
        Destroys the process group. If one is not specified, the default process group is destroyed.

        If `self.fork_launched` is `True` and `group` is `None`, nothing happens.
        """
        ...
    
    @property
    def fork_launched(self): # -> bool:
        ...
    
    @property
    def use_distributed(self): # -> bool:
        """
        Whether the Accelerator is configured for distributed training
        """
        ...
    
    @property
    def is_fsdp2(self) -> bool:
        ...
    
    @property
    def is_last_process(self) -> bool:
        "Returns whether the current process is the last one"
        ...
    
    @property
    def is_main_process(self) -> bool:
        "Returns whether the current process is the main process"
        ...
    
    @property
    def is_local_main_process(self) -> bool:
        "Returns whether the current process is the main process on the local node"
        ...
    
    def wait_for_everyone(self): # -> None:
        ...
    
    @contextmanager
    def split_between_processes(self, inputs: list | tuple | dict | torch.Tensor, apply_padding: bool = ...): # -> Generator[list[Any] | tuple[Any, ...] | dict[Any, Any] | Tensor, Any, None]:
        """
        Splits `input` between `self.num_processes` quickly and can be then used on that process. Useful when doing
        distributed inference, such as with different prompts.

        Note that when using a `dict`, all keys need to have the same number of elements.

        Args:
            inputs (`list`, `tuple`, `torch.Tensor`, or `dict` of `list`/`tuple`/`torch.Tensor`):
                The input to split between processes.
            apply_padding (`bool`, `optional`, defaults to `False`):
                Whether to apply padding by repeating the last element of the input so that all processes have the same
                number of elements. Useful when trying to perform actions such as `gather()` on the outputs or passing
                in less inputs than there are processes. If so, just remember to drop the padded elements afterwards.


        Example:

        ```python
        # Assume there are two processes
        from accelerate.state import AcceleratorState

        state = AcceleratorState()
        with state.split_between_processes(["A", "B", "C"]) as inputs:
            print(inputs)
        # Process 0
        ["A", "B"]
        # Process 1
        ["C"]

        with state.split_between_processes(["A", "B", "C"], apply_padding=True) as inputs:
            print(inputs)
        # Process 0
        ["A", "B"]
        # Process 1
        ["C", "C"]
        ```
        """
        ...
    
    @contextmanager
    def main_process_first(self): # -> Generator[None, Any, None]:
        """
        Lets the main process go first inside a with block.

        The other processes will enter the with block after the main process exits.
        """
        ...
    
    @contextmanager
    def local_main_process_first(self): # -> Generator[None, Any, None]:
        """
        Lets the local main process go inside a with block.

        The other processes will enter the with block after the main process exits.
        """
        ...
    
    @property
    def deepspeed_plugin(self): # -> None:
        """
        Returns the currently active DeepSpeedPlugin.

        If not using deepspeed, returns `None`.
        """
        ...
    
    @deepspeed_required
    def get_deepspeed_plugin(self, name: str):
        """
        Returns the DeepSpeedPlugin with the given plugin_key.
        """
        ...
    
    @deepspeed_required
    def select_deepspeed_plugin(self, name: str | None = ...): # -> None:
        """
        Activates the DeepSpeedPlugin with the given `name`, and will disable all other plugins.
        """
        ...
    
    def print(self, *args, **kwargs): # -> None:
        ...
    
    def __getattr__(self, name: str):
        ...
    


class GradientState:
    """
    Singleton class that has information related to gradient synchronization for gradient accumulation

    **Available attributes:**

        - **end_of_dataloader** (`bool`) -- Whether we have reached the end the current dataloader
        - **remainder** (`int`) -- The number of extra samples that were added from padding the dataloader
        - **sync_gradients** (`bool`) -- Whether the gradients should be synced across all devices
        - **active_dataloader** (`Optional[DataLoader]`) -- The dataloader that is currently being iterated over
        - **dataloader_references** (`List[Optional[DataLoader]]`) -- A list of references to the dataloaders that are
            being iterated over
        - **num_steps** (`int`) -- The number of steps to accumulate over
        - **adjust_scheduler** (`bool`) -- Whether the scheduler should be adjusted to account for the gradient
            accumulation
        - **sync_with_dataloader** (`bool`) -- Whether the gradients should be synced at the end of the dataloader
            iteration and the number of total steps reset
        - **is_xla_gradients_synced** (`bool`) -- Whether the XLA gradients have been synchronized. It is initialized
          as false. Once gradients have been reduced before the optimizer step, this flag is set to true. Subsequently,
            after each step, the flag is reset to false. FSDP will always synchronize the gradients, hence
            is_xla_gradients_synced is always true.
    """
    _shared_state = ...
    def __init__(self, gradient_accumulation_plugin: GradientAccumulationPlugin | None = ...) -> None:
        ...
    
    @property
    def num_steps(self) -> int:
        "Returns the number of steps to accumulate over"
        ...
    
    @property
    def adjust_scheduler(self) -> bool:
        "Returns whether the scheduler should be adjusted"
        ...
    
    @property
    def sync_with_dataloader(self) -> bool:
        "Returns whether the gradients should be synced at the end of the dataloader iteration and the number of total steps reset"
        ...
    
    @property
    def initialized(self) -> bool:
        "Returns whether the `GradientState` has been initialized"
        ...
    
    @property
    def end_of_dataloader(self) -> bool:
        "Returns whether we have reached the end of the current dataloader"
        ...
    
    @property
    def remainder(self) -> int:
        "Returns the number of extra samples that were added from padding the dataloader"
        ...
    
    def __repr__(self): # -> str:
        ...
    
    @property
    def is_xla_gradients_synced(self): # -> bool:
        "Returns the value of is_xla_gradients_synced. FSDP will always synchronize the gradients, hence is_xla_gradients_synced is always true."
        ...
    
    @is_xla_gradients_synced.setter
    def is_xla_gradients_synced(self, is_synced): # -> None:
        "Set the _is_xla_gradients_synced attribute."
        ...
    
    @property
    def active_dataloader(self): # -> None:
        ...
    
    @property
    def dataloader_references(self): # -> list[Any | None]:
        ...
    
    @dataloader_references.setter
    def dataloader_references(self, references): # -> None:
        ...
    
    @property
    def in_dataloader(self) -> bool:
        "Returns whether the current process is in a dataloader"
        ...
    


