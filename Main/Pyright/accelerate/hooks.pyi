"""
This type stub file was generated by pyright.
"""

import torch
import torch.nn as nn
from collections.abc import Mapping
from typing import Optional, Union

_accelerate_added_attributes = ...
class ModelHook:
    """
    A hook that contains callbacks to be executed just before and after the forward method of a model. The difference
    with PyTorch existing hooks is that they get passed along the kwargs.

    Class attribute:
    - **no_grad** (`bool`, *optional*, defaults to `False`) -- Whether or not to execute the actual forward pass under
      the `torch.no_grad()` context manager.
    """
    no_grad = ...
    def init_hook(self, module):
        """
        To be executed when the hook is attached to the module.

        Args:
            module (`torch.nn.Module`): The module attached to this hook.
        """
        ...
    
    def pre_forward(self, module, *args, **kwargs): # -> tuple[tuple[Any, ...], dict[str, Any]]:
        """
        To be executed just before the forward method of the model.

        Args:
            module (`torch.nn.Module`): The module whose forward pass will be executed just after this event.
            args (`Tuple[Any]`): The positional arguments passed to the module.
            kwargs (`Dict[Str, Any]`): The keyword arguments passed to the module.

        Returns:
            `Tuple[Tuple[Any], Dict[Str, Any]]`: A tuple with the treated `args` and `kwargs`.
        """
        ...
    
    def post_forward(self, module, output):
        """
        To be executed just after the forward method of the model.

        Args:
            module (`torch.nn.Module`): The module whose forward pass been executed just before this event.
            output (`Any`): The output of the module.

        Returns:
            `Any`: The processed `output`.
        """
        ...
    
    def detach_hook(self, module):
        """
        To be executed when the hook is detached from a module.

        Args:
            module (`torch.nn.Module`): The module detached from this hook.
        """
        ...
    


class SequentialHook(ModelHook):
    """
    A hook that can contain several hooks and iterates through them at each event.
    """
    def __init__(self, *hooks) -> None:
        ...
    
    def init_hook(self, module):
        ...
    
    def pre_forward(self, module, *args, **kwargs): # -> tuple[tuple[Any, ...] | Any, dict[str, Any] | Any]:
        ...
    
    def post_forward(self, module, output):
        ...
    
    def detach_hook(self, module):
        ...
    


def add_hook_to_module(module: nn.Module, hook: ModelHook, append: bool = ...): # -> Module:
    """
    Adds a hook to a given module. This will rewrite the `forward` method of the module to include the hook, to remove
    this behavior and restore the original `forward` method, use `remove_hook_from_module`.

    <Tip warning={true}>

    If the module already contains a hook, this will replace it with the new hook passed by default. To chain two hooks
    together, pass `append=True`, so it chains the current and new hook into an instance of the `SequentialHook` class.

    </Tip>

    Args:
        module (`torch.nn.Module`):
            The module to attach a hook to.
        hook (`ModelHook`):
            The hook to attach.
        append (`bool`, *optional*, defaults to `False`):
            Whether the hook should be chained with an existing one (if module already contains a hook) or not.

    Returns:
        `torch.nn.Module`: The same module, with the hook attached (the module is modified in place, so the result can
        be discarded).
    """
    ...

def remove_hook_from_module(module: nn.Module, recurse=...): # -> Module:
    """
    Removes any hook attached to a module via `add_hook_to_module`.

    Args:
        module (`torch.nn.Module`): The module to attach a hook to.
        recurse (`bool`, **optional**): Whether to remove the hooks recursively

    Returns:
        `torch.nn.Module`: The same module, with the hook detached (the module is modified in place, so the result can
        be discarded).
    """
    ...

class AlignDevicesHook(ModelHook):
    """
    A generic `ModelHook` that ensures inputs and model weights are on the same device for the forward pass of the
    associated module, potentially offloading the weights after the forward pass.

    Args:
        execution_device (`torch.device`, *optional*):
            The device on which inputs and model weights should be placed before the forward pass.
        offload (`bool`, *optional*, defaults to `False`):
            Whether or not the weights should be offloaded after the forward pass.
        io_same_device (`bool`, *optional*, defaults to `False`):
            Whether or not the output should be placed on the same device as the input was.
        weights_map (`Mapping[str, torch.Tensor]`, *optional*):
            When the model weights are offloaded, a (potentially lazy) map from param names to the tensor values.
        offload_buffers (`bool`, *optional*, defaults to `False`):
            Whether or not to include the associated module's buffers when offloading.
        place_submodules (`bool`, *optional*, defaults to `False`):
            Whether to place the submodules on `execution_device` during the `init_hook` event.
    """
    def __init__(self, execution_device: Optional[Union[int, str, torch.device]] = ..., offload: bool = ..., io_same_device: bool = ..., weights_map: Optional[Mapping] = ..., offload_buffers: bool = ..., place_submodules: bool = ..., skip_keys: Optional[Union[str, list[str]]] = ..., tied_params_map: Optional[dict[int, dict[torch.device, torch.Tensor]]] = ...) -> None:
        ...
    
    def __repr__(self): # -> str:
        ...
    
    def init_hook(self, module):
        ...
    
    def pre_forward(self, module, *args, **kwargs): # -> tuple[Any | Mapping[Any, Any], Any | Mapping[Any, Any]]:
        ...
    
    def post_forward(self, module, output): # -> Any | Mapping[Any, Any]:
        ...
    
    def detach_hook(self, module):
        ...
    


def attach_execution_device_hook(module: torch.nn.Module, execution_device: Union[int, str, torch.device], skip_keys: Optional[Union[str, list[str]]] = ..., preload_module_classes: Optional[list[str]] = ..., tied_params_map: Optional[dict[int, dict[torch.device, torch.Tensor]]] = ...): # -> None:
    """
    Recursively attaches `AlignDevicesHook` to all submodules of a given model to make sure they have the right
    execution device

    Args:
        module (`torch.nn.Module`):
            The module where we want to attach the hooks.
        execution_device (`int`, `str` or `torch.device`):
            The device on which inputs and model weights should be placed before the forward pass.
        skip_keys (`str` or `List[str]`, *optional*):
            A list of keys to ignore when moving inputs or outputs between devices.
        preload_module_classes (`List[str]`, *optional*):
            A list of classes whose instances should load all their weights (even in the submodules) at the beginning
            of the forward. This should only be used for classes that have submodules which are registered but not
            called directly during the forward, for instance if a `dense` linear layer is registered, but at forward,
            `dense.weight` and `dense.bias` are used in some operations instead of calling `dense` directly.
        tied_params_map (Optional[Dict[int, Dict[torch.device, torch.Tensor]]], *optional*, defaults to `None`):
            A map of data pointers to dictionaries of devices to already dispatched tied weights. For a given execution
            device, this parameter is useful to reuse the first available pointer of a shared weight for all others,
            instead of duplicating memory.
    """
    ...

def attach_align_device_hook(module: torch.nn.Module, execution_device: Optional[torch.device] = ..., offload: bool = ..., weights_map: Optional[Mapping] = ..., offload_buffers: bool = ..., module_name: str = ..., skip_keys: Optional[Union[str, list[str]]] = ..., preload_module_classes: Optional[list[str]] = ..., tied_params_map: Optional[dict[int, dict[torch.device, torch.Tensor]]] = ...): # -> None:
    """
    Recursively attaches `AlignDevicesHook` to all submodules of a given model that have direct parameters and/or
    buffers.

    Args:
        module (`torch.nn.Module`):
            The module where we want to attach the hooks.
        execution_device (`torch.device`, *optional*):
            The device on which inputs and model weights should be placed before the forward pass.
        offload (`bool`, *optional*, defaults to `False`):
            Whether or not the weights should be offloaded after the forward pass.
        weights_map (`Mapping[str, torch.Tensor]`, *optional*):
            When the model weights are offloaded, a (potentially lazy) map from param names to the tensor values.
        offload_buffers (`bool`, *optional*, defaults to `False`):
            Whether or not to include the associated module's buffers when offloading.
        module_name (`str`, *optional*, defaults to `""`):
            The name of the module.
        skip_keys (`str` or `List[str]`, *optional*):
            A list of keys to ignore when moving inputs or outputs between devices.
        preload_module_classes (`List[str]`, *optional*):
            A list of classes whose instances should load all their weights (even in the submodules) at the beginning
            of the forward. This should only be used for classes that have submodules which are registered but not
            called directly during the forward, for instance if a `dense` linear layer is registered, but at forward,
            `dense.weight` and `dense.bias` are used in some operations instead of calling `dense` directly.
        tied_params_map (Optional[Dict[int, Dict[torch.device, torch.Tensor]]], *optional*, defaults to `None`):
            A map of data pointers to dictionaries of devices to already dispatched tied weights. For a given execution
            device, this parameter is useful to reuse the first available pointer of a shared weight for all others,
            instead of duplicating memory.
    """
    ...

def remove_hook_from_submodules(module: nn.Module): # -> None:
    """
    Recursively removes all hooks attached on the submodules of a given model.

    Args:
        module (`torch.nn.Module`): The module on which to remove all hooks.
    """
    ...

def attach_align_device_hook_on_blocks(module: nn.Module, execution_device: Optional[Union[torch.device, dict[str, torch.device]]] = ..., offload: Union[bool, dict[str, bool]] = ..., weights_map: Optional[Mapping] = ..., offload_buffers: bool = ..., module_name: str = ..., skip_keys: Optional[Union[str, list[str]]] = ..., preload_module_classes: Optional[list[str]] = ..., tied_params_map: Optional[dict[int, dict[torch.device, torch.Tensor]]] = ...): # -> None:
    """
    Attaches `AlignDevicesHook` to all blocks of a given model as needed.

    Args:
        module (`torch.nn.Module`):
            The module where we want to attach the hooks.
        execution_device (`torch.device` or `Dict[str, torch.device]`, *optional*):
            The device on which inputs and model weights should be placed before the forward pass. It can be one device
            for the whole module, or a dictionary mapping module name to device.
        offload (`bool`, *optional*, defaults to `False`):
            Whether or not the weights should be offloaded after the forward pass. It can be one boolean for the whole
            module, or a dictionary mapping module name to boolean.
        weights_map (`Mapping[str, torch.Tensor]`, *optional*):
            When the model weights are offloaded, a (potentially lazy) map from param names to the tensor values.
        offload_buffers (`bool`, *optional*, defaults to `False`):
            Whether or not to include the associated module's buffers when offloading.
        module_name (`str`, *optional*, defaults to `""`):
            The name of the module.
        skip_keys (`str` or `List[str]`, *optional*):
            A list of keys to ignore when moving inputs or outputs between devices.
        preload_module_classes (`List[str]`, *optional*):
            A list of classes whose instances should load all their weights (even in the submodules) at the beginning
            of the forward. This should only be used for classes that have submodules which are registered but not
            called directly during the forward, for instance if a `dense` linear layer is registered, but at forward,
            `dense.weight` and `dense.bias` are used in some operations instead of calling `dense` directly.
        tied_params_map (Optional[Dict[int, Dict[torch.device, torch.Tensor]]], *optional*, defaults to `None`):
            A map of data pointers to dictionaries of devices to already dispatched tied weights. For a given execution
            device, this parameter is useful to reuse the first available pointer of a shared weight for all others,
            instead of duplicating memory.
    """
    ...

class CpuOffload(ModelHook):
    """
    Offloads a model on the CPU until its forward pass is called. The model will not be offloaded back to the CPU after
    the forward, the user needs to call the `init_hook` method again for this.

    Args:
        execution_device(`str`, `int` or `torch.device`, *optional*):
            The device on which the model should be executed. Will default to the MPS device if it's available, then
            GPU 0 if there is a GPU, and finally to the CPU.
        prev_module_hook (`UserCpuOffloadHook`, *optional*):
            The hook sent back by [`cpu_offload_with_hook`] for a previous model in the pipeline you are running. If
            passed, its offload method will be called just before the forward of the model to which this hook is
            attached.
    """
    def __init__(self, execution_device: Optional[Union[str, int, torch.device]] = ..., prev_module_hook: Optional[UserCpuOffloadHook] = ...) -> None:
        ...
    
    def init_hook(self, module):
        ...
    
    def pre_forward(self, module, *args, **kwargs): # -> tuple[tuple[Any, ...], dict[str, Any]] | tuple[Any | Mapping[Any, Any], Any | Mapping[Any, Any]]:
        ...
    


class UserCpuOffloadHook:
    """
    A simple hook grouping a model and a `ModelHook`, which provides easy APIs for to call the init method of the hook
    or remove it entirely.
    """
    def __init__(self, model, hook) -> None:
        ...
    
    def offload(self): # -> None:
        ...
    
    def remove(self): # -> None:
        ...
    


class LayerwiseCastingHook(ModelHook):
    r"""
    A hook that casts the weights of a module to a high precision dtype for computation, and to a low precision dtype
    for storage. This process may lead to quality loss in the output, but can significantly reduce the memory
    footprint.
    """
    _is_stateful = ...
    def __init__(self, storage_dtype: torch.dtype, compute_dtype: torch.dtype, non_blocking: bool) -> None:
        ...
    
    def init_hook(self, module: torch.nn.Module): # -> Module:
        ...
    
    def pre_forward(self, module: torch.nn.Module, *args, **kwargs): # -> tuple[tuple[Any, ...], dict[str, Any]]:
        ...
    
    def post_forward(self, module: torch.nn.Module, output):
        ...
    


