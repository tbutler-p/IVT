"""
This type stub file was generated by pyright.
"""

import os
import torch
from collections.abc import Mapping
from typing import Optional, Union

def offload_weight(weight, weight_name, offload_folder, index=...): # -> None:
    ...

def load_offloaded_weight(weight_file, weight_info): # -> Tensor:
    ...

def save_offload_index(index, offload_folder): # -> None:
    ...

def offload_state_dict(save_dir: Union[str, os.PathLike], state_dict: dict[str, torch.Tensor]): # -> None:
    """
    Offload a state dict in a given folder.

    Args:
        save_dir (`str` or `os.PathLike`):
            The directory in which to offload the state dict.
        state_dict (`Dict[str, torch.Tensor]`):
            The dictionary of tensors to offload.
    """
    ...

class PrefixedDataset(Mapping):
    """
    Will access keys in a given dataset by adding a prefix.

    Args:
        dataset (`Mapping`): Any map with string keys.
        prefix (`str`): A prefix to add when trying to access any element in the underlying dataset.
    """
    def __init__(self, dataset: Mapping, prefix: str) -> None:
        ...
    
    def __getitem__(self, key):
        ...
    
    def __iter__(self): # -> Iterator[Any]:
        ...
    
    def __len__(self): # -> int:
        ...
    


class OffloadedWeightsLoader(Mapping):
    """
    A collection that loads weights stored in a given state dict or memory-mapped on disk.

    Args:
        state_dict (`Dict[str, torch.Tensor]`, *optional*):
            A dictionary parameter name to tensor.
        save_folder (`str` or `os.PathLike`, *optional*):
            The directory in which the weights are stored (by `offload_state_dict` for instance).
        index (`Dict`, *optional*):
            A dictionary from weight name to their information (`dtype`/ `shape` or safetensors filename). Will default
            to the index saved in `save_folder`.
    """
    def __init__(self, state_dict: Optional[dict[str, torch.Tensor]] = ..., save_folder: Optional[Union[str, os.PathLike]] = ..., index: Optional[Mapping] = ..., device=...) -> None:
        ...
    
    def __getitem__(self, key: str): # -> Tensor:
        ...
    
    def __iter__(self): # -> Iterator[str]:
        ...
    
    def __len__(self): # -> int:
        ...
    


def extract_submodules_state_dict(state_dict: dict[str, torch.Tensor], submodule_names: list[str]): # -> dict[Any, Any]:
    """
    Extract the sub state-dict corresponding to a list of given submodules.

    Args:
        state_dict (`Dict[str, torch.Tensor]`): The state dict to extract from.
        submodule_names (`List[str]`): The list of submodule names we want to extract.
    """
    ...

