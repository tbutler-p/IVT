"""
This type stub file was generated by pyright.
"""

from typing import Any, Match, NamedTuple, Sequence, TYPE_CHECKING
from . import inline_parser
from .element import Element
from .source import Source

"""
Block level elements
"""
if TYPE_CHECKING:
    ...
__all__ = ("Document", "CodeBlock", "Heading", "List", "ListItem", "BlankLine", "Quote", "FencedCode", "ThematicBreak", "HTMLBlock", "LinkRefDef", "SetextHeading", "Paragraph")
class BlockElement(Element):
    """Any block element should inherit this class"""
    children: Sequence[Element] = ...
    priority = ...
    virtual = ...
    inline_body: str = ...
    override = ...
    _prefix = ...
    @classmethod
    def match(cls, source: Source) -> Any:
        """Test if the source matches the element at current position.
        The source should not be consumed in the method unless you have to.

        :param source: the ``Source`` object of the content to be parsed
        """
        ...
    
    @classmethod
    def parse(cls, source: Source) -> Any:
        """Parses the source. This is a proper place to consume the source body and
        return an element or information to build one. The information tuple will be
        passed to ``__init__`` method afterwards. Inline parsing, if any, should also
        be performed here.

        :param source: the ``Source`` object of the content to be parsed
        """
        ...
    
    def __lt__(self, o: BlockElement) -> bool:
        ...
    


class Document(BlockElement):
    """Document node element."""
    _prefix = ...
    virtual = ...
    def __init__(self) -> None:
        ...
    


class BlankLine(BlockElement):
    """Blank lines"""
    priority = ...
    def __init__(self, start: int) -> None:
        ...
    
    @classmethod
    def match(cls, source: Source) -> bool:
        ...
    
    @classmethod
    def parse(cls, source: Source) -> int:
        ...
    


class Heading(BlockElement):
    """Heading element: (### Hello\n)"""
    priority = ...
    pattern = ...
    def __init__(self, match: Match[str]) -> None:
        ...
    
    @classmethod
    def match(cls, source: Source) -> Match[str] | None:
        ...
    
    @classmethod
    def parse(cls, source: Source) -> Match[str] | None:
        ...
    


class SetextHeading(BlockElement):
    """Setext heading: (Hello\n===\n)

    It can only be created by Paragraph.parse.
    """
    virtual = ...
    def __init__(self, lines: list[str]) -> None:
        ...
    


class CodeBlock(BlockElement):
    """Indented code block: (    this is a code block\n)"""
    priority = ...
    def __init__(self, lines: str) -> None:
        ...
    
    @classmethod
    def match(cls, source: Source) -> str:
        ...
    
    @classmethod
    def parse(cls, source: Source) -> str:
        ...
    
    @staticmethod
    def strip_prefix(line: str, prefix: str) -> str:
        ...
    


class FencedCode(BlockElement):
    """Fenced code block: (```python\nhello\n```\n)"""
    priority = ...
    pattern = ...
    class ParseInfo(NamedTuple):
        prefix: str
        leading: str
        lang: str
        extra: str
        ...
    
    
    def __init__(self, match: tuple[str, str, str]) -> None:
        ...
    
    @classmethod
    def match(cls, source: Source) -> Match[str] | None:
        ...
    
    @classmethod
    def parse(cls, source: Source) -> tuple[str, str, str]:
        ...
    


class ThematicBreak(BlockElement):
    """Horizontal rules: (----\n)"""
    priority = ...
    pattern = ...
    @classmethod
    def match(cls, source: Source) -> bool:
        ...
    
    @classmethod
    def parse(cls, source: Source) -> ThematicBreak:
        ...
    


class HTMLBlock(BlockElement):
    """HTML blocks, parsed as it is"""
    priority = ...
    def __init__(self, lines: str) -> None:
        ...
    
    @classmethod
    def match(cls, source: Source) -> int | bool:
        ...
    
    @classmethod
    def parse(cls, source: Source) -> str:
        ...
    


class Paragraph(BlockElement):
    """A paragraph element"""
    priority = ...
    pattern = ...
    def __init__(self, lines: list[str]) -> None:
        ...
    
    @classmethod
    def match(cls, source: Source) -> bool:
        ...
    
    @staticmethod
    def is_setext_heading(line: str) -> bool:
        ...
    
    @classmethod
    def break_paragraph(cls, source: Source, lazy: bool = ...) -> bool:
        ...
    
    @classmethod
    def parse(cls, source: Source) -> list[str] | SetextHeading:
        ...
    


class Quote(BlockElement):
    """block quote element: (> hello world)"""
    priority = ...
    _prefix = ...
    @classmethod
    def match(cls, source: Source) -> Match[str] | None:
        ...
    
    @classmethod
    def parse(cls, source: Source) -> Quote:
        ...
    


class List(BlockElement):
    """List block element"""
    priority = ...
    _prefix = ...
    pattern = ...
    class ParseInfo(NamedTuple):
        bullet: str
        ordered: bool
        start: int
        ...
    
    
    def __init__(self, info: List.ParseInfo) -> None:
        ...
    
    @classmethod
    def match(cls, source: Source) -> bool:
        ...
    
    @classmethod
    def parse(cls, source: Source) -> List:
        ...
    


class ListItem(BlockElement):
    """List item element. It can only be created by List.parse"""
    virtual = ...
    _tight = ...
    pattern = ...
    class ParseInfo(NamedTuple):
        indent: int
        bullet: str
        mid: int
        ...
    
    
    def __init__(self, info: ListItem.ParseInfo) -> None:
        ...
    
    @classmethod
    def parse_leading(cls, line: str, prefix_pos: int) -> tuple[int, str, int, str]:
        ...
    
    @classmethod
    def match(cls, source: Source) -> bool:
        ...
    
    @classmethod
    def parse(cls, source: Source) -> ListItem:
        ...
    


class LinkRefDef(BlockElement):
    """Link reference definition:
    [label]: destination "title"
    """
    pattern = ...
    class ParseInfo(NamedTuple):
        link_label: inline_parser.Group
        link_dest: inline_parser.Group
        link_title: inline_parser.Group
        end: int
        ...
    
    
    def __init__(self, label: str, text: str, title: str | None = ...) -> None:
        ...
    
    @classmethod
    def match(cls, source: Source) -> bool:
        ...
    
    @classmethod
    def parse(cls, source: Source) -> LinkRefDef:
        ...
    


