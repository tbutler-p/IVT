"""
This type stub file was generated by pyright.
"""

import dataclasses
from typing import Any, Callable, Container, Iterable, TYPE_CHECKING, TypeVar, overload
from marko.renderer import Renderer
from .element import Element

"""
Helper functions and data structures
"""
if TYPE_CHECKING:
    RendererFunc = Callable[[Any, Element], Any]
    TRenderer = TypeVar("TRenderer", bound=RendererFunc)
    D = TypeVar("D", bound="_RendererDispatcher")
def camel_to_snake_case(name: str) -> str:
    """Takes a camelCased string and converts to snake_case."""
    ...

def is_paired(text: Iterable[str], open: str = ..., close: str = ...) -> bool:
    """Check if the text only contains:
    1. blackslash escaped parentheses, or
    2. parentheses paired.
    """
    ...

def normalize_label(label: str) -> str:
    """Return the normalized form of link label."""
    ...

def find_next(text: str, target: Container[str], start: int = ..., end: int | None = ..., disallowed: Container[str] = ...) -> int:
    """Find the next occurrence of target in text, and return the index
    Characters are escaped by backslash.
    Optional disallowed characters can be specified, if found, the search
    will fail with -2 returned. Otherwise, -1 is returned if not found.
    """
    ...

def partition_by_spaces(text: str, spaces: str = ...) -> tuple[str, str, str]:
    """Split the given text by spaces or tabs, and return a tuple of
    (start, delimiter, remaining). If spaces are not found, the latter
    two elements will be empty.
    """
    ...

@dataclasses.dataclass(frozen=True)
class MarkoExtension:
    parser_mixins: list[type] = ...
    renderer_mixins: list[type] = ...
    elements: list[type[Element]] = ...


def load_extension(name: str, **kwargs: Any) -> MarkoExtension:
    """Load extension object from a string.
    First try `marko.ext.<name>` if possible
    """
    ...

class _RendererDispatcher:
    name: str
    def __init__(self, types: type[Renderer] | tuple[type[Renderer], ...], func: RendererFunc) -> None:
        ...
    
    def dispatch(self: D, types: type[Renderer] | tuple[type[Renderer], ...]) -> Callable[[RendererFunc], D]:
        ...
    
    def __set_name__(self, owner: type, name: str) -> None:
        ...
    
    @staticmethod
    def render_ast(self, element: Element) -> Any:
        ...
    
    def super_render(self, r: Any, element: Element) -> Any:
        """Call on the next class in the MRO which has the same method."""
        ...
    
    @overload
    def __get__(self: D, obj: None, owner: type) -> D:
        ...
    
    @overload
    def __get__(self: D, obj: Renderer, owner: type) -> RendererFunc:
        ...
    
    def __get__(self: D, obj: Renderer | None, owner: type) -> RendererFunc | D:
        ...
    


def render_dispatch(types: type[Renderer] | tuple[type[Renderer], ...]) -> Callable[[RendererFunc], _RendererDispatcher]:
    ...

