"""
This type stub file was generated by pyright.
"""

import functools
from contextlib import contextmanager
from typing import Generator, Literal, Match, Pattern, TYPE_CHECKING, overload
from marko.block import BlockElement, Document
from marko.parser import Parser

if TYPE_CHECKING:
    ...
class Source:
    """Wrapper class on content to be parsed"""
    parser: Parser
    def __init__(self, text: str) -> None:
        ...
    
    @property
    def state(self) -> BlockElement:
        """Returns the current element state."""
        ...
    
    @property
    def root(self) -> Document:
        """Returns the root element, which is at the bottom of self._states."""
        ...
    
    def push_state(self, element: BlockElement) -> None:
        """Push a new state to the state stack."""
        ...
    
    def pop_state(self) -> BlockElement:
        """Pop the top most state."""
        ...
    
    @contextmanager
    def under_state(self, element: BlockElement) -> Generator[Source, None, None]:
        """A context manager to enable a new state temporarily."""
        ...
    
    @property
    def exhausted(self) -> bool:
        """Indicates whether the source reaches the end."""
        ...
    
    @property
    def prefix(self) -> str:
        """The prefix of each line when parsing."""
        ...
    
    @staticmethod
    @functools.lru_cache
    def match_prefix(prefix: str, line: str) -> int:
        """Check if the line starts with given prefix and
        return the position of the end of prefix.
        If the prefix is not matched, return -1.
        """
        ...
    
    def expect_re(self, regexp: Pattern[str] | str) -> Match[str] | None:
        """Test against the given regular expression and returns the match object.
        :param regexp: the expression to be tested.
        :returns: the match object.
        """
        ...
    
    @overload
    def next_line(self, require_prefix: Literal[False] = ...) -> str:
        ...
    
    @overload
    def next_line(self, require_prefix: Literal[True] = ...) -> str | None:
        ...
    
    def next_line(self, require_prefix: bool = ...) -> str | None:
        """Return the next line in the source.

        :param require_prefix:  if False, the whole line will be returned.
            otherwise, return the line with prefix stripped or None if the prefix
            is not matched.
        """
        ...
    
    def consume(self) -> None:
        """Consume the body of source. ``pos`` will move forward."""
        ...
    
    def anchor(self) -> None:
        """Pin the current parsing position."""
        ...
    
    def reset(self) -> None:
        """Reset the position to the last anchor."""
        ...
    


