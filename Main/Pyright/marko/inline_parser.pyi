"""
This type stub file was generated by pyright.
"""

from typing import Match, NamedTuple, TYPE_CHECKING, Union
from .inline import InlineElement
from .source import Source

"""
Parse inline elements
"""
if TYPE_CHECKING:
    _Match = Union[Match[str], "MatchObj"]
    ElementType = type[InlineElement]
class Group(NamedTuple):
    start: int
    end: int
    text: str | None
    ...


_EMPTY_GROUP = ...
WHITESPACE = ...
ASCII_CONTROL = ...
class ParseError(ValueError):
    """Raised when parsing fails."""
    ...


def parse(text: str, elements: list[ElementType], fallback: ElementType, source: Source) -> list[InlineElement]:
    """Parse given text and produce a list of inline elements.

    :param text: the text to be parsed.
    :param elements: the element types to be included in parsing
    :param fallback: fallback class when no other element type is matched.
    """
    class LinkOrEmph(InlineElement):
        ...
    
    

def make_elements(tokens: list[Token], text: str, start: int = ..., end: int | None = ..., fallback: ElementType | None = ...) -> list[InlineElement]:
    """Make elements from a list of parsed tokens.
    It will turn all unmatched holes into fallback elements.

    :param tokens: a list of parsed tokens.
    :param text: the original tet.
    :param start: the offset of where parsing starts. Defaults to the start of text.
    :param end: the offset of where parsing ends. Defauls to the end of text.
    :param fallback: fallback element type.
    :returns: a list of inline elements.
    """
    ...

class Token:
    """An intermediate class to wrap the match object.
    It can be converted to element by :meth:`as_element()`
    """
    PRECEDE = ...
    INTERSECT = ...
    CONTAIN = ...
    SHADE = ...
    def __init__(self, etype: ElementType, match: _Match, text: str, fallback: ElementType) -> None:
        ...
    
    def relation(self, other: Token) -> int:
        ...
    
    def append_child(self, child: Token) -> None:
        ...
    
    def as_element(self) -> InlineElement:
        ...
    
    def __repr__(self) -> str:
        ...
    
    def __lt__(self, o: Token) -> bool:
        ...
    


def find_links_or_emphs(text: str, link_ref_defs: dict[str, tuple[str, str]]) -> list[MatchObj]:
    """Fink links/images or emphasis from text.

    :param text: the original text.
    :param link_ref_defs: a mapping of link ref definitions.
    :returns: an iterable of match object.
    """
    ...

def look_for_image_or_link(text: str, delimiters: list[Delimiter], close: int, link_ref_defs: dict[str, tuple[str, str]], matches: list[MatchObj]) -> MatchObj | None:
    ...

def process_emphasis(text: str, delimiters: list[Delimiter], stack_bottom: int | None, matches: list[MatchObj]) -> None:
    ...

class Delimiter:
    whitespace_re = ...
    def __init__(self, match: _Match, text: str) -> None:
        ...
    
    def is_left_flanking(self) -> bool:
        ...
    
    def is_right_flanking(self) -> bool:
        ...
    
    def followed_by_punc(self) -> bool:
        ...
    
    def preceded_by_punc(self) -> bool:
        ...
    
    def closed_by(self, other: Delimiter) -> bool:
        ...
    
    def remove(self, n: int, left: bool = ...) -> bool:
        ...
    
    def __repr__(self) -> str:
        ...
    


class MatchObj:
    """A fake match object that memes re.match methods"""
    def __init__(self, etype: str, text: str, start: int, end: int, *groups: Group) -> None:
        ...
    
    def group(self, n: int = ...) -> str:
        ...
    
    def start(self, n: int = ...) -> int:
        ...
    
    def end(self, n: int = ...) -> int:
        ...
    
    def span(self, n: int = ...) -> tuple[int, int]:
        ...
    


