"""
This type stub file was generated by pyright.
"""

from collections.abc import Generator, Mapping, Sequence, Set
from types import ModuleType
from typing import Any, Callable, Optional, TYPE_CHECKING, TypeVar, TypedDict, Union, final, overload
from ._result import Result

"""
Internal hook annotation, representation and calling machinery.
"""
_T = TypeVar("_T")
_F = TypeVar("_F", bound=Callable[..., object])
_Namespace = Union[ModuleType, type]
_Plugin = object
_HookExec = Callable[[str, Sequence["HookImpl"], Mapping[str, object], bool], Union[object, list[object]],]
_HookImplFunction = Callable[..., Union[_T, Generator[None, Result[_T], None]]]
class HookspecOpts(TypedDict):
    """Options for a hook specification."""
    firstresult: bool
    historic: bool
    warn_on_impl: Warning | None
    warn_on_impl_args: Mapping[str, Warning] | None
    ...


class HookimplOpts(TypedDict):
    """Options for a hook implementation."""
    wrapper: bool
    hookwrapper: bool
    optionalhook: bool
    tryfirst: bool
    trylast: bool
    specname: str | None
    ...


@final
class HookspecMarker:
    """Decorator for marking functions as hook specifications.

    Instantiate it with a project_name to get a decorator.
    Calling :meth:`PluginManager.add_hookspecs` later will discover all marked
    functions if the :class:`PluginManager` uses the same project name.
    """
    __slots__ = ...
    def __init__(self, project_name: str) -> None:
        ...
    
    @overload
    def __call__(self, function: _F, firstresult: bool = ..., historic: bool = ..., warn_on_impl: Warning | None = ..., warn_on_impl_args: Mapping[str, Warning] | None = ...) -> _F:
        ...
    
    @overload
    def __call__(self, function: None = ..., firstresult: bool = ..., historic: bool = ..., warn_on_impl: Warning | None = ..., warn_on_impl_args: Mapping[str, Warning] | None = ...) -> Callable[[_F], _F]:
        ...
    
    def __call__(self, function: _F | None = ..., firstresult: bool = ..., historic: bool = ..., warn_on_impl: Warning | None = ..., warn_on_impl_args: Mapping[str, Warning] | None = ...) -> _F | Callable[[_F], _F]:
        """If passed a function, directly sets attributes on the function
        which will make it discoverable to :meth:`PluginManager.add_hookspecs`.

        If passed no function, returns a decorator which can be applied to a
        function later using the attributes supplied.

        :param firstresult:
            If ``True``, the 1:N hook call (N being the number of registered
            hook implementation functions) will stop at I<=N when the I'th
            function returns a non-``None`` result. See :ref:`firstresult`.

        :param historic:
            If ``True``, every call to the hook will be memorized and replayed
            on plugins registered after the call was made. See :ref:`historic`.

        :param warn_on_impl:
            If given, every implementation of this hook will trigger the given
            warning. See :ref:`warn_on_impl`.

        :param warn_on_impl_args:
            If given, every implementation of this hook which requests one of
            the arguments in the dict will trigger the corresponding warning.
            See :ref:`warn_on_impl`.

            .. versionadded:: 1.5
        """
        ...
    


@final
class HookimplMarker:
    """Decorator for marking functions as hook implementations.

    Instantiate it with a ``project_name`` to get a decorator.
    Calling :meth:`PluginManager.register` later will discover all marked
    functions if the :class:`PluginManager` uses the same project name.
    """
    __slots__ = ...
    def __init__(self, project_name: str) -> None:
        ...
    
    @overload
    def __call__(self, function: _F, hookwrapper: bool = ..., optionalhook: bool = ..., tryfirst: bool = ..., trylast: bool = ..., specname: str | None = ..., wrapper: bool = ...) -> _F:
        ...
    
    @overload
    def __call__(self, function: None = ..., hookwrapper: bool = ..., optionalhook: bool = ..., tryfirst: bool = ..., trylast: bool = ..., specname: str | None = ..., wrapper: bool = ...) -> Callable[[_F], _F]:
        ...
    
    def __call__(self, function: _F | None = ..., hookwrapper: bool = ..., optionalhook: bool = ..., tryfirst: bool = ..., trylast: bool = ..., specname: str | None = ..., wrapper: bool = ...) -> _F | Callable[[_F], _F]:
        """If passed a function, directly sets attributes on the function
        which will make it discoverable to :meth:`PluginManager.register`.

        If passed no function, returns a decorator which can be applied to a
        function later using the attributes supplied.

        :param optionalhook:
            If ``True``, a missing matching hook specification will not result
            in an error (by default it is an error if no matching spec is
            found). See :ref:`optionalhook`.

        :param tryfirst:
            If ``True``, this hook implementation will run as early as possible
            in the chain of N hook implementations for a specification. See
            :ref:`callorder`.

        :param trylast:
            If ``True``, this hook implementation will run as late as possible
            in the chain of N hook implementations for a specification. See
            :ref:`callorder`.

        :param wrapper:
            If ``True`` ("new-style hook wrapper"), the hook implementation
            needs to execute exactly one ``yield``. The code before the
            ``yield`` is run early before any non-hook-wrapper function is run.
            The code after the ``yield`` is run after all non-hook-wrapper
            functions have run. The ``yield`` receives the result value of the
            inner calls, or raises the exception of inner calls (including
            earlier hook wrapper calls). The return value of the function
            becomes the return value of the hook, and a raised exception becomes
            the exception of the hook. See :ref:`hookwrapper`.

        :param hookwrapper:
            If ``True`` ("old-style hook wrapper"), the hook implementation
            needs to execute exactly one ``yield``. The code before the
            ``yield`` is run early before any non-hook-wrapper function is run.
            The code after the ``yield`` is run after all non-hook-wrapper
            function have run  The ``yield`` receives a :class:`Result` object
            representing the exception or result outcome of the inner calls
            (including earlier hook wrapper calls). This option is mutually
            exclusive with ``wrapper``. See :ref:`old_style_hookwrapper`.

        :param specname:
            If provided, the given name will be used instead of the function
            name when matching this hook implementation to a hook specification
            during registration. See :ref:`specname`.

        .. versionadded:: 1.2.0
            The ``wrapper`` parameter.
        """
        ...
    


def normalize_hookimpl_opts(opts: HookimplOpts) -> None:
    ...

_PYPY = ...
def varnames(func: object) -> tuple[tuple[str, ...], tuple[str, ...]]:
    """Return tuple of positional and keywrord argument names for a function,
    method, class or callable.

    In case of a class, its ``__init__`` method is considered.
    For methods the ``self`` parameter is not included.
    """
    ...

@final
class HookRelay:
    """Hook holder object for performing 1:N hook calls where N is the number
    of registered plugins."""
    __slots__ = ...
    def __init__(self) -> None:
        """:meta private:"""
        ...
    
    if TYPE_CHECKING:
        def __getattr__(self, name: str) -> HookCaller:
            ...
        


_HookRelay = HookRelay
_CallHistory = list[tuple[Mapping[str, object], Optional[Callable[[Any], None]]]]
class HookCaller:
    """A caller of all registered implementations of a hook specification."""
    __slots__ = ...
    def __init__(self, name: str, hook_execute: _HookExec, specmodule_or_class: _Namespace | None = ..., spec_opts: HookspecOpts | None = ...) -> None:
        """:meta private:"""
        ...
    
    def has_spec(self) -> bool:
        ...
    
    def set_specification(self, specmodule_or_class: _Namespace, spec_opts: HookspecOpts) -> None:
        ...
    
    def is_historic(self) -> bool:
        """Whether this caller is :ref:`historic <historic>`."""
        ...
    
    def get_hookimpls(self) -> list[HookImpl]:
        """Get all registered hook implementations for this hook."""
        ...
    
    def __repr__(self) -> str:
        ...
    
    def __call__(self, **kwargs: object) -> Any:
        """Call the hook.

        Only accepts keyword arguments, which should match the hook
        specification.

        Returns the result(s) of calling all registered plugins, see
        :ref:`calling`.
        """
        ...
    
    def call_historic(self, result_callback: Callable[[Any], None] | None = ..., kwargs: Mapping[str, object] | None = ...) -> None:
        """Call the hook with given ``kwargs`` for all registered plugins and
        for all plugins which will be registered afterwards, see
        :ref:`historic`.

        :param result_callback:
            If provided, will be called for each non-``None`` result obtained
            from a hook implementation.
        """
        ...
    
    def call_extra(self, methods: Sequence[Callable[..., object]], kwargs: Mapping[str, object]) -> Any:
        """Call the hook with some additional temporarily participating
        methods using the specified ``kwargs`` as call parameters, see
        :ref:`call_extra`."""
        ...
    


_HookCaller = HookCaller
class _SubsetHookCaller(HookCaller):
    """A proxy to another HookCaller which manages calls to all registered
    plugins except the ones from remove_plugins."""
    __slots__ = ...
    def __init__(self, orig: HookCaller, remove_plugins: Set[_Plugin]) -> None:
        ...
    
    @property
    def spec(self) -> HookSpec | None:
        ...
    
    def __repr__(self) -> str:
        ...
    


@final
class HookImpl:
    """A hook implementation in a :class:`HookCaller`."""
    __slots__ = ...
    def __init__(self, plugin: _Plugin, plugin_name: str, function: _HookImplFunction[object], hook_impl_opts: HookimplOpts) -> None:
        """:meta private:"""
        ...
    
    def __repr__(self) -> str:
        ...
    


@final
class HookSpec:
    __slots__ = ...
    def __init__(self, namespace: _Namespace, name: str, opts: HookspecOpts) -> None:
        ...
    


