"""
This type stub file was generated by pyright.
"""

import numpy as np
from typing import Any, Literal, TYPE_CHECKING, overload
from pandas._typing import ArrayLike, AxisInt, ReindexMethod, npt
from pandas import Index

"""
Routines for filling missing data.
"""
if TYPE_CHECKING:
    ...
def check_value_size(value, mask: npt.NDArray[np.bool_], length: int):
    """
    Validate the size of the values passed to ExtensionArray.fillna.
    """
    ...

def mask_missing(arr: ArrayLike, values_to_mask) -> npt.NDArray[np.bool_]:
    """
    Return a masking array of same size/shape as arr
    with entries equaling any member of values_to_mask set to True

    Parameters
    ----------
    arr : ArrayLike
    values_to_mask: list, tuple, or scalar

    Returns
    -------
    np.ndarray[bool]
    """
    ...

@overload
def clean_fill_method(method: Literal["ffill", "pad", "bfill", "backfill"], *, allow_nearest: Literal[False] = ...) -> Literal["pad", "backfill"]:
    ...

@overload
def clean_fill_method(method: Literal["ffill", "pad", "bfill", "backfill", "nearest"], *, allow_nearest: Literal[True]) -> Literal["pad", "backfill", "nearest"]:
    ...

def clean_fill_method(method: Literal["ffill", "pad", "bfill", "backfill", "nearest"], *, allow_nearest: bool = ...) -> Literal["pad", "backfill", "nearest"]:
    ...

NP_METHODS = ...
SP_METHODS = ...
def clean_interp_method(method: str, index: Index, **kwargs) -> str:
    ...

def find_valid_index(how: str, is_valid: npt.NDArray[np.bool_]) -> int | None:
    """
    Retrieves the positional index of the first valid value.

    Parameters
    ----------
    how : {'first', 'last'}
        Use this parameter to change between the first or last valid index.
    is_valid: np.ndarray
        Mask to find na_values.

    Returns
    -------
    int or None
    """
    ...

def validate_limit_direction(limit_direction: str) -> Literal["forward", "backward", "both"]:
    ...

def validate_limit_area(limit_area: str | None) -> Literal["inside", "outside"] | None:
    ...

def infer_limit_direction(limit_direction: Literal["backward", "forward", "both"] | None, method: str) -> Literal["backward", "forward", "both"]:
    ...

def get_interp_index(method, index: Index) -> Index:
    ...

def interpolate_2d_inplace(data: np.ndarray, index: Index, axis: AxisInt, method: str = ..., limit: int | None = ..., limit_direction: str = ..., limit_area: str | None = ..., fill_value: Any | None = ..., mask=..., **kwargs) -> None:
    """
    Column-wise application of _interpolate_1d.

    Notes
    -----
    Alters 'data' in-place.

    The signature does differ from _interpolate_1d because it only
    includes what is needed for Block.interpolate.
    """
    ...

def pad_or_backfill_inplace(values: np.ndarray, method: Literal["pad", "backfill"] = ..., axis: AxisInt = ..., limit: int | None = ..., limit_area: Literal["inside", "outside"] | None = ...) -> None:
    """
    Perform an actual interpolation of values, values will be make 2-d if
    needed fills inplace, returns the result.

    Parameters
    ----------
    values: np.ndarray
        Input array.
    method: str, default "pad"
        Interpolation method. Could be "bfill" or "pad"
    axis: 0 or 1
        Interpolation axis
    limit: int, optional
        Index limit on interpolation.
    limit_area: str, optional
        Limit area for interpolation. Can be "inside" or "outside"

    Notes
    -----
    Modifies values in-place.
    """
    ...

_fill_methods = ...
def get_fill_func(method, ndim: int = ...): # -> Callable[..., tuple[ndarray[Any, Any], NDArray[bool_]]]:
    ...

def clean_reindex_fill_method(method) -> ReindexMethod | None:
    ...

