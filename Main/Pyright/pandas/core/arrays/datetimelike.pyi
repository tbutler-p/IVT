"""
This type stub file was generated by pyright.
"""

import numpy as np
from typing import Any, Callable, Literal, TYPE_CHECKING, Union, overload
from pandas._libs.tslibs import BaseOffset, NaTType
from pandas._typing import ArrayLike, AxisInt, DatetimeLikeScalar, Dtype, DtypeObj, InterpolateOptions, NpDtype, PositionalIndexer2D, PositionalIndexerTuple, ScalarIndexer, Self, SequenceIndexer, TimeAmbiguous, TimeNonexistent, npt
from pandas.util._decorators import Appender, Substitution, cache_readonly
from pandas.core.dtypes.dtypes import ArrowDtype, DatetimeTZDtype
from pandas.core.arraylike import OpsMixin
from pandas.core.arrays._mixins import NDArrayBackedExtensionArray, ravel_compat
from pandas.core.ops.common import unpack_zerodim_and_defer
from collections.abc import Iterator, Sequence
from pandas import Index
from pandas.core.arrays import DatetimeArray, TimedeltaArray

if TYPE_CHECKING:
    ...
DTScalarOrNaT = Union[DatetimeLikeScalar, NaTType]
class DatetimeLikeArrayMixin(OpsMixin, NDArrayBackedExtensionArray):
    """
    Shared Base/Mixin class for DatetimeArray, TimedeltaArray, PeriodArray

    Assumes that __new__/__init__ defines:
        _ndarray

    and that inheriting subclass implements:
        freq
    """
    _infer_matches: tuple[str, ...]
    _is_recognized_dtype: Callable[[DtypeObj], bool]
    _recognized_scalars: tuple[type, ...]
    _ndarray: np.ndarray
    freq: BaseOffset | None
    def __init__(self, data, dtype: Dtype | None = ..., freq=..., copy: bool = ...) -> None:
        ...
    
    def __iter__(self) -> Iterator:
        ...
    
    @property
    def asi8(self) -> npt.NDArray[np.int64]:
        """
        Integer representation of the values.

        Returns
        -------
        ndarray
            An ndarray with int64 dtype.
        """
        ...
    
    def __array__(self, dtype: NpDtype | None = ..., copy: bool | None = ...) -> np.ndarray:
        ...
    
    @overload
    def __getitem__(self, item: ScalarIndexer) -> DTScalarOrNaT:
        ...
    
    @overload
    def __getitem__(self, item: SequenceIndexer | PositionalIndexerTuple) -> Self:
        ...
    
    def __getitem__(self, key: PositionalIndexer2D) -> Self | DTScalarOrNaT:
        """
        This getitem defers to the underlying array, which by-definition can
        only handle list-likes, slices, and integer scalars
        """
        ...
    
    def __setitem__(self, key: int | Sequence[int] | Sequence[bool] | slice, value: NaTType | Any | Sequence[Any]) -> None:
        ...
    
    def astype(self, dtype, copy: bool = ...): # -> NDArray[object_] | ndarray[tuple[int, ...], Any] | ExtensionArray | NDArray[int64] | NDArray[Any]:
        ...
    
    @overload
    def view(self) -> Self:
        ...
    
    @overload
    def view(self, dtype: Literal["M8[ns]"]) -> DatetimeArray:
        ...
    
    @overload
    def view(self, dtype: Literal["m8[ns]"]) -> TimedeltaArray:
        ...
    
    @overload
    def view(self, dtype: Dtype | None = ...) -> ArrayLike:
        ...
    
    def view(self, dtype: Dtype | None = ...) -> ArrayLike:
        ...
    
    @ravel_compat
    def map(self, mapper, na_action=...): # -> ndarray[Any, Any] | ExtensionArray:
        ...
    
    def isin(self, values: ArrayLike) -> npt.NDArray[np.bool_]:
        """
        Compute boolean array of whether each value is found in the
        passed set of values.

        Parameters
        ----------
        values : np.ndarray or ExtensionArray

        Returns
        -------
        ndarray[bool]
        """
        ...
    
    def isna(self) -> npt.NDArray[np.bool_]:
        ...
    
    @property
    def freqstr(self) -> str | None:
        """
        Return the frequency object as a string if it's set, otherwise None.

        Examples
        --------
        For DatetimeIndex:

        >>> idx = pd.DatetimeIndex(["1/1/2020 10:00:00+00:00"], freq="D")
        >>> idx.freqstr
        'D'

        The frequency can be inferred if there are more than 2 points:

        >>> idx = pd.DatetimeIndex(["2018-01-01", "2018-01-03", "2018-01-05"],
        ...                        freq="infer")
        >>> idx.freqstr
        '2D'

        For PeriodIndex:

        >>> idx = pd.PeriodIndex(["2023-1", "2023-2", "2023-3"], freq="M")
        >>> idx.freqstr
        'M'
        """
        ...
    
    @property
    def inferred_freq(self) -> str | None:
        """
        Tries to return a string representing a frequency generated by infer_freq.

        Returns None if it can't autodetect the frequency.

        Examples
        --------
        For DatetimeIndex:

        >>> idx = pd.DatetimeIndex(["2018-01-01", "2018-01-03", "2018-01-05"])
        >>> idx.inferred_freq
        '2D'

        For TimedeltaIndex:

        >>> tdelta_idx = pd.to_timedelta(["0 days", "10 days", "20 days"])
        >>> tdelta_idx
        TimedeltaIndex(['0 days', '10 days', '20 days'],
                       dtype='timedelta64[ns]', freq=None)
        >>> tdelta_idx.inferred_freq
        '10D'
        """
        ...
    
    @property
    def resolution(self) -> str:
        """
        Returns day, hour, minute, second, millisecond or microsecond
        """
        ...
    
    __pow__ = ...
    __rpow__ = ...
    __mul__ = ...
    __rmul__ = ...
    __truediv__ = ...
    __rtruediv__ = ...
    __floordiv__ = ...
    __rfloordiv__ = ...
    __mod__ = ...
    __rmod__ = ...
    __divmod__ = ...
    __rdivmod__ = ...
    @unpack_zerodim_and_defer("__add__")
    def __add__(self, other): # -> DatetimeArray | _NotImplementedType | TimedeltaArray | PeriodArray | ndarray[Any, Any]:
        ...
    
    def __radd__(self, other): # -> DatetimeArray | _NotImplementedType | TimedeltaArray | PeriodArray | ndarray[Any, Any]:
        ...
    
    @unpack_zerodim_and_defer("__sub__")
    def __sub__(self, other): # -> _NotImplementedType | TimedeltaArray | DatetimeArray | PeriodArray | ndarray[tuple[int, ...], dtype[Any]] | ndarray[Any, Any] | ndarray[_Shape, dtype[object_]]:
        ...
    
    def __rsub__(self, other): # -> _NotImplementedType | TimedeltaArray | DatetimeArray | PeriodArray | ndarray[tuple[int, ...], dtype[Any]] | ndarray[Any, Any] | ndarray[_Shape, dtype[object_]]:
        ...
    
    def __iadd__(self, other) -> Self:
        ...
    
    def __isub__(self, other) -> Self:
        ...
    
    @_period_dispatch
    def min(self, *, axis: AxisInt | None = ..., skipna: bool = ..., **kwargs):
        """
        Return the minimum value of the Array or minimum along
        an axis.

        See Also
        --------
        numpy.ndarray.min
        Index.min : Return the minimum value in an Index.
        Series.min : Return the minimum value in a Series.
        """
        ...
    
    @_period_dispatch
    def max(self, *, axis: AxisInt | None = ..., skipna: bool = ..., **kwargs):
        """
        Return the maximum value of the Array or maximum along
        an axis.

        See Also
        --------
        numpy.ndarray.max
        Index.max : Return the maximum value in an Index.
        Series.max : Return the maximum value in a Series.
        """
        ...
    
    def mean(self, *, skipna: bool = ..., axis: AxisInt | None = ...):
        """
        Return the mean value of the Array.

        Parameters
        ----------
        skipna : bool, default True
            Whether to ignore any NaT elements.
        axis : int, optional, default 0

        Returns
        -------
        scalar
            Timestamp or Timedelta.

        See Also
        --------
        numpy.ndarray.mean : Returns the average of array elements along a given axis.
        Series.mean : Return the mean value in a Series.

        Notes
        -----
        mean is only defined for Datetime and Timedelta dtypes, not for Period.

        Examples
        --------
        For :class:`pandas.DatetimeIndex`:

        >>> idx = pd.date_range('2001-01-01 00:00', periods=3)
        >>> idx
        DatetimeIndex(['2001-01-01', '2001-01-02', '2001-01-03'],
                      dtype='datetime64[ns]', freq='D')
        >>> idx.mean()
        Timestamp('2001-01-02 00:00:00')

        For :class:`pandas.TimedeltaIndex`:

        >>> tdelta_idx = pd.to_timedelta([1, 2, 3], unit='D')
        >>> tdelta_idx
        TimedeltaIndex(['1 days', '2 days', '3 days'],
                        dtype='timedelta64[ns]', freq=None)
        >>> tdelta_idx.mean()
        Timedelta('2 days 00:00:00')
        """
        ...
    
    @_period_dispatch
    def median(self, *, axis: AxisInt | None = ..., skipna: bool = ..., **kwargs):
        ...
    


class DatelikeOps(DatetimeLikeArrayMixin):
    """
    Common ops for DatetimeIndex/PeriodIndex, but not TimedeltaIndex.
    """
    @Substitution(URL="https://docs.python.org/3/library/datetime.html" "#strftime-and-strptime-behavior")
    def strftime(self, date_format: str) -> npt.NDArray[np.object_]:
        """
        Convert to Index using specified date_format.

        Return an Index of formatted strings specified by date_format, which
        supports the same string format as the python standard library. Details
        of the string format can be found in `python string format
        doc <%(URL)s>`__.

        Formats supported by the C `strftime` API but not by the python string format
        doc (such as `"%%R"`, `"%%r"`) are not officially supported and should be
        preferably replaced with their supported equivalents (such as `"%%H:%%M"`,
        `"%%I:%%M:%%S %%p"`).

        Note that `PeriodIndex` support additional directives, detailed in
        `Period.strftime`.

        Parameters
        ----------
        date_format : str
            Date format string (e.g. "%%Y-%%m-%%d").

        Returns
        -------
        ndarray[object]
            NumPy ndarray of formatted strings.

        See Also
        --------
        to_datetime : Convert the given argument to datetime.
        DatetimeIndex.normalize : Return DatetimeIndex with times to midnight.
        DatetimeIndex.round : Round the DatetimeIndex to the specified freq.
        DatetimeIndex.floor : Floor the DatetimeIndex to the specified freq.
        Timestamp.strftime : Format a single Timestamp.
        Period.strftime : Format a single Period.

        Examples
        --------
        >>> rng = pd.date_range(pd.Timestamp("2018-03-10 09:00"),
        ...                     periods=3, freq='s')
        >>> rng.strftime('%%B %%d, %%Y, %%r')
        Index(['March 10, 2018, 09:00:00 AM', 'March 10, 2018, 09:00:01 AM',
               'March 10, 2018, 09:00:02 AM'],
              dtype='object')
        """
        ...
    


_round_doc = ...
_round_example = ...
_floor_example = ...
_ceil_example = ...
class TimelikeOps(DatetimeLikeArrayMixin):
    """
    Common ops for TimedeltaIndex/DatetimeIndex, but not PeriodIndex.
    """
    _default_dtype: np.dtype
    def __init__(self, values, dtype=..., freq=..., copy: bool = ...) -> None:
        ...
    
    @property
    def freq(self): # -> Tick | BaseOffset | None:
        """
        Return the frequency object if it is set, otherwise None.
        """
        ...
    
    @freq.setter
    def freq(self, value) -> None:
        ...
    
    @cache_readonly
    def unit(self) -> str:
        ...
    
    def as_unit(self, unit: str, round_ok: bool = ...) -> Self:
        ...
    
    def __array_ufunc__(self, ufunc: np.ufunc, method: str, *inputs, **kwargs): # -> Any | _NotImplementedType | tuple[Any, ...]:
        ...
    
    @Appender((_round_doc + _round_example).format(op="round"))
    def round(self, freq, ambiguous: TimeAmbiguous = ..., nonexistent: TimeNonexistent = ...) -> Self:
        ...
    
    @Appender((_round_doc + _floor_example).format(op="floor"))
    def floor(self, freq, ambiguous: TimeAmbiguous = ..., nonexistent: TimeNonexistent = ...) -> Self:
        ...
    
    @Appender((_round_doc + _ceil_example).format(op="ceil"))
    def ceil(self, freq, ambiguous: TimeAmbiguous = ..., nonexistent: TimeNonexistent = ...) -> Self:
        ...
    
    def any(self, *, axis: AxisInt | None = ..., skipna: bool = ...) -> bool:
        ...
    
    def all(self, *, axis: AxisInt | None = ..., skipna: bool = ...) -> bool:
        ...
    
    def factorize(self, use_na_sentinel: bool = ..., sort: bool = ...): # -> tuple[ndarray[_Shape, dtype[signedinteger[_NBitIntP]]] | _Array1D[signedinteger[_NBitIntP]], Self] | tuple[ndarray[Any, Any], ExtensionArray]:
        ...
    
    def copy(self, order: str = ...) -> Self:
        ...
    
    def interpolate(self, *, method: InterpolateOptions, axis: int, index: Index, limit, limit_direction, limit_area, copy: bool, **kwargs) -> Self:
        """
        See NDFrame.interpolate.__doc__.
        """
        ...
    


def ensure_arraylike_for_datetimelike(data, copy: bool, cls_name: str) -> tuple[ArrayLike, bool]:
    ...

@overload
def validate_periods(periods: None) -> None:
    ...

@overload
def validate_periods(periods: int | float) -> int:
    ...

def validate_periods(periods: int | float | None) -> int | None:
    """
    If a `periods` argument is passed to the Datetime/Timedelta Array/Index
    constructor, cast it to an integer.

    Parameters
    ----------
    periods : None, float, int

    Returns
    -------
    periods : None or int

    Raises
    ------
    TypeError
        if periods is None, float, or int
    """
    ...

def dtype_to_unit(dtype: DatetimeTZDtype | np.dtype | ArrowDtype) -> str:
    """
    Return the unit str corresponding to the dtype's resolution.

    Parameters
    ----------
    dtype : DatetimeTZDtype or np.dtype
        If np.dtype, we assume it is a datetime64 dtype.

    Returns
    -------
    str
    """
    ...

