"""
This type stub file was generated by pyright.
"""

import io
import sys
import warnings
from collections import Counter
from .builder import TreeBuilder, builder_registry
from .builder._htmlparser import HTMLParserTreeBuilder
from .dammit import UnicodeDammit
from .css import CSS
from ._deprecation import _deprecated
from .element import CData, Comment, DEFAULT_OUTPUT_ENCODING, Declaration, Doctype, NavigableString, PYTHON_SPECIFIC_ENCODINGS, PageElement, ProcessingInstruction, ResultSet, Script, Stylesheet, Tag, TemplateString
from .formatter import Formatter
from .filter import ElementFilter, SoupStrainer
from typing import Any, Counter as CounterType, Dict, Iterator, List, Optional, Sequence, Sized, Type, Union, cast
from bs4._typing import _Encoding, _Encodings, _IncomingMarkup, _InsertableElement, _RawAttributeValue, _RawAttributeValues, _RawMarkup
from bs4.exceptions import FeatureNotFound, ParserRejectedMarkup, StopParsing
from bs4._warnings import AttributeResemblesVariableWarning, GuessedAtParserWarning, MarkupResemblesLocatorWarning, UnusualUsageWarning, XMLParsedAsHTMLWarning

"""Beautiful Soup Elixir and Tonic - "The Screen-Scraper's Friend".

http://www.crummy.com/software/BeautifulSoup/

Beautiful Soup uses a pluggable XML or HTML parser to parse a
(possibly invalid) document into a tree representation. Beautiful Soup
provides methods and Pythonic idioms that make it easy to navigate,
search, and modify the parse tree.

Beautiful Soup works with Python 3.7 and up. It works better if lxml
and/or html5lib is installed, but they are not required.

For more than you ever wanted to know about Beautiful Soup, see the
documentation: http://www.crummy.com/software/BeautifulSoup/bs4/doc/
"""
__author__ = ...
__version__ = ...
__copyright__ = ...
__license__ = ...
__all__ = ["AttributeResemblesVariableWarning", "BeautifulSoup", "Comment", "Declaration", "ProcessingInstruction", "ResultSet", "CSS", "Script", "Stylesheet", "Tag", "TemplateString", "ElementFilter", "UnicodeDammit", "CData", "Doctype", "FeatureNotFound", "ParserRejectedMarkup", "StopParsing", "AttributeResemblesVariableWarning", "GuessedAtParserWarning", "MarkupResemblesLocatorWarning", "UnusualUsageWarning", "XMLParsedAsHTMLWarning"]
if sys.version_info.major < 3:
    ...
class BeautifulSoup(Tag):
    """A data structure representing a parsed HTML or XML document.

    Most of the methods you'll call on a BeautifulSoup object are inherited from
    PageElement or Tag.

    Internally, this class defines the basic interface called by the
    tree builders when converting an HTML/XML document into a data
    structure. The interface abstracts away the differences between
    parsers. To write a new tree builder, you'll need to understand
    these methods as a whole.

    These methods will be called by the BeautifulSoup constructor:
      * reset()
      * feed(markup)

    The tree builder may call these methods from its feed() implementation:
      * handle_starttag(name, attrs) # See note about return value
      * handle_endtag(name)
      * handle_data(data) # Appends to the current data node
      * endData(containerClass) # Ends the current data node

    No matter how complicated the underlying parser is, you should be
    able to build a tree using 'start tag' events, 'end tag' events,
    'data' events, and "done with data" events.

    If you encounter an empty-element tag (aka a self-closing tag,
    like HTML's <br> tag), call handle_starttag and then
    handle_endtag.
    """
    ROOT_TAG_NAME: str = ...
    DEFAULT_BUILDER_FEATURES: Sequence[str] = ...
    ASCII_SPACES: str = ...
    element_classes: Dict[Type[PageElement], Type[PageElement]]
    builder: TreeBuilder
    is_xml: bool
    known_xml: Optional[bool]
    parse_only: Optional[SoupStrainer]
    markup: Optional[_RawMarkup]
    current_data: List[str]
    currentTag: Optional[Tag]
    tagStack: List[Tag]
    open_tag_counter: CounterType[str]
    preserve_whitespace_tag_stack: List[Tag]
    string_container_stack: List[Tag]
    _most_recent_element: Optional[PageElement]
    original_encoding: Optional[_Encoding]
    declared_html_encoding: Optional[_Encoding]
    contains_replacement_characters: bool
    def __init__(self, markup: _IncomingMarkup = ..., features: Optional[Union[str, Sequence[str]]] = ..., builder: Optional[Union[TreeBuilder, Type[TreeBuilder]]] = ..., parse_only: Optional[SoupStrainer] = ..., from_encoding: Optional[_Encoding] = ..., exclude_encodings: Optional[_Encodings] = ..., element_classes: Optional[Dict[Type[PageElement], Type[PageElement]]] = ..., **kwargs: Any) -> None:
        """Constructor.

        :param markup: A string or a file-like object representing
         markup to be parsed.

        :param features: Desirable features of the parser to be
         used. This may be the name of a specific parser ("lxml",
         "lxml-xml", "html.parser", or "html5lib") or it may be the
         type of markup to be used ("html", "html5", "xml"). It's
         recommended that you name a specific parser, so that
         Beautiful Soup gives you the same results across platforms
         and virtual environments.

        :param builder: A TreeBuilder subclass to instantiate (or
         instance to use) instead of looking one up based on
         `features`. You only need to use this if you've implemented a
         custom TreeBuilder.

        :param parse_only: A SoupStrainer. Only parts of the document
         matching the SoupStrainer will be considered. This is useful
         when parsing part of a document that would otherwise be too
         large to fit into memory.

        :param from_encoding: A string indicating the encoding of the
         document to be parsed. Pass this in if Beautiful Soup is
         guessing wrongly about the document's encoding.

        :param exclude_encodings: A list of strings indicating
         encodings known to be wrong. Pass this in if you don't know
         the document's encoding but you know Beautiful Soup's guess is
         wrong.

        :param element_classes: A dictionary mapping BeautifulSoup
         classes like Tag and NavigableString, to other classes you'd
         like to be instantiated instead as the parse tree is
         built. This is useful for subclassing Tag or NavigableString
         to modify default behavior.

        :param kwargs: For backwards compatibility purposes, the
         constructor accepts certain keyword arguments used in
         Beautiful Soup 3. None of these arguments do anything in
         Beautiful Soup 4; they will result in a warning and then be
         ignored.

         Apart from this, any keyword arguments passed into the
         BeautifulSoup constructor are propagated to the TreeBuilder
         constructor. This makes it possible to configure a
         TreeBuilder by passing in arguments, not just by saying which
         one to use.
        """
        ...
    
    def copy_self(self) -> BeautifulSoup:
        """Create a new BeautifulSoup object with the same TreeBuilder,
        but not associated with any markup.

        This is the first step of the deepcopy process.
        """
        ...
    
    def __getstate__(self) -> Dict[str, Any]:
        ...
    
    def __setstate__(self, state: Dict[str, Any]) -> None:
        ...
    
    def reset(self) -> None:
        """Reset this object to a state as though it had never parsed any
        markup.
        """
        ...
    
    def new_tag(self, name: str, namespace: Optional[str] = ..., nsprefix: Optional[str] = ..., attrs: Optional[_RawAttributeValues] = ..., sourceline: Optional[int] = ..., sourcepos: Optional[int] = ..., string: Optional[str] = ..., **kwattrs: _RawAttributeValue) -> Tag:
        """Create a new Tag associated with this BeautifulSoup object.

        :param name: The name of the new Tag.
        :param namespace: The URI of the new Tag's XML namespace, if any.
        :param prefix: The prefix for the new Tag's XML namespace, if any.
        :param attrs: A dictionary of this Tag's attribute values; can
            be used instead of ``kwattrs`` for attributes like 'class'
            that are reserved words in Python.
        :param sourceline: The line number where this tag was
            (purportedly) found in its source document.
        :param sourcepos: The character position within ``sourceline`` where this
            tag was (purportedly) found.
        :param string: String content for the new Tag, if any.
        :param kwattrs: Keyword arguments for the new Tag's attribute values.

        """
        ...
    
    def string_container(self, base_class: Optional[Type[NavigableString]] = ...) -> Type[NavigableString]:
        """Find the class that should be instantiated to hold a given kind of
        string.

        This may be a built-in Beautiful Soup class or a custom class passed
        in to the BeautifulSoup constructor.
        """
        ...
    
    def new_string(self, s: str, subclass: Optional[Type[NavigableString]] = ...) -> NavigableString:
        """Create a new `NavigableString` associated with this `BeautifulSoup`
        object.

        :param s: The string content of the `NavigableString`
        :param subclass: The subclass of `NavigableString`, if any, to
               use. If a document is being processed, an appropriate
               subclass for the current location in the document will
               be determined automatically.
        """
        ...
    
    def insert_before(self, *args: _InsertableElement) -> List[PageElement]:
        """This method is part of the PageElement API, but `BeautifulSoup` doesn't implement
        it because there is nothing before or after it in the parse tree.
        """
        ...
    
    def insert_after(self, *args: _InsertableElement) -> List[PageElement]:
        """This method is part of the PageElement API, but `BeautifulSoup` doesn't implement
        it because there is nothing before or after it in the parse tree.
        """
        ...
    
    def popTag(self) -> Optional[Tag]:
        """Internal method called by _popToTag when a tag is closed.

        :meta private:
        """
        ...
    
    def pushTag(self, tag: Tag) -> None:
        """Internal method called by handle_starttag when a tag is opened.

        :meta private:
        """
        ...
    
    def endData(self, containerClass: Optional[Type[NavigableString]] = ...) -> None:
        """Method called by the TreeBuilder when the end of a data segment
        occurs.

        :param containerClass: The class to use when incorporating the
        data segment into the parse tree.

        :meta private:
        """
        ...
    
    def object_was_parsed(self, o: PageElement, parent: Optional[Tag] = ..., most_recent_element: Optional[PageElement] = ...) -> None:
        """Method called by the TreeBuilder to integrate an object into the
        parse tree.

        :meta private:
        """
        ...
    
    def handle_starttag(self, name: str, namespace: Optional[str], nsprefix: Optional[str], attrs: _RawAttributeValues, sourceline: Optional[int] = ..., sourcepos: Optional[int] = ..., namespaces: Optional[Dict[str, str]] = ...) -> Optional[Tag]:
        """Called by the tree builder when a new tag is encountered.

        :param name: Name of the tag.
        :param nsprefix: Namespace prefix for the tag.
        :param attrs: A dictionary of attribute values. Note that
           attribute values are expected to be simple strings; processing
           of multi-valued attributes such as "class" comes later.
        :param sourceline: The line number where this tag was found in its
            source document.
        :param sourcepos: The character position within `sourceline` where this
            tag was found.
        :param namespaces: A dictionary of all namespace prefix mappings
            currently in scope in the document.

        If this method returns None, the tag was rejected by an active
        `ElementFilter`. You should proceed as if the tag had not occurred
        in the document. For instance, if this was a self-closing tag,
        don't call handle_endtag.

        :meta private:
        """
        ...
    
    def handle_endtag(self, name: str, nsprefix: Optional[str] = ...) -> None:
        """Called by the tree builder when an ending tag is encountered.

        :param name: Name of the tag.
        :param nsprefix: Namespace prefix for the tag.

        :meta private:
        """
        ...
    
    def handle_data(self, data: str) -> None:
        """Called by the tree builder when a chunk of textual data is
        encountered.

        :meta private:
        """
        ...
    
    def decode(self, indent_level: Optional[int] = ..., eventual_encoding: _Encoding = ..., formatter: Union[Formatter, str] = ..., iterator: Optional[Iterator[PageElement]] = ..., **kwargs: Any) -> str:
        """Returns a string representation of the parse tree
            as a full HTML or XML document.

        :param indent_level: Each line of the rendering will be
           indented this many levels. (The ``formatter`` decides what a
           'level' means, in terms of spaces or other characters
           output.) This is used internally in recursive calls while
           pretty-printing.
        :param eventual_encoding: The encoding of the final document.
            If this is None, the document will be a Unicode string.
        :param formatter: Either a `Formatter` object, or a string naming one of
            the standard formatters.
        :param iterator: The iterator to use when navigating over the
            parse tree. This is only used by `Tag.decode_contents` and
            you probably won't need to use it.
        """
        ...
    


_s = BeautifulSoup
_soup = BeautifulSoup
class BeautifulStoneSoup(BeautifulSoup):
    """Deprecated interface to an XML parser."""
    def __init__(self, *args: Any, **kwargs: Any) -> None:
        ...
    


if __name__ == "__main__":
    soup = ...
