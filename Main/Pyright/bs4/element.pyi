"""
This type stub file was generated by pyright.
"""

from bs4.css import CSS
from bs4._deprecation import _deprecated
from bs4.formatter import Formatter, _EntitySubstitutionFunction, _FormatterOrName
from typing import Any, Dict, Generic, Iterable, Iterator, List, Optional, Pattern, Set, TYPE_CHECKING, Tuple, Type, TypeVar, Union, overload
from typing_extensions import Self, TypeAlias
from bs4 import BeautifulSoup
from bs4.builder import TreeBuilder
from bs4.filter import ElementFilter
from bs4._typing import _AtMostOneElement, _AtMostOneNavigableString, _AtMostOneTag, _AttributeValue, _AttributeValues, _Encoding, _InsertableElement, _OneElement, _QueryResults, _RawOrProcessedAttributeValues, _SomeNavigableStrings, _SomeTags, _StrainableAttribute, _StrainableAttributes, _StrainableElement, _StrainableString

__license__ = ...
if TYPE_CHECKING:
    ...
_OneOrMoreStringTypes: TypeAlias = Union[Type["NavigableString"], Iterable[Type["NavigableString"]]]
_FindMethodName: TypeAlias = Optional[Union["_StrainableElement", "ElementFilter"]]
_deprecated_names = ...
_deprecated_whitespace_re: Pattern[str] = ...
def __getattr__(name: str) -> Any:
    ...

DEFAULT_OUTPUT_ENCODING: str = ...
nonwhitespace_re: Pattern[str] = ...
PYTHON_SPECIFIC_ENCODINGS: Set[_Encoding] = ...
class NamespacedAttribute(str):
    """A namespaced attribute (e.g. the 'xml:lang' in 'xml:lang="en"')
    which remembers the namespace prefix ('xml') and the name ('lang')
    that were used to create it.
    """
    prefix: Optional[str]
    name: Optional[str]
    namespace: Optional[str]
    def __new__(cls, prefix: Optional[str], name: Optional[str] = ..., namespace: Optional[str] = ...) -> Self:
        ...
    


class AttributeValueWithCharsetSubstitution(str):
    """An abstract class standing in for a character encoding specified
    inside an HTML ``<meta>`` tag.

    Subclasses exist for each place such a character encoding might be
    found: either inside the ``charset`` attribute
    (`CharsetMetaAttributeValue`) or inside the ``content`` attribute
    (`ContentMetaAttributeValue`)

    This allows Beautiful Soup to replace that part of the HTML file
    with a different encoding when ouputting a tree as a string.
    """
    original_value: str
    def substitute_encoding(self, eventual_encoding: str) -> str:
        """Do whatever's necessary in this implementation-specific
        portion an HTML document to substitute in a specific encoding.
        """
        ...
    


class CharsetMetaAttributeValue(AttributeValueWithCharsetSubstitution):
    """A generic stand-in for the value of a ``<meta>`` tag's ``charset``
    attribute.

    When Beautiful Soup parses the markup ``<meta charset="utf8">``, the
    value of the ``charset`` attribute will become one of these objects.

    If the document is later encoded to an encoding other than UTF-8, its
    ``<meta>`` tag will mention the new encoding instead of ``utf8``.
    """
    def __new__(cls, original_value: str) -> Self:
        ...
    
    def substitute_encoding(self, eventual_encoding: _Encoding = ...) -> str:
        """When an HTML document is being encoded to a given encoding, the
        value of a ``<meta>`` tag's ``charset`` becomes the name of
        the encoding.
        """
        ...
    


class AttributeValueList(List[str]):
    """Class for the list used to hold the values of attributes which
    have multiple values (such as HTML's 'class'). It's just a regular
    list, but you can subclass it and pass it in to the TreeBuilder
    constructor as attribute_value_list_class, to have your subclass
    instantiated instead.
    """
    ...


class AttributeDict(Dict[Any, Any]):
    """Superclass for the dictionary used to hold a tag's
    attributes. You can use this, but it's just a regular dict with no
    special logic.
    """
    ...


class XMLAttributeDict(AttributeDict):
    """A dictionary for holding a Tag's attributes, which processes
    incoming values for consistency with the HTML spec.
    """
    def __setitem__(self, key: str, value: Any) -> None:
        """Set an attribute value, possibly modifying it to comply with
        the XML spec.

        This just means converting common non-string values to
        strings: XML attributes may have "any literal string as a
        value."
        """
        ...
    


class HTMLAttributeDict(AttributeDict):
    """A dictionary for holding a Tag's attributes, which processes
    incoming values for consistency with the HTML spec, which says
    'Attribute values are a mixture of text and character
    references...'

    Basically, this means converting common non-string values into
    strings, like XMLAttributeDict, though HTML also has some rules
    around boolean attributes that XML doesn't have.
    """
    def __setitem__(self, key: str, value: Any) -> None:
        """Set an attribute value, possibly modifying it to comply
        with the HTML spec,
        """
        ...
    


class ContentMetaAttributeValue(AttributeValueWithCharsetSubstitution):
    """A generic stand-in for the value of a ``<meta>`` tag's ``content``
    attribute.

    When Beautiful Soup parses the markup:
     ``<meta http-equiv="content-type" content="text/html; charset=utf8">``

    The value of the ``content`` attribute will become one of these objects.

    If the document is later encoded to an encoding other than UTF-8, its
    ``<meta>`` tag will mention the new encoding instead of ``utf8``.
    """
    CHARSET_RE: Pattern[str] = ...
    def __new__(cls, original_value: str) -> Self:
        ...
    
    def substitute_encoding(self, eventual_encoding: _Encoding = ...) -> str:
        """When an HTML document is being encoded to a given encoding, the
        value of the ``charset=`` in a ``<meta>`` tag's ``content`` becomes
        the name of the encoding.
        """
        ...
    


class PageElement:
    """An abstract class representing a single element in the parse tree.

    `NavigableString`, `Tag`, etc. are all subclasses of
    `PageElement`. For this reason you'll see a lot of methods that
    return `PageElement`, but you'll never see an actual `PageElement`
    object. For the most part you can think of `PageElement` as
    meaning "a `Tag` or a `NavigableString`."
    """
    known_xml: Optional[bool] = ...
    _decomposed: bool
    parent: Optional[Tag]
    next_element: _AtMostOneElement
    previous_element: _AtMostOneElement
    next_sibling: _AtMostOneElement
    previous_sibling: _AtMostOneElement
    hidden: bool = ...
    def setup(self, parent: Optional[Tag] = ..., previous_element: _AtMostOneElement = ..., next_element: _AtMostOneElement = ..., previous_sibling: _AtMostOneElement = ..., next_sibling: _AtMostOneElement = ...) -> None:
        """Sets up the initial relations between this element and
        other elements.

        :param parent: The parent of this element.

        :param previous_element: The element parsed immediately before
            this one.

        :param next_element: The element parsed immediately after
            this one.

        :param previous_sibling: The most recently encountered element
            on the same level of the parse tree as this one.

        :param previous_sibling: The next element to be encountered
            on the same level of the parse tree as this one.
        """
        ...
    
    def format_string(self, s: str, formatter: Optional[_FormatterOrName]) -> str:
        """Format the given string using the given formatter.

        :param s: A string.
        :param formatter: A Formatter object, or a string naming one of the standard formatters.
        """
        ...
    
    def formatter_for_name(self, formatter_name: Union[_FormatterOrName, _EntitySubstitutionFunction]) -> Formatter:
        """Look up or create a Formatter for the given identifier,
        if necessary.

        :param formatter: Can be a `Formatter` object (used as-is), a
            function (used as the entity substitution hook for an
            `bs4.formatter.XMLFormatter` or
            `bs4.formatter.HTMLFormatter`), or a string (used to look
            up an `bs4.formatter.XMLFormatter` or
            `bs4.formatter.HTMLFormatter` in the appropriate registry.

        """
        ...
    
    nextSibling = ...
    previousSibling = ...
    def __deepcopy__(self, memo: Dict[Any, Any], recursive: bool = ...) -> Self:
        ...
    
    def __copy__(self) -> Self:
        """A copy of a PageElement can only be a deep copy, because
        only one PageElement can occupy a given place in a parse tree.
        """
        ...
    
    default: Iterable[type[NavigableString]] = ...
    @property
    def stripped_strings(self) -> Iterator[str]:
        """Yield all interesting strings in this PageElement, stripping them
        first.

        See `Tag` for information on which strings are considered
        interesting in a given context.
        """
        ...
    
    def get_text(self, separator: str = ..., strip: bool = ..., types: Iterable[Type[NavigableString]] = ...) -> str:
        """Get all child strings of this PageElement, concatenated using the
        given separator.

        :param separator: Strings will be concatenated using this separator.

        :param strip: If True, strings will be stripped before being
            concatenated.

        :param types: A tuple of NavigableString subclasses. Any
            strings of a subclass not found in this list will be
            ignored. Although there are exceptions, the default
            behavior in most cases is to consider only NavigableString
            and CData objects. That means no comments, processing
            instructions, etc.

        :return: A string.
        """
        ...
    
    getText = ...
    text = ...
    def replace_with(self, *args: _InsertableElement) -> Self:
        """Replace this `PageElement` with one or more other elements,
        objects, keeping the rest of the tree the same.

        :return: This `PageElement`, no longer part of the tree.
        """
        ...
    
    replaceWith = ...
    def wrap(self, wrap_inside: Tag) -> Tag:
        """Wrap this `PageElement` inside a `Tag`.

        :return: ``wrap_inside``, occupying the position in the tree that used
           to be occupied by this object, and with this object now inside it.
        """
        ...
    
    def extract(self, _self_index: Optional[int] = ...) -> Self:
        """Destructively rips this element out of the tree.

        :param _self_index: The location of this element in its parent's
           .contents, if known. Passing this in allows for a performance
           optimization.

        :return: this `PageElement`, no longer part of the tree.
        """
        ...
    
    def decompose(self) -> None:
        """Recursively destroys this `PageElement` and its children.

        The element will be removed from the tree and wiped out; so
        will everything beneath it.

        The behavior of a decomposed `PageElement` is undefined and you
        should never use one for anything, but if you need to *check*
        whether an element has been decomposed, you can use the
        `PageElement.decomposed` property.
        """
        ...
    
    _lastRecursiveChild = ...
    def insert_before(self, *args: _InsertableElement) -> List[PageElement]:
        """Makes the given element(s) the immediate predecessor of this one.

        All the elements will have the same `PageElement.parent` as
        this one, and the given elements will occur immediately before
        this one.

        :param args: One or more PageElements.

        :return The list of PageElements that were inserted.
        """
        ...
    
    def insert_after(self, *args: _InsertableElement) -> List[PageElement]:
        """Makes the given element(s) the immediate successor of this one.

        The elements will have the same `PageElement.parent` as this
        one, and the given elements will occur immediately after this
        one.

        :param args: One or more PageElements.

        :return The list of PageElements that were inserted.
        """
        ...
    
    @overload
    def find_next(self, name: _FindMethodName = ..., attrs: Optional[_StrainableAttributes] = ..., string: None = ..., **kwargs: _StrainableAttribute) -> _AtMostOneTag:
        ...
    
    @overload
    def find_next(self, name: None = ..., attrs: None = ..., string: _StrainableString = ..., **kwargs: _StrainableAttribute) -> _AtMostOneNavigableString:
        ...
    
    def find_next(self, name: _FindMethodName = ..., attrs: Optional[_StrainableAttributes] = ..., string: Optional[_StrainableString] = ..., **kwargs: _StrainableAttribute) -> Union[_AtMostOneTag, _AtMostOneNavigableString, _AtMostOneElement]:
        """Find the first PageElement that matches the given criteria and
        appears later in the document than this PageElement.

        All find_* methods take a common set of arguments. See the online
        documentation for detailed explanations.

        :param name: A filter on tag name.
        :param attrs: Additional filters on attribute values.
        :param string: A filter for a NavigableString with specific text.
        :kwargs: Additional filters on attribute values.
        """
        ...
    
    findNext = ...
    @overload
    def find_all_next(self, name: _FindMethodName = ..., attrs: Optional[_StrainableAttributes] = ..., string: None = ..., limit: Optional[int] = ..., _stacklevel: int = ..., **kwargs: _StrainableAttribute) -> _SomeTags:
        ...
    
    @overload
    def find_all_next(self, name: None = ..., attrs: None = ..., string: _StrainableString = ..., limit: Optional[int] = ..., _stacklevel: int = ..., **kwargs: _StrainableAttribute) -> _SomeNavigableStrings:
        ...
    
    def find_all_next(self, name: _FindMethodName = ..., attrs: Optional[_StrainableAttributes] = ..., string: Optional[_StrainableString] = ..., limit: Optional[int] = ..., _stacklevel: int = ..., **kwargs: _StrainableAttribute) -> Union[_SomeTags, _SomeNavigableStrings, _QueryResults]:
        """Find all `PageElement` objects that match the given criteria and
        appear later in the document than this `PageElement`.

        All find_* methods take a common set of arguments. See the online
        documentation for detailed explanations.

        :param name: A filter on tag name.
        :param attrs: Additional filters on attribute values.
        :param string: A filter for a NavigableString with specific text.
        :param limit: Stop looking after finding this many results.
        :param _stacklevel: Used internally to improve warning messages.
        :kwargs: Additional filters on attribute values.
        """
        ...
    
    findAllNext = ...
    @overload
    def find_next_sibling(self, name: _FindMethodName = ..., attrs: Optional[_StrainableAttributes] = ..., string: None = ..., **kwargs: _StrainableAttribute) -> _AtMostOneTag:
        ...
    
    @overload
    def find_next_sibling(self, name: None = ..., attrs: None = ..., string: _StrainableString = ..., **kwargs: _StrainableAttribute) -> _AtMostOneNavigableString:
        ...
    
    def find_next_sibling(self, name: _FindMethodName = ..., attrs: Optional[_StrainableAttributes] = ..., string: Optional[_StrainableString] = ..., **kwargs: _StrainableAttribute) -> Union[_AtMostOneTag, _AtMostOneNavigableString, _AtMostOneElement]:
        """Find the closest sibling to this PageElement that matches the
        given criteria and appears later in the document.

        All find_* methods take a common set of arguments. See the
        online documentation for detailed explanations.

        :param name: A filter on tag name.
        :param attrs: Additional filters on attribute values.
        :param string: A filter for a `NavigableString` with specific text.
        :kwargs: Additional filters on attribute values.
        """
        ...
    
    findNextSibling = ...
    @overload
    def find_next_siblings(self, name: _FindMethodName = ..., attrs: Optional[_StrainableAttributes] = ..., string: None = ..., limit: Optional[int] = ..., _stacklevel: int = ..., **kwargs: _StrainableAttribute) -> _SomeTags:
        ...
    
    @overload
    def find_next_siblings(self, name: None = ..., attrs: None = ..., string: _StrainableString = ..., limit: Optional[int] = ..., _stacklevel: int = ..., **kwargs: _StrainableAttribute) -> _SomeNavigableStrings:
        ...
    
    def find_next_siblings(self, name: _FindMethodName = ..., attrs: Optional[_StrainableAttributes] = ..., string: Optional[_StrainableString] = ..., limit: Optional[int] = ..., _stacklevel: int = ..., **kwargs: _StrainableAttribute) -> Union[_SomeTags, _SomeNavigableStrings, _QueryResults]:
        """Find all siblings of this `PageElement` that match the given criteria
        and appear later in the document.

        All find_* methods take a common set of arguments. See the online
        documentation for detailed explanations.

        :param name: A filter on tag name.
        :param attrs: Additional filters on attribute values.
        :param string: A filter for a `NavigableString` with specific text.
        :param limit: Stop looking after finding this many results.
        :param _stacklevel: Used internally to improve warning messages.
        :kwargs: Additional filters on attribute values.
        """
        ...
    
    findNextSiblings = ...
    fetchNextSiblings = ...
    @overload
    def find_previous(self, name: _FindMethodName = ..., attrs: Optional[_StrainableAttributes] = ..., string: None = ..., **kwargs: _StrainableAttribute) -> _AtMostOneTag:
        ...
    
    @overload
    def find_previous(self, name: None = ..., attrs: None = ..., string: _StrainableString = ..., **kwargs: _StrainableAttribute) -> _AtMostOneNavigableString:
        ...
    
    def find_previous(self, name: _FindMethodName = ..., attrs: Optional[_StrainableAttributes] = ..., string: Optional[_StrainableString] = ..., **kwargs: _StrainableAttribute) -> Union[_AtMostOneTag, _AtMostOneNavigableString, _AtMostOneElement]:
        """Look backwards in the document from this `PageElement` and find the
        first `PageElement` that matches the given criteria.

        All find_* methods take a common set of arguments. See the online
        documentation for detailed explanations.

        :param name: A filter on tag name.
        :param attrs: Additional filters on attribute values.
        :param string: A filter for a `NavigableString` with specific text.
        :kwargs: Additional filters on attribute values.
        """
        ...
    
    findPrevious = ...
    @overload
    def find_all_previous(self, name: _FindMethodName = ..., attrs: Optional[_StrainableAttributes] = ..., string: None = ..., limit: Optional[int] = ..., _stacklevel: int = ..., **kwargs: _StrainableAttribute) -> _SomeTags:
        ...
    
    @overload
    def find_all_previous(self, name: None = ..., attrs: None = ..., string: _StrainableString = ..., limit: Optional[int] = ..., _stacklevel: int = ..., **kwargs: _StrainableAttribute) -> _SomeNavigableStrings:
        ...
    
    def find_all_previous(self, name: _FindMethodName = ..., attrs: Optional[_StrainableAttributes] = ..., string: Optional[_StrainableString] = ..., limit: Optional[int] = ..., _stacklevel: int = ..., **kwargs: _StrainableAttribute) -> Union[_SomeTags, _SomeNavigableStrings, _QueryResults]:
        """Look backwards in the document from this `PageElement` and find all
        `PageElement` that match the given criteria.

        All find_* methods take a common set of arguments. See the online
        documentation for detailed explanations.

        :param name: A filter on tag name.
        :param attrs: Additional filters on attribute values.
        :param string: A filter for a `NavigableString` with specific text.
        :param limit: Stop looking after finding this many results.
        :param _stacklevel: Used internally to improve warning messages.
        :kwargs: Additional filters on attribute values.
        """
        ...
    
    findAllPrevious = ...
    fetchAllPrevious = ...
    @overload
    def find_previous_sibling(self, name: _FindMethodName = ..., attrs: Optional[_StrainableAttributes] = ..., string: None = ..., **kwargs: _StrainableAttribute) -> _AtMostOneTag:
        ...
    
    @overload
    def find_previous_sibling(self, name: None = ..., attrs: None = ..., string: _StrainableString = ..., **kwargs: _StrainableAttribute) -> _AtMostOneNavigableString:
        ...
    
    def find_previous_sibling(self, name: _FindMethodName = ..., attrs: Optional[_StrainableAttributes] = ..., string: Optional[_StrainableString] = ..., **kwargs: _StrainableAttribute) -> Union[_AtMostOneTag, _AtMostOneNavigableString, _AtMostOneElement]:
        """Returns the closest sibling to this `PageElement` that matches the
        given criteria and appears earlier in the document.

        All find_* methods take a common set of arguments. See the online
        documentation for detailed explanations.

        :param name: A filter on tag name.
        :param attrs: Additional filters on attribute values.
        :param string: A filter for a `NavigableString` with specific text.
        :kwargs: Additional filters on attribute values.
        """
        ...
    
    findPreviousSibling = ...
    @overload
    def find_previous_siblings(self, name: _FindMethodName = ..., attrs: Optional[_StrainableAttributes] = ..., string: None = ..., limit: Optional[int] = ..., _stacklevel: int = ..., **kwargs: _StrainableAttribute) -> _SomeTags:
        ...
    
    @overload
    def find_previous_siblings(self, name: None = ..., attrs: None = ..., string: _StrainableString = ..., limit: Optional[int] = ..., _stacklevel: int = ..., **kwargs: _StrainableAttribute) -> _SomeNavigableStrings:
        ...
    
    def find_previous_siblings(self, name: _FindMethodName = ..., attrs: Optional[_StrainableAttributes] = ..., string: Optional[_StrainableString] = ..., limit: Optional[int] = ..., _stacklevel: int = ..., **kwargs: _StrainableAttribute) -> Union[_SomeTags, _SomeNavigableStrings, _QueryResults]:
        """Returns all siblings to this PageElement that match the
        given criteria and appear earlier in the document.

        All find_* methods take a common set of arguments. See the online
        documentation for detailed explanations.

        :param name: A filter on tag name.
        :param attrs: Additional filters on attribute values.
        :param string: A filter for a NavigableString with specific text.
        :param limit: Stop looking after finding this many results.
        :param _stacklevel: Used internally to improve warning messages.
        :kwargs: Additional filters on attribute values.
        """
        ...
    
    findPreviousSiblings = ...
    fetchPreviousSiblings = ...
    def find_parent(self, name: _FindMethodName = ..., attrs: Optional[_StrainableAttributes] = ..., **kwargs: _StrainableAttribute) -> _AtMostOneTag:
        """Find the closest parent of this PageElement that matches the given
        criteria.

        All find_* methods take a common set of arguments. See the online
        documentation for detailed explanations.

        :param name: A filter on tag name.
        :param attrs: Additional filters on attribute values.
        :param self: Whether the PageElement itself should be considered
           as one of its 'parents'.
        :kwargs: Additional filters on attribute values.
        """
        ...
    
    findParent = ...
    def find_parents(self, name: _FindMethodName = ..., attrs: Optional[_StrainableAttributes] = ..., limit: Optional[int] = ..., _stacklevel: int = ..., **kwargs: _StrainableAttribute) -> _SomeTags:
        """Find all parents of this `PageElement` that match the given criteria.

        All find_* methods take a common set of arguments. See the online
        documentation for detailed explanations.

        :param name: A filter on tag name.
        :param attrs: Additional filters on attribute values.
        :param limit: Stop looking after finding this many results.
        :param _stacklevel: Used internally to improve warning messages.
        :kwargs: Additional filters on attribute values.
        """
        ...
    
    findParents = ...
    fetchParents = ...
    @property
    def next(self) -> _AtMostOneElement:
        """The `PageElement`, if any, that was parsed just after this one."""
        ...
    
    @property
    def previous(self) -> _AtMostOneElement:
        """The `PageElement`, if any, that was parsed just before this one."""
        ...
    
    @property
    def next_elements(self) -> Iterator[PageElement]:
        """All PageElements that were parsed after this one."""
        ...
    
    @property
    def self_and_next_elements(self) -> Iterator[PageElement]:
        """This PageElement, then all PageElements that were parsed after it."""
        ...
    
    @property
    def next_siblings(self) -> Iterator[PageElement]:
        """All PageElements that are siblings of this one but were parsed
        later.
        """
        ...
    
    @property
    def self_and_next_siblings(self) -> Iterator[PageElement]:
        """This PageElement, then all of its siblings."""
        ...
    
    @property
    def previous_elements(self) -> Iterator[PageElement]:
        """All PageElements that were parsed before this one.

        :yield: A sequence of PageElements.
        """
        ...
    
    @property
    def self_and_previous_elements(self) -> Iterator[PageElement]:
        """This PageElement, then all elements that were parsed
        earlier."""
        ...
    
    @property
    def previous_siblings(self) -> Iterator[PageElement]:
        """All PageElements that are siblings of this one but were parsed
        earlier.

        :yield: A sequence of PageElements.
        """
        ...
    
    @property
    def self_and_previous_siblings(self) -> Iterator[PageElement]:
        """This PageElement, then all of its siblings that were parsed
        earlier."""
        ...
    
    @property
    def parents(self) -> Iterator[Tag]:
        """All elements that are parents of this PageElement.

        :yield: A sequence of Tags, ending with a BeautifulSoup object.
        """
        ...
    
    @property
    def self_and_parents(self) -> Iterator[PageElement]:
        """This element, then all of its parents.

        :yield: A sequence of PageElements, ending with a BeautifulSoup object.
        """
        ...
    
    @property
    def decomposed(self) -> bool:
        """Check whether a PageElement has been decomposed."""
        ...
    
    @_deprecated("next_elements", "4.0.0")
    def nextGenerator(self) -> Iterator[PageElement]:
        ":meta private:"
        ...
    
    @_deprecated("next_siblings", "4.0.0")
    def nextSiblingGenerator(self) -> Iterator[PageElement]:
        ":meta private:"
        ...
    
    @_deprecated("previous_elements", "4.0.0")
    def previousGenerator(self) -> Iterator[PageElement]:
        ":meta private:"
        ...
    
    @_deprecated("previous_siblings", "4.0.0")
    def previousSiblingGenerator(self) -> Iterator[PageElement]:
        ":meta private:"
        ...
    
    @_deprecated("parents", "4.0.0")
    def parentGenerator(self) -> Iterator[PageElement]:
        ":meta private:"
        ...
    


class NavigableString(str, PageElement):
    """A Python string that is part of a parse tree.

    When Beautiful Soup parses the markup ``<b>penguin</b>``, it will
    create a `NavigableString` for the string "penguin".
    """
    PREFIX: str = ...
    SUFFIX: str = ...
    def __new__(cls, value: Union[str, bytes]) -> Self:
        """Create a new NavigableString.

        When unpickling a NavigableString, this method is called with
        the string in DEFAULT_OUTPUT_ENCODING. That encoding needs to be
        passed in to the superclass's __new__ or the superclass won't know
        how to handle non-ASCII characters.
        """
        ...
    
    def __deepcopy__(self, memo: Dict[Any, Any], recursive: bool = ...) -> Self:
        """A copy of a NavigableString has the same contents and class
        as the original, but it is not connected to the parse tree.

        :param recursive: This parameter is ignored; it's only defined
           so that NavigableString.__deepcopy__ implements the same
           signature as Tag.__deepcopy__.
        """
        ...
    
    def __getnewargs__(self) -> Tuple[str]:
        ...
    
    def __getitem__(self, key: Union[int | slice]) -> str:
        """Raise an exception """
        ...
    
    @property
    def string(self) -> str:
        """Convenience property defined to match `Tag.string`.

        :return: This property always returns the `NavigableString` it was
           called on.

        :meta private:
        """
        ...
    
    def output_ready(self, formatter: _FormatterOrName = ...) -> str:
        """Run the string through the provided formatter, making it
        ready for output as part of an HTML or XML document.

        :param formatter: A `Formatter` object, or a string naming one
            of the standard formatters.
        """
        ...
    
    @property
    def name(self) -> None:
        """Since a NavigableString is not a Tag, it has no .name.

        This property is implemented so that code like this doesn't crash
        when run on a mixture of Tag and NavigableString objects:
            [x.name for x in tag.children]

        :meta private:
        """
        ...
    
    @name.setter
    def name(self, name: str) -> None:
        """Prevent NavigableString.name from ever being set.

        :meta private:
        """
        ...
    
    @property
    def strings(self) -> Iterator[str]:
        """Yield this string, but only if it is interesting.

        This is defined the way it is for compatibility with
        `Tag.strings`. See `Tag` for information on which strings are
        interesting in a given context.

        :yield: A sequence that either contains this string, or is empty.
        """
        ...
    


class PreformattedString(NavigableString):
    """A `NavigableString` not subject to the normal formatting rules.

    This is an abstract class used for special kinds of strings such
    as comments (`Comment`) and CDATA blocks (`CData`).
    """
    PREFIX: str = ...
    SUFFIX: str = ...
    def output_ready(self, formatter: Optional[_FormatterOrName] = ...) -> str:
        """Make this string ready for output by adding any subclass-specific
            prefix or suffix.

        :param formatter: A `Formatter` object, or a string naming one
            of the standard formatters. The string will be passed into the
            `Formatter`, but only to trigger any side effects: the return
            value is ignored.

        :return: The string, with any subclass-specific prefix and
           suffix added on.
        """
        ...
    


class CData(PreformattedString):
    """A `CDATA section <https://dev.w3.org/html5/spec-LC/syntax.html#cdata-sections>`_."""
    PREFIX: str = ...
    SUFFIX: str = ...


class ProcessingInstruction(PreformattedString):
    """A SGML processing instruction."""
    PREFIX: str = ...
    SUFFIX: str = ...


class XMLProcessingInstruction(ProcessingInstruction):
    """An `XML processing instruction <https://www.w3.org/TR/REC-xml/#sec-pi>`_."""
    PREFIX: str = ...
    SUFFIX: str = ...


class Comment(PreformattedString):
    """An `HTML comment <https://dev.w3.org/html5/spec-LC/syntax.html#comments>`_ or `XML comment <https://www.w3.org/TR/REC-xml/#sec-comments>`_."""
    PREFIX: str = ...
    SUFFIX: str = ...


class Declaration(PreformattedString):
    """An `XML declaration <https://www.w3.org/TR/REC-xml/#sec-prolog-dtd>`_."""
    PREFIX: str = ...
    SUFFIX: str = ...


class Doctype(PreformattedString):
    """A `document type declaration <https://www.w3.org/TR/REC-xml/#dt-doctype>`_."""
    @classmethod
    def for_name_and_ids(cls, name: str, pub_id: Optional[str], system_id: Optional[str]) -> Doctype:
        """Generate an appropriate document type declaration for a given
        public ID and system ID.

        :param name: The name of the document's root element, e.g. 'html'.
        :param pub_id: The Formal Public Identifier for this document type,
            e.g. '-//W3C//DTD XHTML 1.1//EN'
        :param system_id: The system identifier for this document type,
            e.g. 'http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd'
        """
        ...
    
    PREFIX: str = ...
    SUFFIX: str = ...


class Stylesheet(NavigableString):
    """A `NavigableString` representing the contents of a `<style> HTML
    tag <https://dev.w3.org/html5/spec-LC/Overview.html#the-style-element>`_
    (probably CSS).

    Used to distinguish embedded stylesheets from textual content.
    """
    ...


class Script(NavigableString):
    """A `NavigableString` representing the contents of a `<script>
    HTML tag
    <https://dev.w3.org/html5/spec-LC/Overview.html#the-script-element>`_
    (probably Javascript).

    Used to distinguish executable code from textual content.
    """
    ...


class TemplateString(NavigableString):
    """A `NavigableString` representing a string found inside an `HTML
    <template> tag <https://html.spec.whatwg.org/multipage/scripting.html#the-template-element>`_
    embedded in a larger document.

    Used to distinguish such strings from the main body of the document.
    """
    ...


class RubyTextString(NavigableString):
    """A NavigableString representing the contents of an `<rt> HTML
    tag <https://dev.w3.org/html5/spec-LC/text-level-semantics.html#the-rt-element>`_.

    Can be used to distinguish such strings from the strings they're
    annotating.
    """
    ...


class RubyParenthesisString(NavigableString):
    """A NavigableString representing the contents of an `<rp> HTML
    tag <https://dev.w3.org/html5/spec-LC/text-level-semantics.html#the-rp-element>`_.
    """
    ...


class Tag(PageElement):
    """An HTML or XML tag that is part of a parse tree, along with its
    attributes, contents, and relationships to other parts of the tree.

    When Beautiful Soup parses the markup ``<b>penguin</b>``, it will
    create a `Tag` object representing the ``<b>`` tag. You can
    instantiate `Tag` objects directly, but it's not necessary unless
    you're adding entirely new markup to a parsed document. Most of
    the constructor arguments are intended for use by the `TreeBuilder`
    that's parsing a document.

    :param parser: A `BeautifulSoup` object representing the parse tree this
        `Tag` will be part of.
    :param builder: The `TreeBuilder` being used to build the tree.
    :param name: The name of the tag.
    :param namespace: The URI of this tag's XML namespace, if any.
    :param prefix: The prefix for this tag's XML namespace, if any.
    :param attrs: A dictionary of attribute values.
    :param parent: The `Tag` to use as the parent of this `Tag`. May be
       the `BeautifulSoup` object itself.
    :param previous: The `PageElement` that was parsed immediately before
        parsing this tag.
    :param is_xml: If True, this is an XML tag. Otherwise, this is an
        HTML tag.
    :param sourceline: The line number where this tag was found in its
        source document.
    :param sourcepos: The character position within ``sourceline`` where this
        tag was found.
    :param can_be_empty_element: If True, this tag should be
        represented as <tag/>. If False, this tag should be represented
        as <tag></tag>.
    :param cdata_list_attributes: A dictionary of attributes whose values should
        be parsed as lists of strings if they ever show up on this tag.
    :param preserve_whitespace_tags: Names of tags whose contents
        should have their whitespace preserved if they are encountered inside
        this tag.
    :param interesting_string_types: When iterating over this tag's
        string contents in methods like `Tag.strings` or
        `PageElement.get_text`, these are the types of strings that are
        interesting enough to be considered. By default,
        `NavigableString` (normal strings) and `CData` (CDATA
        sections) are the only interesting string subtypes.
    :param namespaces: A dictionary mapping currently active
        namespace prefixes to URIs, as of the point in the parsing process when
        this tag was encountered. This can be used later to
        construct CSS selectors.

    """
    def __init__(self, parser: Optional[BeautifulSoup] = ..., builder: Optional[TreeBuilder] = ..., name: Optional[str] = ..., namespace: Optional[str] = ..., prefix: Optional[str] = ..., attrs: Optional[_RawOrProcessedAttributeValues] = ..., parent: Optional[Union[BeautifulSoup, Tag]] = ..., previous: _AtMostOneElement = ..., is_xml: Optional[bool] = ..., sourceline: Optional[int] = ..., sourcepos: Optional[int] = ..., can_be_empty_element: Optional[bool] = ..., cdata_list_attributes: Optional[Dict[str, Set[str]]] = ..., preserve_whitespace_tags: Optional[Set[str]] = ..., interesting_string_types: Optional[Set[Type[NavigableString]]] = ..., namespaces: Optional[Dict[str, str]] = ...) -> None:
        ...
    
    parser_class: Optional[type[BeautifulSoup]]
    name: str
    namespace: Optional[str]
    prefix: Optional[str]
    attrs: _AttributeValues
    sourceline: Optional[int]
    sourcepos: Optional[int]
    known_xml: Optional[bool]
    contents: List[PageElement]
    hidden: bool
    interesting_string_types: Optional[Set[Type[NavigableString]]]
    can_be_empty_element: Optional[bool]
    cdata_list_attributes: Optional[Dict[str, Set[str]]]
    preserve_whitespace_tags: Optional[Set[str]]
    parserClass = ...
    def __deepcopy__(self, memo: Dict[Any, Any], recursive: bool = ...) -> Self:
        """A deepcopy of a Tag is a new Tag, unconnected to the parse tree.
        Its contents are a copy of the old Tag's contents.
        """
        ...
    
    def copy_self(self) -> Self:
        """Create a new Tag just like this one, but with no
        contents and unattached to any parse tree.

        This is the first step in the deepcopy process, but you can
        call it on its own to create a copy of a Tag without copying its
        contents.
        """
        ...
    
    @property
    def is_empty_element(self) -> bool:
        """Is this tag an empty-element tag? (aka a self-closing tag)

        A tag that has contents is never an empty-element tag.

        A tag that has no contents may or may not be an empty-element
        tag. It depends on the `TreeBuilder` used to create the
        tag. If the builder has a designated list of empty-element
        tags, then only a tag whose name shows up in that list is
        considered an empty-element tag. This is usually the case
        for HTML documents.

        If the builder has no designated list of empty-element, then
        any tag with no contents is an empty-element tag. This is usually
        the case for XML documents.
        """
        ...
    
    @_deprecated("is_empty_element", "4.0.0")
    def isSelfClosing(self) -> bool:
        ": :meta private:"
        ...
    
    @property
    def string(self) -> Optional[str]:
        """Convenience property to get the single string within this
        `Tag`, assuming there is just one.

        :return: If this `Tag` has a single child that's a
         `NavigableString`, the return value is that string. If this
         element has one child `Tag`, the return value is that child's
         `Tag.string`, recursively. If this `Tag` has no children,
         or has more than one child, the return value is ``None``.

         If this property is unexpectedly returning ``None`` for you,
         it's probably because your `Tag` has more than one thing
         inside it.
        """
        ...
    
    @string.setter
    def string(self, string: str) -> None:
        """Replace the `Tag.contents` of this `Tag` with a single string."""
        ...
    
    MAIN_CONTENT_STRING_TYPES = ...
    strings = ...
    def insert(self, position: int, *new_children: _InsertableElement) -> List[PageElement]:
        """Insert one or more new PageElements as a child of this `Tag`.

        This works similarly to :py:meth:`list.insert`, except you can insert
        multiple elements at once.

        :param position: The numeric position that should be occupied
           in this Tag's `Tag.children` by the first new `PageElement`.

        :param new_children: The PageElements to insert.

        :return The newly inserted PageElements.
        """
        ...
    
    def unwrap(self) -> Self:
        """Replace this `PageElement` with its contents.

        :return: This object, no longer part of the tree.
        """
        ...
    
    replace_with_children = ...
    @_deprecated("unwrap", "4.0.0")
    def replaceWithChildren(self) -> _OneElement:
        ": :meta private:"
        ...
    
    def append(self, tag: _InsertableElement) -> PageElement:
        """
        Appends the given `PageElement` to the contents of this `Tag`.

        :param tag: A PageElement.

        :return The newly appended PageElement.
        """
        ...
    
    def extend(self, tags: Union[Iterable[_InsertableElement], Tag]) -> List[PageElement]:
        """Appends one or more objects to the contents of this
        `Tag`.

        :param tags: If a list of `PageElement` objects is provided,
            they will be appended to this tag's contents, one at a time.
            If a single `Tag` is provided, its `Tag.contents` will be
            used to extend this object's `Tag.contents`.

        :return The list of PageElements that were appended.
        """
        ...
    
    def clear(self, decompose: bool = ...) -> None:
        """Destroy all children of this `Tag` by calling
           `PageElement.extract` on them.

        :param decompose: If this is True, `PageElement.decompose` (a
            more destructive method) will be called instead of
            `PageElement.extract`.
        """
        ...
    
    def smooth(self) -> None:
        """Smooth out the children of this `Tag` by consolidating consecutive
        strings.

        If you perform a lot of operations that modify the tree,
        calling this method afterwards can make pretty-printed output
        look more natural.
        """
        ...
    
    def index(self, element: PageElement) -> int:
        """Find the index of a child of this `Tag` (by identity, not value).

        Doing this by identity avoids issues when a `Tag` contains two
        children that have string equality.

        :param element: Look for this `PageElement` in this object's contents.
        """
        ...
    
    def get(self, key: str, default: Optional[_AttributeValue] = ...) -> Optional[_AttributeValue]:
        """Returns the value of the 'key' attribute for the tag, or
        the value given for 'default' if it doesn't have that
        attribute.

        :param key: The attribute to look for.
        :param default: Use this value if the attribute is not present
            on this `Tag`.
        """
        ...
    
    def get_attribute_list(self, key: str, default: Optional[AttributeValueList] = ...) -> AttributeValueList:
        """The same as get(), but always returns a (possibly empty) list.

        :param key: The attribute to look for.
        :param default: Use this value if the attribute is not present
            on this `Tag`.
        :return: A list of strings, usually empty or containing only a single
            value.
        """
        ...
    
    def has_attr(self, key: str) -> bool:
        """Does this `Tag` have an attribute with the given name?"""
        ...
    
    def __hash__(self) -> int:
        ...
    
    def __getitem__(self, key: str) -> _AttributeValue:
        """tag[key] returns the value of the 'key' attribute for the Tag,
        and throws an exception if it's not there."""
        ...
    
    def __iter__(self) -> Iterator[PageElement]:
        "Iterating over a Tag iterates over its contents."
        ...
    
    def __len__(self) -> int:
        "The length of a Tag is the length of its list of contents."
        ...
    
    def __contains__(self, x: Any) -> bool:
        ...
    
    def __bool__(self) -> bool:
        "A tag is non-None even if it has no contents."
        ...
    
    def __setitem__(self, key: str, value: _AttributeValue) -> None:
        """Setting tag[key] sets the value of the 'key' attribute for the
        tag."""
        ...
    
    def __delitem__(self, key: str) -> None:
        "Deleting tag[key] deletes all 'key' attributes for the tag."
        ...
    
    @overload
    def __call__(self, name: _FindMethodName = ..., attrs: Optional[_StrainableAttributes] = ..., recursive: bool = ..., string: None = ..., limit: Optional[int] = ..., _stacklevel: int = ..., **kwargs: _StrainableAttribute) -> _SomeTags:
        ...
    
    @overload
    def __call__(self, name: None = ..., attrs: None = ..., recursive: bool = ..., string: _StrainableString = ..., limit: Optional[int] = ..., _stacklevel: int = ..., **kwargs: _StrainableAttribute) -> _SomeNavigableStrings:
        ...
    
    def __call__(self, name: _FindMethodName = ..., attrs: Optional[_StrainableAttributes] = ..., recursive: bool = ..., string: Optional[_StrainableString] = ..., limit: Optional[int] = ..., _stacklevel: int = ..., **kwargs: _StrainableAttribute) -> Union[_SomeTags, _SomeNavigableStrings, _QueryResults]:
        """Calling a Tag like a function is the same as calling its
        find_all() method. Eg. tag('a') returns a list of all the A tags
        found within this tag."""
        ...
    
    def __getattr__(self, subtag: str) -> Optional[Tag]:
        """Calling tag.subtag is the same as calling tag.find(name="subtag")"""
        ...
    
    def __eq__(self, other: Any) -> bool:
        """Returns true iff this Tag has the same name, the same attributes,
        and the same contents (recursively) as `other`."""
        ...
    
    def __ne__(self, other: Any) -> bool:
        """Returns true iff this Tag is not identical to `other`,
        as defined in __eq__."""
        ...
    
    def __repr__(self) -> str:
        """Renders this `Tag` as a string."""
        ...
    
    __unicode__ = ...
    def encode(self, encoding: _Encoding = ..., indent_level: Optional[int] = ..., formatter: _FormatterOrName = ..., errors: str = ...) -> bytes:
        """Render this `Tag` and its contents as a bytestring.

        :param encoding: The encoding to use when converting to
           a bytestring. This may also affect the text of the document,
           specifically any encoding declarations within the document.
        :param indent_level: Each line of the rendering will be
           indented this many levels. (The ``formatter`` decides what a
           'level' means, in terms of spaces or other characters
           output.) This is used internally in recursive calls while
           pretty-printing.
        :param formatter: Either a `Formatter` object, or a string naming one of
            the standard formatters.
        :param errors: An error handling strategy such as
            'xmlcharrefreplace'. This value is passed along into
            :py:meth:`str.encode` and its value should be one of the `error
            handling constants defined by Python's codecs module
            <https://docs.python.org/3/library/codecs.html#error-handlers>`_.
        """
        ...
    
    def decode(self, indent_level: Optional[int] = ..., eventual_encoding: _Encoding = ..., formatter: _FormatterOrName = ..., iterator: Optional[Iterator[PageElement]] = ...) -> str:
        """Render this `Tag` and its contents as a Unicode string.

        :param indent_level: Each line of the rendering will be
           indented this many levels. (The ``formatter`` decides what a
           'level' means, in terms of spaces or other characters
           output.) This is used internally in recursive calls while
           pretty-printing.
        :param encoding: The encoding you intend to use when
           converting the string to a bytestring. decode() is *not*
           responsible for performing that encoding. This information
           is needed so that a real encoding can be substituted in if
           the document contains an encoding declaration (e.g. in a
           <meta> tag).
        :param formatter: Either a `Formatter` object, or a string
            naming one of the standard formatters.
        :param iterator: The iterator to use when navigating over the
            parse tree. This is only used by `Tag.decode_contents` and
            you probably won't need to use it.
        """
        ...
    
    class _TreeTraversalEvent:
        """An internal class representing an event in the process
        of traversing a parse tree.

        :meta private:
        """
        ...
    
    
    START_ELEMENT_EVENT = ...
    END_ELEMENT_EVENT = ...
    EMPTY_ELEMENT_EVENT = ...
    STRING_ELEMENT_EVENT = ...
    @overload
    def prettify(self, encoding: None = ..., formatter: _FormatterOrName = ...) -> str:
        ...
    
    @overload
    def prettify(self, encoding: _Encoding, formatter: _FormatterOrName = ...) -> bytes:
        ...
    
    def prettify(self, encoding: Optional[_Encoding] = ..., formatter: _FormatterOrName = ...) -> Union[str, bytes]:
        """Pretty-print this `Tag` as a string or bytestring.

        :param encoding: The encoding of the bytestring, or None if you want Unicode.
        :param formatter: A Formatter object, or a string naming one of
            the standard formatters.
        :return: A string (if no ``encoding`` is provided) or a bytestring
            (otherwise).
        """
        ...
    
    def decode_contents(self, indent_level: Optional[int] = ..., eventual_encoding: _Encoding = ..., formatter: _FormatterOrName = ...) -> str:
        """Renders the contents of this tag as a Unicode string.

        :param indent_level: Each line of the rendering will be
           indented this many levels. (The formatter decides what a
           'level' means in terms of spaces or other characters
           output.) Used internally in recursive calls while
           pretty-printing.

        :param eventual_encoding: The tag is destined to be
           encoded into this encoding. decode_contents() is *not*
           responsible for performing that encoding. This information
           is needed so that a real encoding can be substituted in if
           the document contains an encoding declaration (e.g. in a
           <meta> tag).

        :param formatter: A `Formatter` object, or a string naming one of
            the standard Formatters.
        """
        ...
    
    def encode_contents(self, indent_level: Optional[int] = ..., encoding: _Encoding = ..., formatter: _FormatterOrName = ...) -> bytes:
        """Renders the contents of this PageElement as a bytestring.

        :param indent_level: Each line of the rendering will be
           indented this many levels. (The ``formatter`` decides what a
           'level' means, in terms of spaces or other characters
           output.) This is used internally in recursive calls while
           pretty-printing.
        :param formatter: Either a `Formatter` object, or a string naming one of
            the standard formatters.
        :param encoding: The bytestring will be in this encoding.
        """
        ...
    
    @_deprecated("encode_contents", "4.0.0")
    def renderContents(self, encoding: _Encoding = ..., prettyPrint: bool = ..., indentLevel: Optional[int] = ...) -> bytes:
        """Deprecated method for BS3 compatibility.

        :meta private:
        """
        ...
    
    @overload
    def find(self, name: _FindMethodName = ..., attrs: Optional[_StrainableAttributes] = ..., recursive: bool = ..., string: None = ..., **kwargs: _StrainableAttribute) -> _AtMostOneTag:
        ...
    
    @overload
    def find(self, name: None = ..., attrs: None = ..., recursive: bool = ..., string: _StrainableString = ...) -> _AtMostOneNavigableString:
        ...
    
    def find(self, name: _FindMethodName = ..., attrs: Optional[_StrainableAttributes] = ..., recursive: bool = ..., string: Optional[_StrainableString] = ..., **kwargs: _StrainableAttribute) -> Union[_AtMostOneTag, _AtMostOneNavigableString, _AtMostOneElement]:
        """Look in the children of this PageElement and find the first
        PageElement that matches the given criteria.

        All find_* methods take a common set of arguments. See the online
        documentation for detailed explanations.

        :param name: A filter on tag name.
        :param attrs: Additional filters on attribute values.
        :param recursive: If this is True, find() will perform a
            recursive search of this Tag's children. Otherwise,
            only the direct children will be considered.
        :param string: A filter on the `Tag.string` attribute.
        :kwargs: Additional filters on attribute values.
        """
        ...
    
    findChild = ...
    @overload
    def find_all(self, name: _FindMethodName = ..., attrs: Optional[_StrainableAttributes] = ..., recursive: bool = ..., string: None = ..., limit: Optional[int] = ..., _stacklevel: int = ..., **kwargs: _StrainableAttribute) -> _SomeTags:
        ...
    
    @overload
    def find_all(self, name: None = ..., attrs: None = ..., recursive: bool = ..., string: _StrainableString = ..., limit: Optional[int] = ..., _stacklevel: int = ..., **kwargs: _StrainableAttribute) -> _SomeNavigableStrings:
        ...
    
    def find_all(self, name: _FindMethodName = ..., attrs: Optional[_StrainableAttributes] = ..., recursive: bool = ..., string: Optional[_StrainableString] = ..., limit: Optional[int] = ..., _stacklevel: int = ..., **kwargs: _StrainableAttribute) -> Union[_SomeTags, _SomeNavigableStrings, _QueryResults]:
        """Look in the children of this `PageElement` and find all
        `PageElement` objects that match the given criteria.

        All find_* methods take a common set of arguments. See the online
        documentation for detailed explanations.

        :param name: A filter on tag name.
        :param attrs: Additional filters on attribute values.
        :param recursive: If this is True, find_all() will perform a
            recursive search of this PageElement's children. Otherwise,
            only the direct children will be considered.
        :param limit: Stop looking after finding this many results.
        :param _stacklevel: Used internally to improve warning messages.
        :kwargs: Additional filters on attribute values.
        """
        ...
    
    findAll = ...
    findChildren = ...
    @property
    def children(self) -> Iterator[PageElement]:
        """Iterate over all direct children of this `PageElement`."""
        ...
    
    @property
    def self_and_descendants(self) -> Iterator[PageElement]:
        """Iterate over this `Tag` and its children in a
        breadth-first sequence.
        """
        ...
    
    @property
    def descendants(self) -> Iterator[PageElement]:
        """Iterate over all children of this `Tag` in a
        breadth-first sequence.
        """
        ...
    
    def select_one(self, selector: str, namespaces: Optional[Dict[str, str]] = ..., **kwargs: Any) -> Optional[Tag]:
        """Perform a CSS selection operation on the current element.

        :param selector: A CSS selector.

        :param namespaces: A dictionary mapping namespace prefixes
           used in the CSS selector to namespace URIs. By default,
           Beautiful Soup will use the prefixes it encountered while
           parsing the document.

        :param kwargs: Keyword arguments to be passed into Soup Sieve's
           soupsieve.select() method.
        """
        ...
    
    def select(self, selector: str, namespaces: Optional[Dict[str, str]] = ..., limit: int = ..., **kwargs: Any) -> ResultSet[Tag]:
        """Perform a CSS selection operation on the current element.

        This uses the SoupSieve library.

        :param selector: A string containing a CSS selector.

        :param namespaces: A dictionary mapping namespace prefixes
           used in the CSS selector to namespace URIs. By default,
           Beautiful Soup will use the prefixes it encountered while
           parsing the document.

        :param limit: After finding this number of results, stop looking.

        :param kwargs: Keyword arguments to be passed into SoupSieve's
           soupsieve.select() method.
        """
        ...
    
    @property
    def css(self) -> CSS:
        """Return an interface to the CSS selector API."""
        ...
    
    @_deprecated("children", "4.0.0")
    def childGenerator(self) -> Iterator[PageElement]:
        """Deprecated generator.

        :meta private:
        """
        ...
    
    @_deprecated("descendants", "4.0.0")
    def recursiveChildGenerator(self) -> Iterator[PageElement]:
        """Deprecated generator.

        :meta private:
        """
        ...
    
    @_deprecated("has_attr", "4.0.0")
    def has_key(self, key: str) -> bool:
        """Deprecated method. This was kind of misleading because has_key()
        (attributes) was different from __in__ (contents).

        has_key() is gone in Python 3, anyway.

        :meta private:
        """
        ...
    


_PageElementT = TypeVar("_PageElementT", bound=PageElement)
class ResultSet(List[_PageElementT], Generic[_PageElementT]):
    """A ResultSet is a list of `PageElement` objects, gathered as the result
    of matching an :py:class:`ElementFilter` against a parse tree. Basically, a list of
    search results.
    """
    source: Optional[ElementFilter]
    def __init__(self, source: Optional[ElementFilter], result: Iterable[_PageElementT] = ...) -> None:
        ...
    
    def __getattr__(self, key: str) -> None:
        """Raise a helpful exception to explain a common code fix."""
        ...
    


