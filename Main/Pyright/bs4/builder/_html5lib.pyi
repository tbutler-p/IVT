"""
This type stub file was generated by pyright.
"""

import html5lib
from typing import Any, Dict, Iterable, Optional, TYPE_CHECKING, Tuple, Union
from typing_extensions import TypeAlias
from bs4._typing import _AttributeValue, _AttributeValues, _Encoding, _Encodings, _NamespaceURL, _RawMarkup
from bs4.builder import HTMLTreeBuilder
from bs4.element import NavigableString, PageElement, Tag
from bs4 import BeautifulSoup
from html5lib.treebuilders import base as treebuilder_base

__license__ = ...
__all__ = ["HTML5TreeBuilder"]
if TYPE_CHECKING:
    ...
class HTML5TreeBuilder(HTMLTreeBuilder):
    """Use `html5lib <https://github.com/html5lib/html5lib-python>`_ to
    build a tree.

    Note that `HTML5TreeBuilder` does not support some common HTML
    `TreeBuilder` features. Some of these features could theoretically
    be implemented, but at the very least it's quite difficult,
    because html5lib moves the parse tree around as it's being built.

    Specifically:

    * This `TreeBuilder` doesn't use different subclasses of
      `NavigableString` (e.g. `Script`) based on the name of the tag
      in which the string was found.
    * You can't use a `SoupStrainer` to parse only part of a document.
    """
    NAME: str = ...
    features: Iterable[str] = ...
    TRACKS_LINE_NUMBERS: bool = ...
    underlying_builder: TreeBuilderForHtml5lib
    user_specified_encoding: Optional[_Encoding]
    def prepare_markup(self, markup: _RawMarkup, user_specified_encoding: Optional[_Encoding] = ..., document_declared_encoding: Optional[_Encoding] = ..., exclude_encodings: Optional[_Encodings] = ...) -> Iterable[Tuple[_RawMarkup, Optional[_Encoding], Optional[_Encoding], bool]]:
        ...
    
    def feed(self, markup: _RawMarkup) -> None:
        """Run some incoming markup through some parsing process,
        populating the `BeautifulSoup` object in `HTML5TreeBuilder.soup`.
        """
        ...
    
    def create_treebuilder(self, namespaceHTMLElements: bool) -> TreeBuilderForHtml5lib:
        """Called by html5lib to instantiate the kind of class it
        calls a 'TreeBuilder'.

        :param namespaceHTMLElements: Whether or not to namespace HTML elements.

        :meta private:
        """
        ...
    
    def test_fragment_to_document(self, fragment: str) -> str:
        """See `TreeBuilder`."""
        ...
    


class TreeBuilderForHtml5lib(treebuilder_base.TreeBuilder):
    soup: BeautifulSoup
    parser: Optional[html5lib.HTMLParser]
    def __init__(self, namespaceHTMLElements: bool, soup: Optional[BeautifulSoup] = ..., store_line_numbers: bool = ..., **kwargs: Any) -> None:
        ...
    
    def documentClass(self) -> Element:
        ...
    
    def insertDoctype(self, token: Dict[str, Any]) -> None:
        ...
    
    def elementClass(self, name: str, namespace: str) -> Element:
        ...
    
    def commentClass(self, data: str) -> TextNode:
        ...
    
    def fragmentClass(self) -> Element:
        """This is only used by html5lib HTMLParser.parseFragment(),
        which is never used by Beautiful Soup, only by the html5lib
        unit tests. Since we don't currently hook into those tests,
        the implementation is left blank.
        """
        ...
    
    def getFragment(self) -> Element:
        """This is only used by the html5lib unit tests. Since we
        don't currently hook into those tests, the implementation is
        left blank.
        """
        ...
    
    def appendChild(self, node: Element) -> None:
        ...
    
    def getDocument(self) -> BeautifulSoup:
        ...
    
    def testSerializer(self, node: Element) -> None:
        """This is only used by the html5lib unit tests. Since we
        don't currently hook into those tests, the implementation is
        left blank.
        """
        ...
    


class AttrList:
    """Represents a Tag's attributes in a way compatible with html5lib."""
    element: Tag
    attrs: _AttributeValues
    def __init__(self, element: Tag) -> None:
        ...
    
    def __iter__(self) -> Iterable[Tuple[str, _AttributeValue]]:
        ...
    
    def __setitem__(self, name: str, value: _AttributeValue) -> None:
        ...
    
    def items(self) -> Iterable[Tuple[str, _AttributeValue]]:
        ...
    
    def keys(self) -> Iterable[str]:
        ...
    
    def __len__(self) -> int:
        ...
    
    def __getitem__(self, name: str) -> _AttributeValue:
        ...
    
    def __contains__(self, name: str) -> bool:
        ...
    


class BeautifulSoupNode(treebuilder_base.Node):
    tag: Optional[Tag]
    string: Optional[NavigableString]
    soup: BeautifulSoup
    namespace: Optional[_NamespaceURL]
    @property
    def element(self) -> PageElement:
        ...
    
    @property
    def nodeType(self) -> int:
        """Return the html5lib constant corresponding to the type of
        the underlying DOM object.

        NOTE: This property is only accessed by the html5lib test
        suite, not by Beautiful Soup proper.
        """
        ...
    
    def cloneNode(self) -> treebuilder_base.Node:
        ...
    


class Element(BeautifulSoupNode):
    namespace: Optional[_NamespaceURL]
    def __init__(self, element: Tag, soup: BeautifulSoup, namespace: Optional[_NamespaceURL]) -> None:
        ...
    
    def appendChild(self, node: BeautifulSoupNode) -> None:
        ...
    
    def getAttributes(self) -> AttrList:
        ...
    
    _Html5libAttributeName: TypeAlias = Union[str, Tuple[str, str]]
    _Html5libAttributes: TypeAlias = Dict[_Html5libAttributeName, str]
    def setAttributes(self, attributes: Optional[_Html5libAttributes]) -> None:
        ...
    
    attributes = property(getAttributes, setAttributes)
    def insertText(self, data: str, insertBefore: Optional[BeautifulSoupNode] = ...) -> None:
        ...
    
    def insertBefore(self, node: BeautifulSoupNode, refNode: BeautifulSoupNode) -> None:
        ...
    
    def removeChild(self, node: Element) -> None:
        ...
    
    def reparentChildren(self, newParent: Element) -> None:
        """Move all of this tag's children into another tag."""
        ...
    
    def hasContent(self) -> bool:
        ...
    
    def cloneNode(self) -> treebuilder_base.Node:
        ...
    
    def getNameTuple(self) -> Tuple[Optional[_NamespaceURL], str]:
        ...
    
    nameTuple = ...


class TextNode(BeautifulSoupNode):
    def __init__(self, element: NavigableString, soup: BeautifulSoup) -> None:
        ...
    


