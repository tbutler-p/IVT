"""
This type stub file was generated by pyright.
"""

import re
import warnings
import sys
from collections import defaultdict
from types import ModuleType
from typing import Any, Dict, Iterable, List, Optional, Pattern, Set, TYPE_CHECKING, Tuple, Type, cast
from bs4.element import AttributeDict, AttributeValueList, CharsetMetaAttributeValue, ContentMetaAttributeValue, NavigableString, RubyParenthesisString, RubyTextString, Script, Stylesheet, Tag, TemplateString, nonwhitespace_re
from bs4.exceptions import ParserRejectedMarkup
from bs4._typing import _AttributeValue, _AttributeValues, _Encoding, _Encodings, _RawAttributeValue, _RawMarkup, _RawOrProcessedAttributeValues
from bs4._warnings import XMLParsedAsHTMLWarning
from bs4 import BeautifulSoup
from . import _html5lib, _htmlparser, _lxml

__license__ = ...
if TYPE_CHECKING:
    ...
__all__ = ["HTMLTreeBuilder", "SAXTreeBuilder", "TreeBuilder", "TreeBuilderRegistry"]
FAST = ...
PERMISSIVE = ...
STRICT = ...
XML = ...
HTML = ...
HTML_5 = ...
__all__ = ["TreeBuilderRegistry", "TreeBuilder", "HTMLTreeBuilder", "DetectsXMLParsedAsHTML", "ParserRejectedMarkup"]
class TreeBuilderRegistry:
    """A way of looking up TreeBuilder subclasses by their name or by desired
    features.
    """
    builders_for_feature: Dict[str, List[Type[TreeBuilder]]]
    builders: List[Type[TreeBuilder]]
    def __init__(self) -> None:
        ...
    
    def register(self, treebuilder_class: type[TreeBuilder]) -> None:
        """Register a treebuilder based on its advertised features.

        :param treebuilder_class: A subclass of `TreeBuilder`. its
           `TreeBuilder.features` attribute should list its features.
        """
        ...
    
    def lookup(self, *features: str) -> Optional[Type[TreeBuilder]]:
        """Look up a TreeBuilder subclass with the desired features.

        :param features: A list of features to look for. If none are
            provided, the most recently registered TreeBuilder subclass
            will be used.
        :return: A TreeBuilder subclass, or None if there's no
            registered subclass with all the requested features.
        """
        ...
    


builder_registry: TreeBuilderRegistry = ...
class TreeBuilder:
    """Turn a textual document into a Beautiful Soup object tree.

    This is an abstract superclass which smooths out the behavior of
    different parser libraries into a single, unified interface.

    :param multi_valued_attributes: If this is set to None, the
     TreeBuilder will not turn any values for attributes like
     'class' into lists. Setting this to a dictionary will
     customize this behavior; look at :py:attr:`bs4.builder.HTMLTreeBuilder.DEFAULT_CDATA_LIST_ATTRIBUTES`
     for an example.

     Internally, these are called "CDATA list attributes", but that
     probably doesn't make sense to an end-user, so the argument name
     is ``multi_valued_attributes``.

    :param preserve_whitespace_tags: A set of tags to treat
     the way <pre> tags are treated in HTML. Tags in this set
     are immune from pretty-printing; their contents will always be
     output as-is.

    :param string_containers: A dictionary mapping tag names to
     the classes that should be instantiated to contain the textual
     contents of those tags. The default is to use NavigableString
     for every tag, no matter what the name. You can override the
     default by changing :py:attr:`DEFAULT_STRING_CONTAINERS`.

    :param store_line_numbers: If the parser keeps track of the line
     numbers and positions of the original markup, that information
     will, by default, be stored in each corresponding
     :py:class:`bs4.element.Tag` object. You can turn this off by
     passing store_line_numbers=False; then Tag.sourcepos and
     Tag.sourceline will always be None. If the parser you're using
     doesn't keep track of this information, then store_line_numbers
     is irrelevant.

    :param attribute_dict_class: The value of a multi-valued attribute
      (such as HTML's 'class') willl be stored in an instance of this
      class.  The default is Beautiful Soup's built-in
      `AttributeValueList`, which is a normal Python list, and you
      will probably never need to change it.
    """
    USE_DEFAULT: Any = ...
    def __init__(self, multi_valued_attributes: Dict[str, Set[str]] = ..., preserve_whitespace_tags: Set[str] = ..., store_line_numbers: bool = ..., string_containers: Dict[str, Type[NavigableString]] = ..., empty_element_tags: Set[str] = ..., attribute_dict_class: Type[AttributeDict] = ..., attribute_value_list_class: Type[AttributeValueList] = ...) -> None:
        ...
    
    NAME: str = ...
    ALTERNATE_NAMES: Iterable[str] = ...
    features: Iterable[str] = ...
    is_xml: bool = ...
    picklable: bool = ...
    soup: Optional[BeautifulSoup]
    empty_element_tags: Optional[Set[str]] = ...
    cdata_list_attributes: Dict[str, Set[str]]
    preserve_whitespace_tags: Set[str]
    string_containers: Dict[str, Type[NavigableString]]
    tracks_line_numbers: bool
    DEFAULT_CDATA_LIST_ATTRIBUTES: Dict[str, Set[str]] = ...
    DEFAULT_PRESERVE_WHITESPACE_TAGS: Set[str] = ...
    DEFAULT_STRING_CONTAINERS: Dict[str, Type[bs4.element.NavigableString]] = ...
    DEFAULT_EMPTY_ELEMENT_TAGS: Optional[Set[str]] = ...
    TRACKS_LINE_NUMBERS: bool = ...
    def initialize_soup(self, soup: BeautifulSoup) -> None:
        """The BeautifulSoup object has been initialized and is now
        being associated with the TreeBuilder.

        :param soup: A BeautifulSoup object.
        """
        ...
    
    def reset(self) -> None:
        """Do any work necessary to reset the underlying parser
        for a new document.

        By default, this does nothing.
        """
        ...
    
    def can_be_empty_element(self, tag_name: str) -> bool:
        """Might a tag with this name be an empty-element tag?

        The final markup may or may not actually present this tag as
        self-closing.

        For instance: an HTMLBuilder does not consider a <p> tag to be
        an empty-element tag (it's not in
        HTMLBuilder.empty_element_tags). This means an empty <p> tag
        will be presented as "<p></p>", not "<p/>" or "<p>".

        The default implementation has no opinion about which tags are
        empty-element tags, so a tag will be presented as an
        empty-element tag if and only if it has no children.
        "<foo></foo>" will become "<foo/>", and "<foo>bar</foo>" will
        be left alone.

        :param tag_name: The name of a markup tag.
        """
        ...
    
    def feed(self, markup: _RawMarkup) -> None:
        """Run incoming markup through some parsing process."""
        ...
    
    def prepare_markup(self, markup: _RawMarkup, user_specified_encoding: Optional[_Encoding] = ..., document_declared_encoding: Optional[_Encoding] = ..., exclude_encodings: Optional[_Encodings] = ...) -> Iterable[Tuple[_RawMarkup, Optional[_Encoding], Optional[_Encoding], bool]]:
        """Run any preliminary steps necessary to make incoming markup
        acceptable to the parser.

        :param markup: The markup that's about to be parsed.
        :param user_specified_encoding: The user asked to try this encoding
           to convert the markup into a Unicode string.
        :param document_declared_encoding: The markup itself claims to be
            in this encoding. NOTE: This argument is not used by the
            calling code and can probably be removed.
        :param exclude_encodings: The user asked *not* to try any of
            these encodings.

        :yield: A series of 4-tuples: (markup, encoding, declared encoding,
            has undergone character replacement)

            Each 4-tuple represents a strategy that the parser can try
            to convert the document to Unicode and parse it. Each
            strategy will be tried in turn.

         By default, the only strategy is to parse the markup
         as-is. See `LXMLTreeBuilderForXML` and
         `HTMLParserTreeBuilder` for implementations that take into
         account the quirks of particular parsers.

        :meta private:

        """
        ...
    
    def test_fragment_to_document(self, fragment: str) -> str:
        """Wrap an HTML fragment to make it look like a document.

        Different parsers do this differently. For instance, lxml
        introduces an empty <head> tag, and html5lib
        doesn't. Abstracting this away lets us write simple tests
        which run HTML fragments through the parser and compare the
        results against other HTML fragments.

        This method should not be used outside of unit tests.

        :param fragment: A fragment of HTML.
        :return: A full HTML document.
        :meta private:
        """
        ...
    
    def set_up_substitutions(self, tag: Tag) -> bool:
        """Set up any substitutions that will need to be performed on
        a `Tag` when it's output as a string.

        By default, this does nothing. See `HTMLTreeBuilder` for a
        case where this is used.

        :return: Whether or not a substitution was performed.
        :meta private:
        """
        ...
    


class SAXTreeBuilder(TreeBuilder):
    """A Beautiful Soup treebuilder that listens for SAX events.

    This is not currently used for anything, and it will be removed
    soon. It was a good idea, but it wasn't properly integrated into the
    rest of Beautiful Soup, so there have been long stretches where it
    hasn't worked properly.
    """
    def __init__(self, *args: Any, **kwargs: Any) -> None:
        ...
    
    def feed(self, markup: _RawMarkup) -> None:
        ...
    
    def close(self) -> None:
        ...
    
    def startElement(self, name: str, attrs: Dict[str, str]) -> None:
        ...
    
    def endElement(self, name: str) -> None:
        ...
    
    def startElementNS(self, nsTuple: Tuple[str, str], nodeName: str, attrs: Dict[str, str]) -> None:
        ...
    
    def endElementNS(self, nsTuple: Tuple[str, str], nodeName: str) -> None:
        ...
    
    def startPrefixMapping(self, prefix: str, nodeValue: str) -> None:
        ...
    
    def endPrefixMapping(self, prefix: str) -> None:
        ...
    
    def characters(self, content: str) -> None:
        ...
    
    def startDocument(self) -> None:
        ...
    
    def endDocument(self) -> None:
        ...
    


class HTMLTreeBuilder(TreeBuilder):
    """This TreeBuilder knows facts about HTML, such as which tags are treated
    specially by the HTML standard.
    """
    DEFAULT_EMPTY_ELEMENT_TAGS: Optional[Set[str]] = ...
    DEFAULT_BLOCK_ELEMENTS: Set[str] = ...
    DEFAULT_STRING_CONTAINERS: Dict[str, Type[bs4.element.NavigableString]] = ...
    DEFAULT_CDATA_LIST_ATTRIBUTES: Dict[str, Set[str]] = ...
    DEFAULT_PRESERVE_WHITESPACE_TAGS: set[str] = ...
    def set_up_substitutions(self, tag: Tag) -> bool:
        """Replace the declared encoding in a <meta> tag with a placeholder,
        to be substituted when the tag is output to a string.

        An HTML document may come in to Beautiful Soup as one
        encoding, but exit in a different encoding, and the <meta> tag
        needs to be changed to reflect this.

        :return: Whether or not a substitution was performed.

        :meta private:
        """
        ...
    


class DetectsXMLParsedAsHTML:
    """A mixin class for any class (a TreeBuilder, or some class used by a
    TreeBuilder) that's in a position to detect whether an XML
    document is being incorrectly parsed as HTML, and issue an
    appropriate warning.

    This requires being able to observe an incoming processing
    instruction that might be an XML declaration, and also able to
    observe tags as they're opened. If you can't do that for a given
    `TreeBuilder`, there's a less reliable implementation based on
    examining the raw markup.
    """
    LOOKS_LIKE_HTML: Pattern[str] = ...
    LOOKS_LIKE_HTML_B: Pattern[bytes] = ...
    XML_PREFIX: str = ...
    XML_PREFIX_B: bytes = ...
    _first_processing_instruction: Optional[str]
    _root_tag_name: Optional[str]
    @classmethod
    def warn_if_markup_looks_like_xml(cls, markup: Optional[_RawMarkup], stacklevel: int = ...) -> bool:
        """Perform a check on some markup to see if it looks like XML
        that's not XHTML. If so, issue a warning.

        This is much less reliable than doing the check while parsing,
        but some of the tree builders can't do that.

        :param stacklevel: The stacklevel of the code calling this\
         function.

        :return: True if the markup looks like non-XHTML XML, False
         otherwise.
        """
        ...
    


def register_treebuilders_from(module: ModuleType) -> None:
    """Copy TreeBuilders from the given module into this module."""
    ...

