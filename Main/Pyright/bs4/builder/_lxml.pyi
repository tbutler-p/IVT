"""
This type stub file was generated by pyright.
"""

from typing import Any, Dict, Iterable, List, Optional, Set, TYPE_CHECKING, Tuple, Type, Union
from typing_extensions import TypeAlias
from lxml import etree
from bs4.element import ProcessingInstruction
from bs4.builder import HTMLTreeBuilder, TreeBuilder
from bs4._typing import _Encoding, _Encodings, _InvertedNamespaceMapping, _NamespaceMapping, _RawMarkup
from bs4 import BeautifulSoup

__license__ = ...
__all__ = ["LXMLTreeBuilderForXML", "LXMLTreeBuilder"]
if TYPE_CHECKING:
    ...
LXML: str = ...
_LXMLParser: TypeAlias = Union[etree.XMLParser, etree.HTMLParser]
_ParserOrParserClass: TypeAlias = Union[_LXMLParser, Type[etree.XMLParser], Type[etree.HTMLParser]]
class LXMLTreeBuilderForXML(TreeBuilder):
    DEFAULT_PARSER_CLASS: Type[etree.XMLParser] = ...
    is_xml: bool = ...
    processing_instruction_class: Type[ProcessingInstruction]
    NAME: str = ...
    ALTERNATE_NAMES: Iterable[str] = ...
    features: Iterable[str] = ...
    CHUNK_SIZE: int = ...
    DEFAULT_NSMAPS: _NamespaceMapping = ...
    DEFAULT_NSMAPS_INVERTED: _InvertedNamespaceMapping = ...
    nsmaps: List[Optional[_InvertedNamespaceMapping]]
    empty_element_tags: Optional[Set[str]]
    parser: Any
    _default_parser: Optional[etree.XMLParser]
    def initialize_soup(self, soup: BeautifulSoup) -> None:
        """Let the BeautifulSoup object know about the standard namespace
        mapping.

        :param soup: A `BeautifulSoup`.
        """
        ...
    
    def default_parser(self, encoding: Optional[_Encoding]) -> _ParserOrParserClass:
        """Find the default parser for the given encoding.

        :return: Either a parser object or a class, which
          will be instantiated with default arguments.
        """
        ...
    
    def parser_for(self, encoding: Optional[_Encoding]) -> _LXMLParser:
        """Instantiate an appropriate parser for the given encoding.

        :param encoding: A string.
        :return: A parser object such as an `etree.XMLParser`.
        """
        ...
    
    def __init__(self, parser: Optional[etree.XMLParser] = ..., empty_element_tags: Optional[Set[str]] = ..., **kwargs: Any) -> None:
        ...
    
    def prepare_markup(self, markup: _RawMarkup, user_specified_encoding: Optional[_Encoding] = ..., document_declared_encoding: Optional[_Encoding] = ..., exclude_encodings: Optional[_Encodings] = ...) -> Iterable[Tuple[Union[str, bytes], Optional[_Encoding], Optional[_Encoding], bool]]:
        """Run any preliminary steps necessary to make incoming markup
        acceptable to the parser.

        lxml really wants to get a bytestring and convert it to
        Unicode itself. So instead of using UnicodeDammit to convert
        the bytestring to Unicode using different encodings, this
        implementation uses EncodingDetector to iterate over the
        encodings, and tell lxml to try to parse the document as each
        one in turn.

        :param markup: Some markup -- hopefully a bytestring.
        :param user_specified_encoding: The user asked to try this encoding.
        :param document_declared_encoding: The markup itself claims to be
            in this encoding.
        :param exclude_encodings: The user asked _not_ to try any of
            these encodings.

        :yield: A series of 4-tuples: (markup, encoding, declared encoding,
            has undergone character replacement)

            Each 4-tuple represents a strategy for converting the
            document to Unicode and parsing it. Each strategy will be tried
            in turn.
        """
        ...
    
    def feed(self, markup: _RawMarkup) -> None:
        ...
    
    def close(self) -> None:
        ...
    
    def start(self, tag: str | bytes, attrib: Dict[str | bytes, str | bytes], nsmap: _NamespaceMapping = ...) -> None:
        ...
    
    def end(self, tag: str | bytes) -> None:
        ...
    
    def pi(self, target: str, data: str) -> None:
        ...
    
    def data(self, data: str | bytes) -> None:
        ...
    
    def doctype(self, name: str, pubid: str, system: str) -> None:
        ...
    
    def comment(self, text: str | bytes) -> None:
        "Handle comments as Comment objects."
        ...
    
    def test_fragment_to_document(self, fragment: str) -> str:
        """See `TreeBuilder`."""
        ...
    


class LXMLTreeBuilder(HTMLTreeBuilder, LXMLTreeBuilderForXML):
    NAME: str = ...
    ALTERNATE_NAMES: Iterable[str] = ...
    features: Iterable[str] = ...
    is_xml: bool = ...
    def default_parser(self, encoding: Optional[_Encoding]) -> _ParserOrParserClass:
        ...
    
    def feed(self, markup: _RawMarkup) -> None:
        ...
    
    def test_fragment_to_document(self, fragment: str) -> str:
        """See `TreeBuilder`."""
        ...
    


