"""
This type stub file was generated by pyright.
"""

from html.parser import HTMLParser
from typing import Any, Callable, Dict, Iterable, List, Optional, TYPE_CHECKING, Tuple, Union
from bs4.builder import DetectsXMLParsedAsHTML, HTMLTreeBuilder
from bs4 import BeautifulSoup
from bs4._typing import _Encoding, _Encodings, _RawMarkup

"""Use the HTMLParser library to parse HTML files that aren't too bad."""
__license__ = ...
__all__ = ["HTMLParserTreeBuilder"]
if TYPE_CHECKING:
    ...
HTMLPARSER = ...
_DuplicateAttributeHandler = Callable[[Dict[str, str], str, str], None]
class BeautifulSoupHTMLParser(HTMLParser, DetectsXMLParsedAsHTML):
    REPLACE: str = ...
    IGNORE: str = ...
    def __init__(self, soup: BeautifulSoup, *args: Any, on_duplicate_attribute: Union[str, _DuplicateAttributeHandler] = ..., **kwargs: Any) -> None:
        ...
    
    on_duplicate_attribute: Union[str, _DuplicateAttributeHandler]
    already_closed_empty_element: List[str]
    soup: BeautifulSoup
    def error(self, message: str) -> None:
        ...
    
    def handle_startendtag(self, tag: str, attrs: List[Tuple[str, Optional[str]]]) -> None:
        """Handle an incoming empty-element tag.

        html.parser only calls this method when the markup looks like
        <tag/>.
        """
        ...
    
    def handle_starttag(self, tag: str, attrs: List[Tuple[str, Optional[str]]], handle_empty_element: bool = ...) -> None:
        """Handle an opening tag, e.g. '<tag>'

        :param handle_empty_element: True if this tag is known to be
            an empty-element tag (i.e. there is not expected to be any
            closing tag).
        """
        ...
    
    def handle_endtag(self, tag: str, check_already_closed: bool = ...) -> None:
        """Handle a closing tag, e.g. '</tag>'

        :param tag: A tag name.
        :param check_already_closed: True if this tag is expected to
           be the closing portion of an empty-element tag,
           e.g. '<tag></tag>'.
        """
        ...
    
    def handle_data(self, data: str) -> None:
        """Handle some textual data that shows up between tags."""
        ...
    
    def handle_charref(self, name: str) -> None:
        """Handle a numeric character reference by converting it to the
        corresponding Unicode character and treating it as textual
        data.

        :param name: Character number, possibly in hexadecimal.
        """
        ...
    
    def handle_entityref(self, name: str) -> None:
        """Handle a named entity reference by converting it to the
        corresponding Unicode character(s) and treating it as textual
        data.

        :param name: Name of the entity reference.
        """
        ...
    
    def handle_comment(self, data: str) -> None:
        """Handle an HTML comment.

        :param data: The text of the comment.
        """
        ...
    
    def handle_decl(self, decl: str) -> None:
        """Handle a DOCTYPE declaration.

        :param data: The text of the declaration.
        """
        ...
    
    def unknown_decl(self, data: str) -> None:
        """Handle a declaration of unknown type -- probably a CDATA block.

        :param data: The text of the declaration.
        """
        ...
    
    def handle_pi(self, data: str) -> None:
        """Handle a processing instruction.

        :param data: The text of the instruction.
        """
        ...
    


class HTMLParserTreeBuilder(HTMLTreeBuilder):
    """A Beautiful soup `bs4.builder.TreeBuilder` that uses the
    :py:class:`html.parser.HTMLParser` parser, found in the Python
    standard library.

    """
    is_xml: bool = ...
    picklable: bool = ...
    NAME: str = ...
    features: Iterable[str] = ...
    parser_args: Tuple[Iterable[Any], Dict[str, Any]]
    TRACKS_LINE_NUMBERS: bool = ...
    def __init__(self, parser_args: Optional[Iterable[Any]] = ..., parser_kwargs: Optional[Dict[str, Any]] = ..., **kwargs: Any) -> None:
        """Constructor.

        :param parser_args: Positional arguments to pass into
            the BeautifulSoupHTMLParser constructor, once it's
            invoked.
        :param parser_kwargs: Keyword arguments to pass into
            the BeautifulSoupHTMLParser constructor, once it's
            invoked.
        :param kwargs: Keyword arguments for the superclass constructor.
        """
        ...
    
    def prepare_markup(self, markup: _RawMarkup, user_specified_encoding: Optional[_Encoding] = ..., document_declared_encoding: Optional[_Encoding] = ..., exclude_encodings: Optional[_Encodings] = ...) -> Iterable[Tuple[str, Optional[_Encoding], Optional[_Encoding], bool]]:
        """Run any preliminary steps necessary to make incoming markup
        acceptable to the parser.

        :param markup: Some markup -- probably a bytestring.
        :param user_specified_encoding: The user asked to try this encoding.
        :param document_declared_encoding: The markup itself claims to be
            in this encoding.
        :param exclude_encodings: The user asked _not_ to try any of
            these encodings.

        :yield: A series of 4-tuples: (markup, encoding, declared encoding,
             has undergone character replacement)

            Each 4-tuple represents a strategy for parsing the document.
            This TreeBuilder uses Unicode, Dammit to convert the markup
            into Unicode, so the ``markup`` element of the tuple will
            always be a string.
        """
        ...
    
    def feed(self, markup: _RawMarkup) -> None:
        ...
    


