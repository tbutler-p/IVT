"""
This type stub file was generated by pyright.
"""

import numpy as np
from collections.abc import Callable
from typing import Literal

"""Implementation of an FFT-based Short-time Fourier Transform. """
__all__ = ['closest_STFT_dual_window', 'ShortTimeFFT']
PAD_TYPE = Literal['zeros', 'edge', 'even', 'odd']
FFT_MODE_TYPE = Literal['twosided', 'centered', 'onesided', 'onesided2X']
def closest_STFT_dual_window(win: np.ndarray, hop: int, desired_dual: np.ndarray | None = ..., *, scaled: bool = ...) -> tuple[np.ndarray, float | complex]:
    r"""Calculate the STFT dual window of a given window closest to a desired dual
        window.

        For a given short-time Fourier transform window `win` incremented by `hop`
        samples, the dual window is calculated, which minimizes
        ``abs(dual_win - desired_dual)**2`` when `scaled` is ``False``. For `scaled`
        set to ``True``, ``abs(alpha*dual_win - desired_dual)**2`` is minimized with
        `alpha` being the optimal scaling factor.
        A ``ValueError`` is raised if no valid dual window can be determined.


        Parameters
        ----------
        win : np.ndarray
            The window must be a real- or complex-valued 1d array.
        hop : int
            The increment in samples by which the window is shifted in each step.
        desired_dual: np.ndarray | None
            The desired dual window must be a 1d array of the same length as `win`.
            If set to ``None`` (default), then `desired_dual` is assumed to be the
            rectangular window, i.e., ``np.ones_like(win)``.
        scaled : bool
            If set (default), the closest scaled version instead of closest dual window
            is calculated.

        Returns
        -------
        dual_win : np.ndarray
            A dual window of ``alpha*win`` (with hop interval `hop`), which is closest
            to `desired_dual`. Note that the dual window of `win` is `dual_win/alpha`
            and that the dual window of `dual_win` is `alpha*win`.
            `dual_win` has the same shape as `win` and `desired_win`.
        alpha : float | complex
            Scale factor for `win`. It is always one if `scaled` is set to ``False``.

        Notes
        -----
        For a given window and `hop` interval, all possible dual windows are expressed
        by the `hop` linear conditions of Eq. :math:numref:`eq_STFT_AllDualWinsCond` in
        the :ref:`tutorial_stft` section of the :ref:`user_guide`. Hence, decreasing
        `hop`, increases the number of degrees of freedom of the set of all possible
        dual windows, improving the ability to better approximate a `desired_dual`.

        This function can also be used to determine windows which fulfill the
        so-called "Constant OverLap Add" (COLA) condition [1]_. It states that summing
        all touching window values at any given sample position results in the same
        constant :math:`\alpha`. Eq. :math:numref:`eq_STFT_AllDualWinsCond` shows that
        this is equal to having a rectangular dual window, i.e., the dual being
        ``alpha*np.ones(m)``.

        Some examples of windows that satisfy COLA (taken from [2]_):

        - Rectangular window at overlap of 0, 1/2, 2/3, 3/4, ...
        - Bartlett window at overlap of 1/2, 3/4, 5/6, ...
        - Hann window at 1/2, 2/3, 3/4, ...
        - Any Blackman family window at 2/3 overlap
        - Any window with ``hop=1``

        References
        ----------
        .. [1] Julius O. Smith III, "Spectral Audio Signal Processing",
               online book, 2011, https://www.dsprelated.com/freebooks/sasp/
        .. [2] G. Heinzel, A. Ruediger and R. Schilling, "Spectrum and spectral density
               estimation by the Discrete Fourier transform (DFT), including a
               comprehensive list of window functions and some new at-top windows",
               2002, http://hdl.handle.net/11858/00-001M-0000-0013-557A-5

        Examples
        --------
        Let's show that a Bartlett window with 75% overlap fulfills the COLA condition:

        >>> import matplotlib.pyplot as plt
        >>> import numpy as np
        >>> from scipy.signal import closest_STFT_dual_window, windows
        ...
        >>> m = 24
        >>> win, w_rect = windows.bartlett(m, sym=False), np.ones(m)
        >>> d_win, alpha = closest_STFT_dual_window(win, m//4, w_rect, scaled=True)
        >>> print(f"COLA: {np.allclose(d_win, w_rect*alpha)}, {alpha = :g}")
        COLA: True, alpha = 0.5

        We can also determine for which hop intervals the COLA condition is fulfilled:

        >>> hops, deviations, alphas = np.arange(1, 16, dtype=int), [], []
        >>> for h_ in hops:
        ...     w_cola, alpha = closest_STFT_dual_window(w_rect, h_, win, scaled=True)
        ...     deviations.append(np.linalg.norm(w_cola - win*alpha))
        ...     alphas.append(alpha)
        ...
        >>> fg0, (ax0, ax1) = plt.subplots(2, 1, sharex='all', tight_layout=True)
        >>> ax0.set_title(f"COLA Window closest to a {m}-Sample Bartlett Window")
        >>> ax0.set(ylabel=r"$||w_\text{cola}-\alpha w||$", xlim=(0, hops[-1]-.5))
        >>> ax1.set(xlabel="Hop Interval", ylabel=r"Scaling factor $\alpha$",
        ...         ylim=(0, 1.25))
        >>> ax0.plot(hops, deviations, 'C0.-')
        >>> ax1.plot(hops, alphas, 'C1.-')
        >>> for ax_ in (ax0, ax1):
        ...     ax_.grid()
        >>> plt.show()

        The lower plot shows the calculated scaling factor :math:`\alpha` for different
        `hops` whereas the upper displays the  :math:`L^2`-norm of the difference
        between the scaled Bartlett window and the calculated window. Since for `hops`
        1 to 4 as well as for 6 and 12 the :math:`L^2`-norm of the difference is
        practically zero, the COLA condition is fulfilled for those.

        See Also
        --------
        ShortTimeFFT: Short-time Fourier transform which is able to utilize a dual
                      window for calculating the inverse.
        ShortTimeFFT.from_win_equals_dual: Create instance where the window and its
                                           dual are equal.

    """
    ...

class ShortTimeFFT:
    r"""Provide a parametrized discrete Short-time Fourier transform (stft)
    and its inverse (istft).

    .. currentmodule:: scipy.signal.ShortTimeFFT

    The `~ShortTimeFFT.stft` calculates sequential FFTs by sliding a
    window (`win`) over an input signal by `hop` increments. It can be used to
    quantify the change of the spectrum over time.

    The `~ShortTimeFFT.stft` is represented by a complex-valued matrix S[q,p]
    where the p-th column represents an FFT with the window centered at the
    time t[p] = p * `delta_t` = p * `hop` * `T` where `T` is  the sampling
    interval of the input signal. The q-th row represents the values at the
    frequency f[q] = q * `delta_f` with `delta_f` = 1 / (`mfft` * `T`) being
    the bin width of the FFT.

    The inverse STFT `~ShortTimeFFT.istft` is calculated by reversing the steps
    of the STFT: Take the IFFT of the p-th slice of S[q,p] and multiply the
    result with the so-called dual window (see `dual_win`). Shift the result by
    p * `delta_t` and add the result to previous shifted results to reconstruct
    the signal. If only the dual window is known and the STFT is invertible,
    `from_dual` can be used to instantiate this class.

    By default, the so-called canonical dual window is used. It is the window with
    minimal energy among all possible dual windows. `from_win_equals_dual` and
    `~scipy.signal.closest_STFT_dual_window` provide means for utilizing alterantive
    dual windows. Note that `win` is also always a dual window of `dual_win`.

    Due to the convention of time t = 0 being at the first sample of the input
    signal, the STFT values typically have negative time slots. Hence,
    negative indexes like `p_min` or `k_min` do not indicate counting
    backwards from an array's end like in standard Python indexing but being
    left of t = 0.

    More detailed information can be found in the :ref:`tutorial_stft`
    section of the :ref:`user_guide`.

    Note that all parameters of the initializer, except `scale_to` (which uses
    `scaling`) have identical named attributes.

    Parameters
    ----------
    win : np.ndarray
        The window must be a real- or complex-valued 1d array.
    hop : int
        The increment in samples, by which the window is shifted in each step.
    fs : float
        Sampling frequency of input signal and window. Its relation to the
        sampling interval `T` is ``T = 1 / fs``.
    fft_mode : 'twosided', 'centered', 'onesided', 'onesided2X'
        Mode of FFT to be used (default 'onesided').
        See property `fft_mode` for details.
    mfft: int | None
        Length of the FFT used, if a zero padded FFT is desired.
        If ``None`` (default), the length of the window `win` is used.
    dual_win : np.ndarray | None
        The dual window of `win`. If set to ``None``, it is calculated if
        needed.
    scale_to : 'magnitude', 'psd' | None
        If not ``None`` (default) the window function is scaled, so each STFT
        column represents either a 'magnitude' or a power spectral density
        ('psd') spectrum. This parameter sets the property `scaling` to the
        same value. See method `scale_to` for details.
    phase_shift : int | None
        If set, add a linear phase `phase_shift` / `mfft` * `f` to each
        frequency `f`. The default value of 0 ensures that there is no phase shift
        on the zeroth slice (in which t=0 is centered). See property
        `phase_shift` for more details.

    Notes
    -----
    A typical STFT application is the creation of various types of time-frequency
    plots, often subsumed under the term "spectrogram". Note that this term is also
    used to explecitly refer to the absolute square of a STFT [11]_, as done in
    :meth:`spectrogram`.

    The STFT can also be used for filtering and filter banks as discussed in [12]_.


    References
    ----------
    .. [11] Karlheinz Gröchenig: "Foundations of Time-Frequency Analysis",
           Birkhäuser Boston 2001, `10.1007/978-1-4612-0003-1`
    .. [12] Julius O. Smith III, "Spectral Audio Signal Processing", online book, 2011,
           https://www.dsprelated.com/freebooks/sasp/


    Examples
    --------
    The following example shows the magnitude of the STFT of a sine with
    varying frequency :math:`f_i(t)` (marked by a red dashed line in the plot):

    >>> import numpy as np
    >>> import matplotlib.pyplot as plt
    >>> from scipy.signal import ShortTimeFFT
    >>> from scipy.signal.windows import gaussian
    ...
    >>> T_x, N = 1 / 20, 1000  # 20 Hz sampling rate for 50 s signal
    >>> t_x = np.arange(N) * T_x  # time indexes for signal
    >>> f_i = 1 * np.arctan((t_x - t_x[N // 2]) / 2) + 5  # varying frequency
    >>> x = np.sin(2*np.pi*np.cumsum(f_i)*T_x) # the signal

    The utilized Gaussian window is 50 samples or 2.5 s long. The parameter
    ``mfft=200`` in `ShortTimeFFT` causes the spectrum to be oversampled
    by a factor of 4:

    >>> g_std = 8  # standard deviation for Gaussian window in samples
    >>> w = gaussian(50, std=g_std, sym=True)  # symmetric Gaussian window
    >>> SFT = ShortTimeFFT(w, hop=10, fs=1/T_x, mfft=200, scale_to='magnitude')
    >>> Sx = SFT.stft(x)  # perform the STFT

    In the plot, the time extent of the signal `x` is marked by vertical dashed
    lines. Note that the SFT produces values outside the time range of `x`. The
    shaded areas on the left and the right indicate border effects caused
    by the window slices in that area not fully being inside time range of
    `x`:

    >>> fig1, ax1 = plt.subplots(figsize=(6., 4.))  # enlarge plot a bit
    >>> t_lo, t_hi = SFT.extent(N)[:2]  # time range of plot
    >>> ax1.set_title(rf"STFT ({SFT.m_num*SFT.T:g}$\,s$ Gaussian window, " +
    ...               rf"$\sigma_t={g_std*SFT.T}\,$s)")
    >>> ax1.set(xlabel=f"Time $t$ in seconds ({SFT.p_num(N)} slices, " +
    ...                rf"$\Delta t = {SFT.delta_t:g}\,$s)",
    ...         ylabel=f"Freq. $f$ in Hz ({SFT.f_pts} bins, " +
    ...                rf"$\Delta f = {SFT.delta_f:g}\,$Hz)",
    ...         xlim=(t_lo, t_hi))
    ...
    >>> im1 = ax1.imshow(abs(Sx), origin='lower', aspect='auto',
    ...                  extent=SFT.extent(N), cmap='viridis')
    >>> ax1.plot(t_x, f_i, 'r--', alpha=.5, label='$f_i(t)$')
    >>> fig1.colorbar(im1, label="Magnitude $|S_x(t, f)|$")
    ...
    >>> # Shade areas where window slices stick out to the side:
    >>> for t0_, t1_ in [(t_lo, SFT.lower_border_end[0] * SFT.T),
    ...                  (SFT.upper_border_begin(N)[0] * SFT.T, t_hi)]:
    ...     ax1.axvspan(t0_, t1_, color='w', linewidth=0, alpha=.2)
    >>> for t_ in [0, N * SFT.T]:  # mark signal borders with vertical line:
    ...     ax1.axvline(t_, color='y', linestyle='--', alpha=0.5)
    >>> ax1.legend()
    >>> fig1.tight_layout()
    >>> plt.show()

    Reconstructing the signal with the `~ShortTimeFFT.istft` is
    straightforward, but note that the length of `x1` should be specified,
    since the STFT length increases in `hop` steps:

    >>> SFT.invertible  # check if invertible
    True
    >>> x1 = SFT.istft(Sx, k1=N)
    >>> np.allclose(x, x1)
    True

    It is possible to calculate the STFT of signal parts:

    >>> N2 = SFT.nearest_k_p(N // 2)
    >>> Sx0 = SFT.stft(x[:N2])
    >>> Sx1 = SFT.stft(x[N2:])

    When assembling sequential STFT parts together, the overlap needs to be
    considered:

    >>> p0_ub = SFT.upper_border_begin(N2)[1] - SFT.p_min
    >>> p1_le = SFT.lower_border_end[1] - SFT.p_min
    >>> Sx01 = np.hstack((Sx0[:, :p0_ub],
    ...                   Sx0[:, p0_ub:] + Sx1[:, :p1_le],
    ...                   Sx1[:, p1_le:]))
    >>> np.allclose(Sx01, Sx)  # Compare with SFT of complete signal
    True

    It is also possible to calculate the `itsft` for signal parts:

    >>> y_p = SFT.istft(Sx, N//3, N//2)
    >>> np.allclose(y_p, x[N//3:N//2])
    True

    """
    _win: np.ndarray
    _dual_win: np.ndarray | None = ...
    _hop: int
    _fs: float
    _fft_mode: FFT_MODE_TYPE = ...
    _mfft: int
    _scaling: Literal['magnitude', 'psd', 'unitary'] | None = ...
    _phase_shift: int | None
    _fac_mag: float | None = ...
    _fac_psd: float | None = ...
    _lower_border_end: tuple[int, int] | None = ...
    _cache_post_padding: tuple[int, tuple[int, int]] = ...
    _cache_upper_border_begin: tuple[int, tuple[int, int]] = ...
    _cache_t: tuple[tuple[int, int | None, int | None, int, float], np.ndarray] = ...
    _cache_f: tuple[tuple[FFT_MODE_TYPE, int, float], np.ndarray] = ...
    def __init__(self, win: np.ndarray, hop: int, fs: float, *, fft_mode: FFT_MODE_TYPE = ..., mfft: int | None = ..., dual_win: np.ndarray | None = ..., scale_to: Literal['magnitude', 'psd'] | None = ..., phase_shift: int | None = ...) -> None:
        ...
    
    @classmethod
    def from_dual(cls, dual_win: np.ndarray, hop: int, fs: float, *, fft_mode: FFT_MODE_TYPE = ..., mfft: int | None = ..., scale_to: Literal['magnitude', 'psd'] | None = ..., phase_shift: int | None = ...): # -> Self:
        r"""Instantiate a `ShortTimeFFT` by only providing a dual window.

        If an STFT is invertible, it is possible to calculate the window `win`
        from a given dual window `dual_win`. All other parameters have the
        same meaning as in the initializer of `ShortTimeFFT`.

        As explained in the :ref:`tutorial_stft` section of the
        :ref:`user_guide`, an invertible STFT can be interpreted as series
        expansion of time-shifted and frequency modulated dual windows. E.g.,
        the series coefficient S[q,p] belongs to the term, which shifted
        `dual_win` by p * `delta_t` and multiplied it by
        exp( 2 * j * pi * t * q * `delta_f`).


        Examples
        --------
        The following example discusses decomposing a signal into time- and
        frequency-shifted Gaussians. A Gaussian with standard deviation of
        one made up of 51 samples will be used:

        >>> import numpy as np
        >>> import matplotlib.pyplot as plt
        >>> from scipy.signal import ShortTimeFFT
        >>> from scipy.signal.windows import gaussian
        ...
        >>> T, N = 0.1, 51
        >>> d_win = gaussian(N, std=1/T, sym=True)  # symmetric Gaussian window
        >>> t = T * (np.arange(N) - N//2)
        ...
        >>> fg1, ax1 = plt.subplots()
        >>> ax1.set_title(r"Dual Window: Gaussian with $\sigma_t=1$")
        >>> ax1.set(xlabel=f"Time $t$ in seconds ({N} samples, $T={T}$ s)",
        ...        xlim=(t[0], t[-1]), ylim=(0, 1.1*np.max(d_win)))
        >>> ax1.plot(t, d_win, 'C0-')

        The following plot with the overlap of 41, 11 and 2 samples show how
        the `hop` interval affects the shape of the window `win`:

        >>> fig2, axx = plt.subplots(3, 1, sharex='all')
        ...
        >>> axx[0].set_title(r"Windows for hop$\in\{10, 40, 49\}$")
        >>> for c_, h_ in enumerate([10, 40, 49]):
        ...     SFT = ShortTimeFFT.from_dual(d_win, h_, 1/T)
        ...     axx[c_].plot(t + h_ * T, SFT.win, 'k--', alpha=.3, label=None)
        ...     axx[c_].plot(t - h_ * T, SFT.win, 'k:', alpha=.3, label=None)
        ...     axx[c_].plot(t, SFT.win, f'C{c_+1}',
        ...                     label=r"$\Delta t=%0.1f\,$s" % SFT.delta_t)
        ...     axx[c_].set_ylim(0, 1.1*max(SFT.win))
        ...     axx[c_].legend(loc='center')
        >>> axx[-1].set(xlabel=f"Time $t$ in seconds ({N} samples, $T={T}$ s)",
        ...             xlim=(t[0], t[-1]))
        >>> plt.show()

        Beside the window `win` centered at t = 0 the previous (t = -`delta_t`)
        and following window (t = `delta_t`) are depicted. It can be seen that
        for small `hop` intervals, the window is compact and smooth, having a
        good time-frequency concentration in the STFT. For the large `hop`
        interval of 4.9 s, the window has small values around t = 0, which are
        not covered by the overlap of the adjacent windows, which could lead to
        numeric inaccuracies. Furthermore, the peaky shape at the beginning and
        the end of the window points to a higher bandwidth, resulting in a
        poorer time-frequency resolution of the STFT.
        Hence, the choice of the `hop` interval will be a compromise between
        a time-frequency resolution and memory requirements demanded by small
        `hop` sizes.

        See Also
        --------
        from_window: Create instance by wrapping `get_window`.
        ShortTimeFFT: Create instance using standard initializer.
        """
        ...
    
    @classmethod
    def from_window(cls, win_param: str | tuple | float, fs: float, nperseg: int, noverlap: int, *, symmetric_win: bool = ..., fft_mode: FFT_MODE_TYPE = ..., mfft: int | None = ..., scale_to: Literal['magnitude', 'psd'] | None = ..., phase_shift: int | None = ...): # -> Self:
        """Instantiate `ShortTimeFFT` by using `get_window`.

        The method `get_window` is used to create a window of length
        `nperseg`. The parameter names `noverlap`, and `nperseg` are used here,
        since they more inline with other classical STFT libraries.

        Parameters
        ----------
        win_param: Union[str, tuple, float],
            Parameters passed to `get_window`. For windows with no parameters,
            it may be a string (e.g., ``'hann'``), for parametrized windows a
            tuple, (e.g., ``('gaussian', 2.)``) or a single float specifying
            the shape parameter of a kaiser window (i.e. ``4.``  and
            ``('kaiser', 4.)`` are equal. See `get_window` for more details.
        fs : float
            Sampling frequency of input signal. Its relation to the
            sampling interval `T` is ``T = 1 / fs``.
        nperseg: int
            Window length in samples, which corresponds to the `m_num`.
        noverlap: int
            Window overlap in samples. It relates to the `hop` increment by
            ``hop = npsereg - noverlap``.
        symmetric_win: bool
            If ``True`` then a symmetric window is generated, else a periodic
            window is generated (default). Though symmetric windows seem for
            most applications to be more sensible, the default of a periodic
            windows was chosen to correspond to the default of `get_window`.
        fft_mode : 'twosided', 'centered', 'onesided', 'onesided2X'
            Mode of FFT to be used (default 'onesided').
            See property `fft_mode` for details.
        mfft: int | None
            Length of the FFT used, if a zero padded FFT is desired.
            If ``None`` (default), the length of the window `win` is used.
        scale_to : 'magnitude', 'psd' | None
            If not ``None`` (default) the window function is scaled, so each
            STFT column represents  either a 'magnitude' or a power spectral
            density ('psd') spectrum. This parameter sets the property
            `scaling` to the same value. See method `scale_to` for details.
        phase_shift : int | None
            If set, add a linear phase `phase_shift` / `mfft` * `f` to each
            frequency `f`. The default value 0 ensures that there is no phase
            shift on the zeroth slice (in which t=0 is centered). See property
            `phase_shift` for more details.

        Examples
        --------
        The following instances ``SFT0`` and ``SFT1`` are equivalent:

        >>> from scipy.signal import ShortTimeFFT, get_window
        >>> nperseg = 9  # window length
        >>> w = get_window(('gaussian', 2.), nperseg)
        >>> fs = 128  # sampling frequency
        >>> hop = 3  # increment of STFT time slice
        >>> SFT0 = ShortTimeFFT(w, hop, fs=fs)
        >>> SFT1 = ShortTimeFFT.from_window(('gaussian', 2.), fs, nperseg,
        ...                                 noverlap=nperseg-hop)

        See Also
        --------
        scipy.signal.get_window: Return a window of a given length and type.
        from_dual: Create instance using dual window.
        ShortTimeFFT: Create instance using standard initializer.
        """
        ...
    
    @classmethod
    def from_win_equals_dual(cls, desired_win: np.ndarray, hop: int, fs: float, *, fft_mode: FFT_MODE_TYPE = ..., mfft: int | None = ..., scale_to: Literal['magnitude', 'psd', 'unitary'] | None = ..., phase_shift: int | None = ...): # -> Self:
        r"""Create instance where the window and its dual are equal up to a
        scaling factor.

        An instance is created were window and dual window are equal as well as being
        closest to the parameter `desired_win` in the least-squares sense, i.e.,
        minimizing ``abs(win-desired_win)**2``. Hence, `win` has the same length as
        `desired_win`. Then a scaling factor is applied accoring to the `scale_to`
        parameter.

        All other parameters have the identical meaning as in the initializer.

        To be able to calculate a valid window, `desired_win` needs to have a valid
        dual STFT window for the given `hop` interval.
        If this is not the case, a ``ValueError`` is raised.

        Parameters
        ----------
        desired_win : np.ndarray
            A real-valued or complex-valued 1d array containing the sample of the
            desired window.
        hop : int
            The increment in samples, by which the window is shifted in each step.
        fs : float
            Sampling frequency of input signal and window. Its relation to the
            sampling interval `T` is ``T = 1 / fs``.
        fft_mode : 'twosided', 'centered', 'onesided', 'onesided2X'
            Mode of FFT to be used (default 'onesided').
            See property `fft_mode` for details.
        mfft: int | None
            Length of the FFT used, if a zero padded FFT is desired.
            If ``None`` (default), the length of the window `win` is used.
        scale_to : 'magnitude' | 'psd' | 'unitary' | None
            If not ``None`` (default) the window function is scaled, so each STFT
            column represents either a 'magnitude' or a power spectral density ('psd')
            spectrum, Alternatively, the STFT can be scaled to a`unitary` mapping,
            i.e., dividing the window by ``np.sqrt(mfft)`` and multiplying the dual
            window by the same amount.
        phase_shift : int | None
            If set, add a linear phase `phase_shift` / `mfft` * `f` to each
            frequency `f`. The default value of 0 ensures that there is no phase shift
            on the zeroth slice (in which t=0 is centered). See property
            `phase_shift` for more details.


        Notes
        -----
        The set of all possible windows with identical dual is defined by the set of
        linear constraints of Eq. :math:numref:`eq_STFT_AllDualWinsCond` in the
        :ref:`tutorial_stft` section of the :ref:`user_guide`. There it is also
        derived that ``ShortTimeFFT.dual_win == ShortTimeFFT.m_pts * ShortTimeFFT.win``
        needs to hold for an STFT to be a unitary mapping.

        A unitary mapping preserves the value of the scalar product, i.e.,

        .. math::

            \langle x, y\rangle = \sum_k x[k]\, \overline{y[k]}
            \stackrel{\stackrel{\text{unitary}}{\downarrow}}{=}
            \sum_{q,p} S_x[q,p]\, \overline{S_y[q,p]}
            = \langle S_x[q,p], S_y[q,p]\rangle\ ,

        with :math:`S_{x,y}` being the STFT of :math:`x,y`. Hence, the energy
        :math:`E_x=T\sum_k |x[k]|^2` of a signal is also preserved. This is also
        illustrated in the example below.

        Thie reason of distinguishing between no scaling (i.e., parameter `scale_to` is
        ``None``) and unitary scaling (i.e., ``scale_to = 'unitary'``) is due to the
        utilized FFT function not being unitary (i.e., using the default value
        ``'backward'`` for the `~scipy.fft.fft` parameter `norm`).


        See Also
        --------
        closest_STFT_dual_window: Calculate the STFT dual window of a given window
                                  closest to a desired dual window.
        ShortTimeFFT.spectrogram: Calculate squared STFTs
        ShortTimeFFT: Class this property belongs to.

        Examples
        --------
        The following example shows that an STFT can be indeed unitary:

        >>> import matplotlib.pyplot as plt
        >>> import numpy as np
        >>> from scipy.signal import ShortTimeFFT, windows
        ...
        >>> m, hop, std = 36, 8, 5
        >>> desired_win = windows.gaussian(m, std, sym=True)
        >>> SFT = ShortTimeFFT.from_win_equals_dual(desired_win, hop, fs=1/m,
        ...                                         fft_mode='twosided',
        ...                                         scale_to='unitary')
        >>> np.allclose(SFT.dual_win, SFT.win * SFT.m_num)  # check if STFT is unitary
        True
        >>> x1, x2 = np.tile([-1, -1, 1, 1], 5), np.tile([1, -1, -1, 1], 5)
        >>> np.sum(x1*x2) # scalar product is zero -> orthogonal signals
        0
        >>> np.sum(x1**2)  # scalar product of x1 with itself
        20
        >>> Sx11, Sx12 = SFT.spectrogram(x1), SFT.spectrogram(x1, x2)
        >>> np.sum(Sx12)  # STFT scalar product is also zero
        -4.163336342344337e-16+0j  # may vary
        >>> np.sum(Sx11)  # == np.sum(x1**2)
        19.999999999999996  # may vary
        ...
        ... # Do the plotting:
        >>> fg1, (ax11, ax12) = plt.subplots(1, 2, tight_layout=True, figsize=(8, 4))
        >>> s_fac = np.sqrt(SFT.mfft)
        >>> _ = fg1.suptitle(f"Scaled Unitary Window of {m} Sample Gaussian with " +
        ...                  rf"{hop=}, $\sigma={std}$, Scale factor: {s_fac}")
        >>> ax11.set(ylabel="Amplitude", xlabel="Samples", xlim=(0, m))
        >>> ax12.set(xlabel="Frequency Bins", ylabel="Magnitude Spectrum",
        ...          xlim=(0, 15), ylim=(1e-5, 1.5))
        >>> u_win_str = rf"Unitary $\times{s_fac:g}$"
        >>> for x_, n_ in zip((desired_win, SFT.win*s_fac), ('Desired', u_win_str)):
        ...     ax11.plot(x_, '.-', alpha=0.5, label=n_)
        ...     X_ = np.fft.rfft(x_) / np.sum(abs(x_))
        ...     ax12.semilogy(abs(X_), '.-', alpha=0.5, label=n_)
        >>> for ax_ in (ax11, ax12):
        ...     ax_.grid(True)
        ...     ax_.legend()
        >>> plt.show()

        Note that ``fftmode='twosided'`` is used, since we need sum over the complete
        time frequency plane. Due to passing ``scale_to='unitary'`` the window
        ``SFT.win`` is scaled by ``1/np.sqrt(SFT.mfft)``. Hence, ``SFT.win`` needs to
        be scaled by `s_fac` in the plot above.
        """
        ...
    
    @property
    def win(self) -> np.ndarray:
        """Window function as real- or complex-valued 1d array.

        This attribute is read-only, since `dual_win` depends on it.
        To make this array immutable, its WRITEABLE flag is set to ``FALSE``.

        See Also
        --------
        dual_win: Dual window.
        m_num: Number of samples in window `win`.
        m_num_mid: Center index of window `win`.
        mfft: Length of input for the FFT used - may be larger than `m_num`.
        hop: ime increment in signal samples for sliding window.
        win: Window function as real- or complex-valued 1d array.
        numpy.ndarray.setflags: Modify array flags.
        ShortTimeFFT: Class this property belongs to.
        """
        ...
    
    @property
    def hop(self) -> int:
        """Time increment in signal samples for sliding window.

        This attribute is read only, since `dual_win` depends on it.

        See Also
        --------
        delta_t: Time increment of STFT (``hop*T``)
        m_num: Number of samples in window `win`.
        m_num_mid: Center index of window `win`.
        mfft: Length of input for the FFT used - may be larger than `m_num`.
        T: Sampling interval of input signal and of the window.
        win: Window function as real- or complex-valued 1d array.
        ShortTimeFFT: Class this property belongs to.
        """
        ...
    
    @property
    def T(self) -> float:
        """Sampling interval of input signal and of the window.

        A ``ValueError`` is raised if it is set to a non-positive value.

        See Also
        --------
        delta_t: Time increment of STFT (``hop*T``)
        hop: Time increment in signal samples for sliding window.
        fs: Sampling frequency (being ``1/T``)
        t: Times of STFT for an input signal with `n` samples.
        ShortTimeFFT: Class this property belongs to.
        """
        ...
    
    @T.setter
    def T(self, v: float): # -> None:
        """Sampling interval of input signal and of the window.

        A ``ValueError`` is raised if it is set to a non-positive value.
        """
        ...
    
    @property
    def fs(self) -> float:
        """Sampling frequency of input signal and of the window.

        The sampling frequency is the inverse of the sampling interval `T`.
        A ``ValueError`` is raised if it is set to a non-positive value.

        See Also
        --------
        delta_t: Time increment of STFT (``hop*T``)
        hop: Time increment in signal samples for sliding window.
        T: Sampling interval of input signal and of the window (``1/fs``).
        ShortTimeFFT: Class this property belongs to.
        """
        ...
    
    @fs.setter
    def fs(self, v: float): # -> None:
        """Sampling frequency of input signal and of the window.

        The sampling frequency is the inverse of the sampling interval `T`.
        A ``ValueError`` is raised if it is set to a non-positive value.
        """
        ...
    
    @property
    def fft_mode(self) -> FFT_MODE_TYPE:
        """Mode of utilized FFT ('twosided', 'centered', 'onesided' or
        'onesided2X').

        It can have the following values:

        'twosided':
            Two-sided FFT, where values for the negative frequencies are in
            upper half of the array. Corresponds to :func:`~scipy.fft.fft()`.
        'centered':
            Two-sided FFT with the values being ordered along monotonically
            increasing frequencies. Corresponds to applying
            :func:`~scipy.fft.fftshift()` to :func:`~scipy.fft.fft()`.
        'onesided':
            Calculates only values for non-negative frequency values.
            Corresponds to :func:`~scipy.fft.rfft()`.
        'onesided2X':
            Like `onesided`, but the non-zero frequencies are doubled if
            `scaling` is set to 'magnitude' or multiplied by ``sqrt(2)`` if
            set to 'psd'. If `scaling` is ``None``, setting `fft_mode` to
            `onesided2X` is not allowed.
            If the FFT length `mfft` is even, the last FFT value is not paired,
            and thus it is not scaled.

        Note that `onesided` and `onesided2X` do not work for complex-valued signals or
        complex-valued windows. Furthermore, the frequency values can be obtained by
        reading the `f` property, and the number of samples by accessing the `f_pts`
        property.

        See Also
        --------
        delta_f: Width of the frequency bins of the STFT.
        f: Frequencies values of the STFT.
        f_pts: Width of the frequency bins of the STFT.
        onesided_fft: True if a one-sided FFT is used.
        scaling: Normalization applied to the window function
        ShortTimeFFT: Class this property belongs to.
        """
        ...
    
    @fft_mode.setter
    def fft_mode(self, t: FFT_MODE_TYPE): # -> None:
        """Set mode of FFT.

        Allowed values are 'twosided', 'centered', 'onesided', 'onesided2X'.
        See the property `fft_mode` for more details.
        """
        ...
    
    @property
    def mfft(self) -> int:
        """Length of input for the FFT used - may be larger than window
        length `m_num`.

        If not set, `mfft` defaults to the window length `m_num`.

        See Also
        --------
        f_pts: Number of points along the frequency axis.
        f: Frequencies values of the STFT.
        m_num: Number of samples in window `win`.
        ShortTimeFFT: Class this property belongs to.
        """
        ...
    
    @mfft.setter
    def mfft(self, n_: int): # -> None:
        """Setter for the length of FFT utilized.

        See the property `mfft` for further details.
        """
        ...
    
    @property
    def scaling(self) -> Literal['magnitude', 'psd', 'unitary'] | None:
        """Normalization applied to the window function
        ('magnitude', 'psd', 'unitary', or ``None``).

        If not ``None``, the FFT slices may be either interpreted as a `magnitude` or
        a power spectral density spectrum (`psd`). If set to `unitary`, the STFT may be
        interpreted as a unitary mapping, i.e., preserving the value of the scalar
        product.

        The window function can be scaled by calling the `scale_to` method,
        or it is set by the initializer parameter ``scale_to``. Note that a
        window cannot to be scaled to be `unitary`.  Use `from_win_equals_dual`
        to create a unitary `ShortTimeFFT` instance.

        See Also
        --------
        fac_magnitude: Scaling factor for to a magnitude spectrum.
        fac_psd: Scaling factor for to  a power spectral density spectrum.
        fft_mode: Mode of utilized FFT
        scale_to: Scale window to obtain 'magnitude' or 'psd' scaling.
        from_win_equals_dual: Class-method for creating a unitary instance.
        ShortTimeFFT: Class this property belongs to.
        """
        ...
    
    def scale_to(self, scaling: Literal['magnitude', 'psd']): # -> None:
        """Scale window to obtain 'magnitude' or 'psd' scaling for the STFT.

        The window of a 'magnitude' spectrum has an integral of one, i.e., unit
        area for non-negative windows. This ensures that absolute the values of
        spectrum does not change if the length of the window changes (given
        the input signal is stationary).

        To represent the power spectral density ('psd') for varying length
        windows the area of the absolute square of the window needs to be
        unity.

        The `scaling` property shows the current scaling. The properties
        `fac_magnitude` and `fac_psd` show the scaling factors required to
        scale the STFT values to a magnitude or a psd spectrum.

        Note that a window cannot to be scaled to be `unitary`. Use
        `from_win_equals_dual` to create a unitary `ShortTimeFFT` instance.

        This method is called, if the initializer parameter `scale_to` is set.

        See Also
        --------
        fac_magnitude: Scaling factor for to  a magnitude spectrum.
        fac_psd: Scaling factor for to  a power spectral density spectrum.
        fft_mode: Mode of utilized FFT
        scaling: Normalization applied to the window function.
        ShortTimeFFT: Class this method belongs to.
        """
        ...
    
    @property
    def phase_shift(self) -> int | None:
        """If set, add linear phase `phase_shift` / `mfft` * `f` to each FFT
        slice of frequency `f`.

        Shifting (more precisely `rolling`) an `mfft`-point FFT input by
        `phase_shift` samples results in a multiplication of the output by
        ``np.exp(2j*np.pi*q*phase_shift/mfft)`` at the frequency q * `delta_f`.

        The default value 0 ensures that there is no phase shift on the
        zeroth slice (in which t=0 is centered).
        No phase shift (``phase_shift is None``) is equivalent to
        ``phase_shift = -mfft//2``. In this case slices are not shifted
        before calculating the FFT.

        The absolute value of `phase_shift` is limited to be less than `mfft`.

        See Also
        --------
        delta_f: Width of the frequency bins of the STFT.
        f: Frequencies values of the STFT.
        mfft: Length of input for the FFT used
        ShortTimeFFT: Class this property belongs to.
        """
        ...
    
    @phase_shift.setter
    def phase_shift(self, v: int | None): # -> None:
        """The absolute value of the phase shift needs to be less than mfft
        samples.

        See the `phase_shift` getter method for more details.
        """
        ...
    
    def stft(self, x: np.ndarray, p0: int | None = ..., p1: int | None = ..., *, k_offset: int = ..., padding: PAD_TYPE = ..., axis: int = ...) -> np.ndarray:
        """Perform the short-time Fourier transform.

        A two-dimensional matrix with ``p1-p0`` columns is calculated.
        The `f_pts` rows represent value at the frequencies `f`. The q-th
        column of the windowed FFT with the window `win` is centered at t[q].
        The columns represent the values at the frequencies `f`.

        Parameters
        ----------
        x : np.ndarray
            The input signal as real or complex valued array. For complex values, the
            property `fft_mode` must be set to 'twosided' or 'centered'.
        p0 : int | None
            The first element of the range of slices to calculate. If ``None``
            then it is set to :attr:`p_min`, which is the smallest possible
            slice.
        p1 : int | None
            The end of the array. If ``None`` then `p_max(n)` is used.
        k_offset : int
            Index of first sample (t = 0) in `x`.
        padding : 'zeros' | 'edge' | 'even' | 'odd'
            Kind of values which are added, when the sliding window sticks out
            on either the lower or upper end of the input `x`. Zeros are added
            if the default 'zeros' is set. For 'edge' either the first or the
            last value of `x` is used. 'even' pads by reflecting the
            signal on the first or last sample and 'odd' additionally
            multiplies it with -1.
        axis : int
            The axis of `x` over which to compute the STFT.
            If not given, the last axis is used.

        Returns
        -------
        S : np.ndarray
            A complex array is returned with the dimension always being larger
            by one than of `x`. The last axis always represents the time slices
            of the STFT. `axis` defines the frequency axis (default second to
            last). E.g., for a one-dimensional `x`, a complex 2d array is
            returned, with axis 0 representing frequency and axis 1 the time
            slices.

        See Also
        --------
        delta_f: Width of the frequency bins of the STFT.
        delta_t: Time increment of STFT
        f: Frequencies values of the STFT.
        invertible: Check if STFT is invertible.
        :meth:`~ShortTimeFFT.istft`: Inverse short-time Fourier transform.
        p_range: Determine and validate slice index range.
        stft_detrend: STFT with detrended segments.
        t: Times of STFT for an input signal with `n` samples.
        :class:`scipy.signal.ShortTimeFFT`: Class this method belongs to.
        """
        ...
    
    def stft_detrend(self, x: np.ndarray, detr: Callable[[np.ndarray], np.ndarray] | Literal['linear', 'constant'] | None, p0: int | None = ..., p1: int | None = ..., *, k_offset: int = ..., padding: PAD_TYPE = ..., axis: int = ...) -> np.ndarray:
        """Calculate short-time Fourier transform with a trend being subtracted from
        each segment beforehand.

        When the parameter `detr` is ``None``, this method's behavior is identical to
        the `~ShortTimeFFT.stft` method. Note that due to the detrending, the original
        signal cannot be reconstructed by the `~ShortTimeFFT.istft`.

        Parameters
        ----------
        x : np.ndarray
            The input signal as real or complex valued array. For complex values, the
            property `fft_mode` must be set to 'twosided' or 'centered'.
        detr : 'linear' |  'constant' |  Callable[[np.ndarray], np.ndarray] | None
            If 'constant', the mean is subtracted, if set to "linear", the linear
            trend is removed from each segment. This is achieved by calling
            `~scipy.signal.detrend`. If `detr` is a function with one parameter, `detr`
            is applied to each segment.
        p0 : int | None
            The first element of the range of slices to calculate. If ``None``
            then it is set to :attr:`p_min`, which is the smallest possible
            slice.
        p1 : int | None
            The end of the array. If ``None`` then `p_max(n)` is used.
        k_offset : int
            Index of first sample (t = 0) in `x`.
        padding : 'zeros' | 'edge' | 'even' | 'odd'
            Kind of values which are added, when the sliding window sticks out
            on either the lower or upper end of the input `x`. Zeros are added
            if the default 'zeros' is set. For 'edge' either the first or the
            last value of `x` is used. 'even' pads by reflecting the
            signal on the first or last sample and 'odd' additionally
            multiplies it with -1.
        axis: int
            The axis of `x` over which to compute the STFT.
            If not given, the last axis is used.

        Returns
        -------
        S : np.ndarray
            A complex array is returned with the dimension always being larger
            by one than of `x`. The last axis always represents the time slices
            of the STFT. `axis` defines the frequency axis (default second to
            last). E.g., for a one-dimensional `x`, a complex 2d array is
            returned, with axis 0 representing frequency and axis 1 the time
            slices.

        See Also
        --------
        invertible: Check if STFT is invertible.
        :meth:`~ShortTimeFFT.istft`: Inverse short-time Fourier transform.
        :meth:`~ShortTimeFFT.stft`: Short-time Fourier transform
                                   (without detrending).
        :class:`scipy.signal.ShortTimeFFT`: Class this method belongs to.
        """
        ...
    
    def spectrogram(self, x: np.ndarray, y: np.ndarray | None = ..., detr: Callable[[np.ndarray], np.ndarray] | Literal['linear', 'constant'] | None = ..., *, p0: int | None = ..., p1: int | None = ..., k_offset: int = ..., padding: PAD_TYPE = ..., axis: int = ...) -> np.ndarray:
        r"""Calculate spectrogram or cross-spectrogram.

        The spectrogram is the absolute square of the STFT, i.e., it is
        ``abs(S[q,p])**2`` for given ``S[q,p]`` and thus is always
        non-negative.
        For two STFTs ``Sx[q,p], Sy[q,p]``, the cross-spectrogram is defined
        as ``Sx[q,p] * np.conj(Sy[q,p])`` and is complex-valued.
        This is a convenience function for calling `~ShortTimeFFT.stft` /
        `stft_detrend`, hence all parameters are discussed there.

        Parameters
        ----------
        x : np.ndarray
            The input signal as real or complex valued array. For complex values, the
            property `fft_mode` must be set to 'twosided' or 'centered'.
        y : np.ndarray
            The second input signal of the same shape as `x`. If ``None``, it is
            assumed to be `x`. For complex values, the property `fft_mode` must be
            set to 'twosided' or 'centered'.
        detr : 'linear' |  'constant' |  Callable[[np.ndarray], np.ndarray] | None
            If 'constant', the mean is subtracted, if set to "linear", the linear
            trend is removed from each segment. This is achieved by calling
            `~scipy.signal.detrend`. If `detr` is a function with one parameter, `detr`
            is applied to each segment. For ``None`` (default), no trends are removed.
        p0 : int | None
            The first element of the range of slices to calculate. If ``None``
            then it is set to :attr:`p_min`, which is the smallest possible
            slice.
        p1 : int | None
            The end of the array. If ``None`` then `p_max(n)` is used.
        k_offset : int
            Index of first sample (t = 0) in `x`.
        padding : 'zeros' | 'edge' | 'even' | 'odd'
            Kind of values which are added, when the sliding window sticks out
            on either the lower or upper end of the input `x`. Zeros are added
            if the default 'zeros' is set. For 'edge' either the first or the
            last value of `x` is used. 'even' pads by reflecting the
            signal on the first or last sample and 'odd' additionally
            multiplies it with -1.
        axis : int
            The axis of `x` over which to compute the STFT.
            If not given, the last axis is used.

        Returns
        -------
        S_xy : np.ndarray
            A real-valued array with non-negative values is returned, if ``x is y`` or
            `y` is ``None``. The dimension is always by one larger than of `x`. The
            last axis always represents the time slices of the spectrogram. `axis`
            defines the frequency axis (default second to last). E.g., for a
            one-dimensional `x`, a complex 2d array is returned, with axis 0
            representing frequency and axis 1 the time slices.

        Notes
        -----
        The cross-spectrogram may be interpreted as the time-frequency analogon of the
        cross-spectral density (consult `csd`). The absolute square `|Sxy|²` of a
        cross-spectrogram `Sxy` divided by the spectrograms `Sxx` and `Syy` can be
        interpreted as a coherence spectrogram ``Cxy := abs(Sxy)**2 / (Sxx*Syy)``,
        which is the time-frequency analogon to `~coherence`.

        If the STFT is parametrized to be a unitary transform, i.e., utilitzing
        `~from_win_equals_dual`, then the value of the scalar product, hence also the
        energy, is preserved.

        Examples
        --------
        The following example shows the spectrogram of a square wave with varying
        frequency :math:`f_i(t)` (marked by a green dashed line in the plot) sampled
        with 20 Hz. The utilized Gaussian window is 50 samples or 2.5 s long. For the
        `ShortTimeFFT`, the parameter ``mfft=800`` (oversampling factor 16) and the
        `hop` interval of 2 in was chosen to produce a sufficient number of points.

        The plot's colormap is logarithmically scaled as the power spectral
        density is in dB. The time extent of the signal `x` is marked by
        vertical dashed lines, and the shaded areas mark the presence of border
        effects.

        >>> import matplotlib.pyplot as plt
        >>> import numpy as np
        >>> from scipy.signal import square, ShortTimeFFT
        >>> from scipy.signal.windows import gaussian
        ...
        >>> T_x, N = 1 / 20, 1000  # 20 Hz sampling rate for 50 s signal
        >>> t_x = np.arange(N) * T_x  # time indexes for signal
        >>> f_i = 5e-3*(t_x - t_x[N // 3])**2 + 1  # varying frequency
        >>> x = square(2*np.pi*np.cumsum(f_i)*T_x)  # the signal
        ...
        >>> g_std = 12  # standard deviation for Gaussian window in samples
        >>> win = gaussian(50, std=g_std, sym=True)  # symmetric Gaussian wind.
        >>> SFT = ShortTimeFFT(win, hop=2, fs=1/T_x, mfft=800, scale_to='psd')
        >>> Sx2 = SFT.spectrogram(x)  # calculate absolute square of STFT
        ...
        >>> fig1, ax1 = plt.subplots(figsize=(6., 4.))  # enlarge plot a bit
        >>> t_lo, t_hi = SFT.extent(N)[:2]  # time range of plot
        >>> ax1.set_title(rf"Spectrogram ({SFT.m_num*SFT.T:g}$\,s$ Gaussian " +
        ...               rf"window, $\sigma_t={g_std*SFT.T:g}\,$s)")
        >>> ax1.set(xlabel=f"Time $t$ in seconds ({SFT.p_num(N)} slices, " +
        ...                rf"$\Delta t = {SFT.delta_t:g}\,$s)",
        ...         ylabel=f"Freq. $f$ in Hz ({SFT.f_pts} bins, " +
        ...                rf"$\Delta f = {SFT.delta_f:g}\,$Hz)",
        ...         xlim=(t_lo, t_hi))
        >>> Sx_dB = 10 * np.log10(np.fmax(Sx2, 1e-4))  # limit range to -40 dB
        >>> im1 = ax1.imshow(Sx_dB, origin='lower', aspect='auto',
        ...                  extent=SFT.extent(N), cmap='magma')
        >>> ax1.plot(t_x, f_i, 'g--', alpha=.5, label='$f_i(t)$')
        >>> fig1.colorbar(im1, label='Power Spectral Density ' +
        ...                          r"$20\,\log_{10}|S_x(t, f)|$ in dB")
        ...
        >>> # Shade areas where window slices stick out to the side:
        >>> for t0_, t1_ in [(t_lo, SFT.lower_border_end[0] * SFT.T),
        ...                  (SFT.upper_border_begin(N)[0] * SFT.T, t_hi)]:
        ...     ax1.axvspan(t0_, t1_, color='w', linewidth=0, alpha=.3)
        >>> for t_ in [0, N * SFT.T]:  # mark signal borders with vertical line
        ...     ax1.axvline(t_, color='c', linestyle='--', alpha=0.5)
        >>> ax1.legend()
        >>> fig1.tight_layout()
        >>> plt.show()

        The logarithmic scaling reveals the odd harmonics of the square wave,
        which are reflected at the Nyquist frequency of 10 Hz. This aliasing
        is also the main source of the noise artifacts in the plot.

        See Also
        --------
        :meth:`~ShortTimeFFT.stft`: Perform the short-time Fourier transform.
        stft_detrend: STFT with a trend subtracted from each segment.
        :class:`scipy.signal.ShortTimeFFT`: Class this method belongs to.
        """
        ...
    
    @property
    def dual_win(self) -> np.ndarray:
        """Dual window (canonical dual window by default).

        A STFT can be interpreted as the input signal being expressed as a
        weighted sum of modulated and time-shifted dual windows. If no dual window is
        given on instantiation, the canonical dual window, i.e., the window with the
        minimal energy (i.e., minimal L²-norm) is calculated. Alternative means for
        determining dual windows are provided by `closest_STFT_dual_window` and the
        `from_win_equals_dual` class-method. Note that `win` is also always a
        dual window of `dual_win`.

        `dual_win` has same length as `win`, namely `m_num` samples.

        If the dual window cannot be calculated a ``ValueError`` is raised.
        This attribute is read only and calculated lazily.
        To make this array immutable, its WRITEABLE flag is set to ``FALSE``.

        See Also
        --------
        m_num: Number of samples in window `win` and `dual_win`.
        win: Window function as real- or complex-valued 1d array.
        from_win_equals_dual: Create instance where `win` and `dual_win` are equal.
        closest_STFT_dual_window: Calculate dual window closest to a desired window.
        numpy.ndarray.setflags: Modify array flags.
        ShortTimeFFT: Class this property belongs to.
        """
        ...
    
    @property
    def invertible(self) -> bool:
        """Check if STFT is invertible.

        This is achieved by trying to calculate the canonical dual window.

        See Also
        --------
        :meth:`~ShortTimeFFT.istft`: Inverse short-time Fourier transform.
        m_num: Number of samples in window `win` and `dual_win`.
        dual_win: Dual window.
        win: Window for STFT.
        ShortTimeFFT: Class this property belongs to.
        """
        ...
    
    def istft(self, S: np.ndarray, k0: int = ..., k1: int | None = ..., *, f_axis: int = ..., t_axis: int = ...) -> np.ndarray:
        """Inverse short-time Fourier transform.

        It returns an array of dimension ``S.ndim - 1``  which is real
        if `onesided_fft` is set, else complex. If the STFT is not
        `invertible`, or the parameters are out of bounds  a ``ValueError`` is
        raised.

        Parameters
        ----------
        S
            A complex valued array where `f_axis` denotes the frequency
            values and the `t-axis` dimension the temporal values of the
            STFT values.
        k0, k1
            The start and the end index of the reconstructed signal. The
            default (``k0 = 0``, ``k1 = None``) assumes that the maximum length
            signal should be reconstructed.
        f_axis, t_axis
            The axes in `S` denoting the frequency and the time dimension.

        Notes
        -----
        It is required that `S` has `f_pts` entries along the `f_axis`. For
        the `t_axis` it is assumed that the first entry corresponds to
        `p_min` * `delta_t` (being <= 0). The length of `t_axis` needs to be
        compatible with `k1`. I.e., ``S.shape[t_axis] >= self.p_max(k1)`` must
        hold, if `k1` is not ``None``. Else `k1` is set to `k_max` with::

            q_max = S.shape[t_range] + self.p_min
            k_max = (q_max - 1) * self.hop + self.m_num - self.m_num_mid

        The :ref:`tutorial_stft` section of the :ref:`user_guide` discussed the
        slicing behavior by means of an example.

        See Also
        --------
        invertible: Check if STFT is invertible.
        :meth:`~ShortTimeFFT.stft`: Perform Short-time Fourier transform.
        :class:`scipy.signal.ShortTimeFFT`: Class this method belongs to.
        """
        ...
    
    @property
    def fac_magnitude(self) -> float:
        """Factor to multiply the STFT values by to scale each frequency slice
        to a magnitude spectrum.

        It is 1 if attribute ``scaling == 'magnitude'``.
        The window can be scaled to a magnitude spectrum by using the method
        `scale_to`.

        See Also
        --------
        fac_psd: Scaling factor for to a power spectral density spectrum.
        scale_to: Scale window to obtain 'magnitude' or 'psd' scaling.
        scaling: Normalization applied to the window function.
        ShortTimeFFT: Class this property belongs to.
        """
        ...
    
    @property
    def fac_psd(self) -> float:
        """Factor to multiply the STFT values by to scale each frequency slice
        to a power spectral density (PSD).

        It is 1 if attribute ``scaling == 'psd'``.
        The window can be scaled to a psd spectrum by using the method
        `scale_to`.

        See Also
        --------
        fac_magnitude: Scaling factor for to a magnitude spectrum.
        scale_to: Scale window to obtain 'magnitude' or 'psd' scaling.
        scaling: Normalization applied to the window function.
        ShortTimeFFT: Class this property belongs to.
        """
        ...
    
    @property
    def m_num(self) -> int:
        """Number of samples in window `win`.

        Note that the FFT can be oversampled by zero-padding. This is achieved
        by setting the `mfft` property.

        See Also
        --------
        m_num_mid: Center index of window `win`.
        mfft: Length of input for the FFT used - may be larger than `m_num`.
        hop: Time increment in signal samples for sliding window.
        win: Window function as real- or complex-valued 1d array.
        ShortTimeFFT: Class this property belongs to.
        """
        ...
    
    @property
    def m_num_mid(self) -> int:
        """Center index of window `win`.

        For odd `m_num`, ``(m_num - 1) / 2`` is returned and
        for even `m_num` (per definition) ``m_num / 2`` is returned.

        See Also
        --------
        m_num: Number of samples in window `win`.
        mfft: Length of input for the FFT used - may be larger than `m_num`.
        hop: ime increment in signal samples for sliding window.
        win: Window function as real- or complex-valued 1d array.
        ShortTimeFFT: Class this property belongs to.
        """
        ...
    
    @property
    def k_min(self) -> int:
        """The smallest possible signal index of the STFT.

        `k_min` is the index of the left-most non-zero value of the lowest
        slice `p_min`. Since the zeroth slice is centered over the zeroth
        sample of the input signal, `k_min` is never positive.
        A detailed example is provided in the :ref:`tutorial_stft_sliding_win`
        section of the :ref:`user_guide`.

        See Also
        --------
        k_max: First sample index after signal end not touched by a time slice.
        lower_border_end: Where pre-padding effects end.
        p_min: The smallest possible slice index.
        p_max: Index of first non-overlapping upper time slice.
        p_num: Number of time slices, i.e., `p_max` - `p_min`.
        p_range: Determine and validate slice index range.
        upper_border_begin: Where post-padding effects start.
        ShortTimeFFT: Class this property belongs to.
        """
        ...
    
    @property
    def p_min(self) -> int:
        """The smallest possible slice index.

        `p_min` is the index of the left-most slice, where the window still
        sticks into the signal, i.e., has non-zero part for t >= 0.
        `k_min` is the smallest index where the window function of the slice
        `p_min` is non-zero.

        Since, per convention the zeroth slice is centered at t=0,
        `p_min` <= 0 always holds.
        A detailed example is provided in the :ref:`tutorial_stft_sliding_win`
        section of the :ref:`user_guide`.

        See Also
        --------
        k_min: The smallest possible signal index.
        k_max: First sample index after signal end not touched by a time slice.
        p_max: Index of first non-overlapping upper time slice.
        p_num: Number of time slices, i.e., `p_max` - `p_min`.
        p_range: Determine and validate slice index range.
        ShortTimeFFT: Class this property belongs to.
        """
        ...
    
    def k_max(self, n: int) -> int:
        """First sample index after signal end not touched by a time slice.

        `k_max` - 1 is the largest sample index of the slice `p_max` - 1 for a
        given input signal of `n` samples.
        A detailed example is provided in the :ref:`tutorial_stft_sliding_win`
        section of the :ref:`user_guide`.

        Parameters
        ----------
        n : int
            Number of samples of input signal (must be ≥ half of the window length).

        See Also
        --------
        k_min: The smallest possible signal index.
        p_min: The smallest possible slice index.
        p_max: Index of first non-overlapping upper time slice.
        p_num: Number of time slices, i.e., `p_max` - `p_min`.
        p_range: Determine and validate slice index range.
        ShortTimeFFT: Class this method belongs to.
        """
        ...
    
    def p_max(self, n: int) -> int:
        """Index of first non-overlapping upper time slice for `n` sample
        input.

        Note that center point t[p_max] = (p_max(n)-1) * `delta_t` is typically
        larger than last time index t[n-1] == (`n`-1) * `T`. The upper border
        of samples indexes covered by the window slices is given by `k_max`.
        Furthermore, `p_max` does not denote the number of slices `p_num` since
        `p_min` is typically less than zero.
        A detailed example is provided in the :ref:`tutorial_stft_sliding_win`
        section of the :ref:`user_guide`.

        See Also
        --------
        k_min: The smallest possible signal index.
        k_max: First sample index after signal end not touched by a time slice.
        p_min: The smallest possible slice index.
        p_num: Number of time slices, i.e., `p_max` - `p_min`.
        p_range: Determine and validate slice index range.
        ShortTimeFFT: Class this method belongs to.
        """
        ...
    
    def p_num(self, n: int) -> int:
        """Number of time slices for an input signal with `n` samples.

        It is given by `p_num` = `p_max` - `p_min` with `p_min` typically
        being negative.
        A detailed example is provided in the :ref:`tutorial_stft_sliding_win`
        section of the :ref:`user_guide`.

        See Also
        --------
        k_min: The smallest possible signal index.
        k_max: First sample index after signal end not touched by a time slice.
        lower_border_end: Where pre-padding effects end.
        p_min: The smallest possible slice index.
        p_max: Index of first non-overlapping upper time slice.
        p_range: Determine and validate slice index range.
        upper_border_begin: Where post-padding effects start.
        ShortTimeFFT: Class this method belongs to.
        """
        ...
    
    @property
    def lower_border_end(self) -> tuple[int, int]:
        """First signal index and first slice index unaffected by pre-padding.

        Describes the point where the window does not stick out to the left
        of the signal domain.
        A detailed example is provided in the :ref:`tutorial_stft_sliding_win`
        section of the :ref:`user_guide`.

        See Also
        --------
        k_min: The smallest possible signal index.
        k_max: First sample index after signal end not touched by a time slice.
        lower_border_end: Where pre-padding effects end.
        p_min: The smallest possible slice index.
        p_max: Index of first non-overlapping upper time slice.
        p_num: Number of time slices, i.e., `p_max` - `p_min`.
        p_range: Determine and validate slice index range.
        upper_border_begin: Where post-padding effects start.
        ShortTimeFFT: Class this property belongs to.
        """
        ...
    
    def upper_border_begin(self, n: int) -> tuple[int, int]:
        """First signal index and first slice index affected by post-padding.

        Describes the point where the window does begin stick out to the right
        of the signal domain.
        A detailed example is given :ref:`tutorial_stft_sliding_win` section
        of the :ref:`user_guide`.

        Parameters
        ----------
        n : int
            Number of samples of input signal (must be ≥ half of the window length).

        Returns
        -------
        k_ub : int
            Lowest signal index, where a touching time slice sticks out past the
            signal end.
        p_ub : int
            Lowest index of time slice of which the end sticks out past the signal end.

        Notes
        -----
        Note that the return values are cached together with the parameter `n` to avoid
        unnecessary recalculations.

        See Also
        --------
        k_min: The smallest possible signal index.
        k_max: First sample index after signal end not touched by a time slice.
        lower_border_end: Where pre-padding effects end.
        p_min: The smallest possible slice index.
        p_max: Index of first non-overlapping upper time slice.
        p_num: Number of time slices, i.e., `p_max` - `p_min`.
        p_range: Determine and validate slice index range.
        ShortTimeFFT: Class this method belongs to.
        """
        ...
    
    @property
    def delta_t(self) -> float:
        """Time increment of STFT.

        The time increment `delta_t` = `T` * `hop` represents the sample
        increment `hop` converted to time based on the sampling interval `T`.

        See Also
        --------
        delta_f: Width of the frequency bins of the STFT.
        hop: Hop size in signal samples for sliding window.
        t: Times of STFT for an input signal with `n` samples.
        T: Sampling interval of input signal and window `win`.
        ShortTimeFFT: Class this property belongs to
        """
        ...
    
    def p_range(self, n: int, p0: int | None = ..., p1: int | None = ...) -> tuple[int, int]:
        """Determine and validate slice index range.

        Parameters
        ----------
        n : int
            Number of samples of input signal, assuming t[0] = 0.
        p0 : int | None
            First slice index. If 0 then the first slice is centered at t = 0.
            If ``None`` then `p_min` is used. Note that p0 may be < 0 if
            slices are left of t = 0.
        p1 : int | None
            End of interval (last value is p1-1).
            If ``None`` then `p_max(n)` is used.


        Returns
        -------
        p0_ : int
            The fist slice index
        p1_ : int
            End of interval (last value is p1-1).

        Notes
        -----
        A ``ValueError`` is raised if ``p_min <= p0 < p1 <= p_max(n)`` does not
        hold.

        See Also
        --------
        k_min: The smallest possible signal index.
        k_max: First sample index after signal end not touched by a time slice.
        lower_border_end: Where pre-padding effects end.
        p_min: The smallest possible slice index.
        p_max: Index of first non-overlapping upper time slice.
        p_num: Number of time slices, i.e., `p_max` - `p_min`.
        upper_border_begin: Where post-padding effects start.
        ShortTimeFFT: Class this property belongs to.
        """
        ...
    
    def t(self, n: int, p0: int | None = ..., p1: int | None = ..., k_offset: int = ...) -> np.ndarray:
        """Times of STFT for an input signal with `n` samples.

        Returns a 1d array with times of the `~ShortTimeFFT.stft` values with
        the same  parametrization. Note that the slices are
        ``delta_t = hop * T`` time units apart.

        Parameters
        ----------
        n
            Number of sample of the input signal.
        p0
            The first element of the range of slices to calculate. If ``None``
            then it is set to :attr:`p_min`, which is the smallest possible
            slice.
        p1
            The end of the array. If ``None`` then `p_max(n)` is used.
        k_offset
            Index of first sample (t = 0) in `x`.

        Notes
        -----
        Note that the returned array is cached together with the method's call
        parameters to avoid unnecessary recalculations.

        See Also
        --------
        delta_t: Time increment of STFT (``hop*T``)
        hop: Time increment in signal samples for sliding window.
        nearest_k_p: Nearest sample index k_p for which t[k_p] == t[p] holds.
        T: Sampling interval of input signal and of the window (``1/fs``).
        fs: Sampling frequency (being ``1/T``)
        ShortTimeFFT: Class this method belongs to.
        """
        ...
    
    def nearest_k_p(self, k: int, left: bool = ...) -> int:
        """Return nearest sample index k_p for which t[k_p] == t[p] holds.

        The nearest next smaller time sample p (where t[p] is the center
        position of the window of the p-th slice) is p_k = k // `hop`.
        If `hop` is a divisor of `k` then `k` is returned.
        If `left` is set then p_k * `hop` is returned else (p_k+1) * `hop`.

        This method can be used to slice an input signal into chunks for
        calculating the STFT and iSTFT incrementally.

        See Also
        --------
        delta_t: Time increment of STFT (``hop*T``)
        hop: Time increment in signal samples for sliding window.
        T: Sampling interval of input signal and of the window (``1/fs``).
        fs: Sampling frequency (being ``1/T``)
        t: Times of STFT for an input signal with `n` samples.
        ShortTimeFFT: Class this method belongs to.
        """
        ...
    
    @property
    def delta_f(self) -> float:
        """Width of the frequency bins of the STFT.

        Return the frequency interval `delta_f` = 1 / (`mfft` * `T`).

        See Also
        --------
        delta_t: Time increment of STFT.
        f_pts: Number of points along the frequency axis.
        f: Frequencies values of the STFT.
        mfft: Length of the input for FFT used.
        T: Sampling interval.
        t: Times of STFT for an input signal with `n` samples.
        ShortTimeFFT: Class this property belongs to.
        """
        ...
    
    @property
    def f_pts(self) -> int:
        """Number of points along the frequency axis.

        See Also
        --------
        delta_f: Width of the frequency bins of the STFT.
        f: Frequencies values of the STFT.
        mfft: Length of the input for FFT used.
        ShortTimeFFT: Class this property belongs to.
        """
        ...
    
    @property
    def onesided_fft(self) -> bool:
        """Return True if a one-sided FFT is used.

        Returns ``True`` if `fft_mode` is either 'onesided' or 'onesided2X'.

        See Also
        --------
        fft_mode: Utilized FFT ('twosided', 'centered', 'onesided' or
                 'onesided2X')
        ShortTimeFFT: Class this property belongs to.
        """
        ...
    
    @property
    def f(self) -> np.ndarray:
        """Frequencies values of the STFT.

        A 1d array of length `f_pts` with `delta_f` spaced entries is returned.
        This array is calculated lazily.

        See Also
        --------
        delta_f: Width of the frequency bins of the STFT.
        f_pts: Number of points along the frequency axis.
        mfft: Length of the input for FFT used.
        ShortTimeFFT: Class this property belongs to.
        """
        ...
    
    def extent(self, n: int, axes_seq: Literal['tf', 'ft'] = ..., center_bins: bool = ...) -> tuple[float, float, float, float]:
        """Return minimum and maximum values time-frequency values.

        A tuple with four floats  ``(t0, t1, f0, f1)`` for 'tf' and
        ``(f0, f1, t0, t1)`` for 'ft' is returned describing the corners
        of the time-frequency domain of the `~ShortTimeFFT.stft`.
        That tuple can be passed to `matplotlib.pyplot.imshow` as a parameter
        with the same name.

        Parameters
        ----------
        n : int
            Number of samples in input signal.
        axes_seq : {'tf', 'ft'}
            Return time extent first and then frequency extent or vice versa.
        center_bins: bool
            If set (default ``False``), the values of the time slots and
            frequency bins are moved from the side the middle. This is useful,
            when plotting the `~ShortTimeFFT.stft` values as step functions,
            i.e., with no interpolation.

        See Also
        --------
        :func:`matplotlib.pyplot.imshow`: Display data as an image.
        :class:`scipy.signal.ShortTimeFFT`: Class this method belongs to.

        Examples
        --------
        The following two plots illustrate the effect of the parameter `center_bins`:
        The grid lines represent the three time and the four frequency values of the
        STFT.
        The left plot, where ``(t0, t1, f0, f1) = (0, 3, 0, 4)`` is passed as parameter
        ``extent`` to `~matplotlib.pyplot.imshow`, shows the standard behavior of the
        time and frequency values being at the lower edge of the corrsponding bin.
        The right plot, with ``(t0, t1, f0, f1) = (-0.5, 2.5, -0.5, 3.5)``, shows that
        the bins are centered over the respective values when passing
        ``center_bins=True``.

        >>> import matplotlib.pyplot as plt
        >>> import numpy as np
        >>> from scipy.signal import ShortTimeFFT
        ...
        >>> n, m = 12, 6
        >>> SFT = ShortTimeFFT.from_window('hann', fs=m, nperseg=m, noverlap=0)
        >>> Sxx = SFT.stft(np.cos(np.arange(n)))  # produces a colorful plot
        ...
        >>> fig, axx = plt.subplots(1, 2, tight_layout=True, figsize=(6., 4.))
        >>> for ax_, center_bins in zip(axx, (False, True)):
        ...     ax_.imshow(abs(Sxx), origin='lower', interpolation=None, aspect='equal',
        ...                cmap='viridis', extent=SFT.extent(n, 'tf', center_bins))
        ...     ax_.set_title(f"{center_bins=}")
        ...     ax_.set_xlabel(f"Time ({SFT.p_num(n)} points, Δt={SFT.delta_t})")
        ...     ax_.set_ylabel(f"Frequency ({SFT.f_pts} points, Δf={SFT.delta_f})")
        ...     ax_.set_xticks(SFT.t(n))  # vertical grid line are timestamps
        ...     ax_.set_yticks(SFT.f)  # horizontal grid line are frequency values
        ...     ax_.grid(True)
        >>> plt.show()

        Note that the step-like behavior with the constant colors is caused by passing
        ``interpolation=None`` to `~matplotlib.pyplot.imshow`.
        """
        ...
    


