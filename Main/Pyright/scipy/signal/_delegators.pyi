"""
This type stub file was generated by pyright.
"""

"""Delegators for alternative backends in scipy.signal.

The signature of `func_signature` must match the signature of signal.func.
The job of a `func_signature` is to know which arguments of `signal.func`
are arrays.

* signatures are generated by

--------------
 import inspect
 from scipy import signal

 names = [x for x in dir(signal) if not x.startswith('_')]
 objs = [getattr(signal, name) for name in names]
 funcs = [obj for obj in objs if inspect.isroutine(obj)]

 for func in funcs:
     try:
        sig = inspect.signature(func)
     except ValueError:
         sig = "( FIXME )"
     print(f"def {func.__name__}_signature{sig}:\n\treturn array_namespace(...
 )\n\n")
---------------

* which arguments to delegate on: manually trawled the documentation for
  array-like and array arguments

"""
def abcd_normalize_signature(A=..., B=..., C=..., D=...): # -> ModuleType:
    ...

def argrelextrema_signature(data, *args, **kwds): # -> ModuleType:
    ...

argrelmax_signature = ...
argrelmin_signature = ...
def band_stop_obj_signature(wp, ind, passb, stopb, gpass, gstop, type): # -> ModuleType:
    ...

def bessel_signature(N, Wn, *args, **kwds): # -> ModuleType:
    ...

butter_signature = ...
def cheby2_signature(N, rs, Wn, *args, **kwds): # -> ModuleType:
    ...

def cheby1_signature(N, rp, Wn, *args, **kwds): # -> ModuleType:
    ...

def ellip_signature(N, rp, rs, Wn, *args, **kwds): # -> ModuleType:
    ...

def besselap_signature(N, norm=...): # -> Any:
    ...

def buttap_signature(N): # -> Any:
    ...

def cheb1ap_signature(N, rp): # -> Any:
    ...

def cheb2ap_signature(N, rs): # -> Any:
    ...

def ellipap_signature(N, rp, rs): # -> Any:
    ...

def correlation_lags_signature(in1_len, in2_len, mode=...): # -> Any:
    ...

def czt_points_signature(m, w=..., a=...): # -> Any:
    ...

def gammatone_signature(freq, ftype, order=..., numtaps=..., fs=...): # -> Any:
    ...

def iircomb_signature(w0, Q, ftype=..., fs=..., *, pass_zero=...): # -> Any:
    ...

def iirnotch_signature(w0, Q, fs=...): # -> Any:
    ...

def iirpeak_signature(w0, Q, fs=...): # -> Any:
    ...

def savgol_coeffs_signature(window_length, polyorder, deriv=..., delta=..., pos=..., use=...): # -> Any:
    ...

def unit_impulse_signature(shape, idx=..., dtype=...): # -> Any:
    ...

def buttord_signature(wp, ws, gpass, gstop, analog=..., fs=...): # -> Any:
    ...

def cheb1ord_signature(wp, ws, gpass, gstop, analog=..., fs=...): # -> Any:
    ...

def cheb2ord_signature(wp, ws, gpass, gstop, analog=..., fs=...): # -> Any:
    ...

def ellipord_signature(wp, ws, gpass, gstop, analog=..., fs=...): # -> Any:
    ...

def kaiser_atten_signature(numtaps, width): # -> Any:
    ...

def kaiser_beta_signature(a): # -> Any:
    ...

def kaiserord_signature(ripple, width): # -> Any:
    ...

def get_window_signature(window, Nx, fftbins=..., *, xp=..., device=...): # -> Any:
    ...

def bode_signature(system, w=..., n=...): # -> ModuleType:
    ...

dbode_signature = ...
def freqresp_signature(system, w=..., n=...): # -> ModuleType:
    ...

dfreqresp_signature = ...
def impulse_signature(system, X0=..., T=..., N=...): # -> ModuleType:
    ...

def dimpulse_signature(system, x0=..., t=..., n=...): # -> ModuleType:
    ...

def lsim_signature(system, U, T, X0=..., interp=...): # -> ModuleType:
    ...

def dlsim_signature(system, u, t=..., x0=...): # -> ModuleType:
    ...

def step_signature(system, X0=..., T=..., N=...): # -> ModuleType:
    ...

def dstep_signature(system, x0=..., t=..., n=...): # -> ModuleType:
    ...

def cont2discrete_signature(system, dt, method=..., alpha=...): # -> ModuleType:
    ...

def bilinear_signature(b, a, fs=...): # -> ModuleType:
    ...

def bilinear_zpk_signature(z, p, k, fs): # -> ModuleType:
    ...

def chirp_signature(t, *args, **kwds): # -> ModuleType:
    ...

def choose_conv_method_signature(in1, in2, *args, **kwds): # -> ModuleType:
    ...

def convolve_signature(in1, in2, *args, **kwds): # -> ModuleType:
    ...

fftconvolve_signature = ...
oaconvolve_signature = ...
correlate_signature = ...
correlate_signature = ...
convolve2d_signature = ...
correlate2d_signature = ...
def coherence_signature(x, y, fs=..., window=..., *args, **kwds): # -> ModuleType:
    ...

def csd_signature(x, y, fs=..., window=..., *args, **kwds): # -> ModuleType:
    ...

def periodogram_signature(x, fs=..., window=...): # -> ModuleType:
    ...

def welch_signature(x, fs=..., window=..., *args, **kwds): # -> ModuleType:
    ...

def spectrogram_signature(x, fs=..., window=..., *args, **kwds): # -> ModuleType:
    ...

def stft_signature(x, fs=..., window=..., *args, **kwds): # -> ModuleType:
    ...

def istft_signature(Zxx, fs=..., window=..., *args, **kwds): # -> ModuleType:
    ...

def resample_signature(x, num, t=..., axis=..., window=..., domain=...): # -> ModuleType:
    ...

def resample_poly_signature(x, up, down, axis=..., window=..., *args, **kwds): # -> ModuleType:
    ...

def check_COLA_signature(window, nperseg, noverlap, tol=...): # -> ModuleType:
    ...

def check_NOLA_signature(window, nperseg, noverlap, tol=...): # -> ModuleType:
    ...

def czt_signature(x, *args, **kwds): # -> ModuleType:
    ...

decimate_signature = ...
gauss_spline_signature = ...
def deconvolve_signature(signal, divisor): # -> ModuleType:
    ...

def detrend_signature(data, axis=..., type=..., bp=..., *args, **kwds): # -> ModuleType:
    ...

def filtfilt_signature(b, a, x, *args, **kwds): # -> ModuleType:
    ...

def lfilter_signature(b, a, x, axis=..., zi=...): # -> ModuleType:
    ...

def envelope_signature(z, *args, **kwds): # -> ModuleType:
    ...

def find_peaks_signature(x, height=..., threshold=..., distance=..., prominence=..., width=..., wlen=..., rel_height=..., plateau_size=...): # -> ModuleType:
    ...

def find_peaks_cwt_signature(vector, widths, wavelet=..., max_distances=..., *args, **kwds): # -> ModuleType:
    ...

def findfreqs_signature(num, den, N, kind=...): # -> ModuleType:
    ...

def firls_signature(numtaps, bands, desired, *, weight=..., fs=...): # -> ModuleType:
    ...

def firwin_signature(numtaps, cutoff, *args, **kwds): # -> Any | ModuleType:
    ...

def firwin2_signature(numtaps, freq, gain, *args, **kwds): # -> ModuleType:
    ...

def freqs_zpk_signature(z, p, k, worN, *args, **kwds): # -> ModuleType:
    ...

freqz_zpk_signature = ...
def freqs_signature(b, a, worN=..., *args, **kwds): # -> ModuleType:
    ...

freqz_signature = ...
def freqz_sos_signature(sos, worN=..., *args, **kwds): # -> ModuleType:
    ...

sosfreqz_signature = ...
def gausspulse_signature(t, *args, **kwds): # -> ModuleType:
    ...

def group_delay_signature(system, w=..., whole=..., fs=...): # -> ModuleType:
    ...

def hilbert_signature(x, N=..., axis=...): # -> ModuleType:
    ...

hilbert2_signature = ...
def iirdesign_signature(wp, ws, *args, **kwds): # -> ModuleType:
    ...

def iirfilter_signature(N, Wn, *args, **kwds): # -> ModuleType:
    ...

def invres_signature(r, p, k, tol=..., rtype=...): # -> ModuleType:
    ...

invresz_signature = ...
def lfilter_zi_signature(b, a): # -> ModuleType:
    ...

def sosfilt_zi_signature(sos): # -> ModuleType:
    ...

def remez_signature(numtaps, bands, desired, *, weight=..., **kwds): # -> ModuleType:
    ...

def lfiltic_signature(b, a, y, x=...): # -> ModuleType:
    ...

def lombscargle_signature(x, y, freqs, precenter=..., normalize=..., *, weights=..., floating_mean=...): # -> ModuleType:
    ...

def lp2bp_signature(b, a, *args, **kwds): # -> ModuleType:
    ...

lp2bs_signature = ...
lp2hp_signature = ...
lp2lp_signature = ...
tf2zpk_signature = ...
tf2sos_signature = ...
normalize_signature = ...
residue_signature = ...
residuez_signature = ...
def lp2bp_zpk_signature(z, p, k, *args, **kwds): # -> ModuleType:
    ...

lp2bs_zpk_signature = ...
lp2hp_zpk_signature = ...
lp2lp_zpk_signature = ...
def zpk2sos_signature(z, p, k, *args, **kwds): # -> ModuleType:
    ...

zpk2ss_signature = ...
zpk2tf_signature = ...
def max_len_seq_signature(nbits, state=..., length=..., taps=...): # -> ModuleType:
    ...

def medfilt_signature(volume, kernel_size=...): # -> ModuleType:
    ...

def medfilt2d_signature(input, kernel_size=...): # -> ModuleType:
    ...

def minimum_phase_signature(h, *args, **kwds): # -> ModuleType:
    ...

def order_filter_signature(a, domain, rank): # -> ModuleType:
    ...

def peak_prominences_signature(x, peaks, *args, **kwds): # -> ModuleType:
    ...

peak_widths_signature = ...
def place_poles_signature(A, B, poles, method=..., rtol=..., maxiter=...): # -> ModuleType:
    ...

def savgol_filter_signature(x, *args, **kwds): # -> ModuleType:
    ...

def sawtooth_signature(t, width=...): # -> ModuleType:
    ...

def sepfir2d_signature(input, hrow, hcol): # -> ModuleType:
    ...

def sos2tf_signature(sos): # -> ModuleType:
    ...

sos2zpk_signature = ...
def sosfilt_signature(sos, x, axis=..., zi=...): # -> ModuleType:
    ...

def sosfiltfilt_signature(sos, x, *args, **kwds): # -> ModuleType:
    ...

def spline_filter_signature(Iin, lmbda=...): # -> ModuleType:
    ...

def square_signature(t, duty=...): # -> ModuleType:
    ...

def ss2tf_signature(A, B, C, D, input=...): # -> ModuleType:
    ...

ss2zpk_signature = ...
def sweep_poly_signature(t, poly, phi=...): # -> ModuleType:
    ...

def symiirorder1_signature(signal, c0, z1, precision=...): # -> ModuleType:
    ...

def symiirorder2_signature(input, r, omega, precision=...): # -> ModuleType:
    ...

def cspline1d_signature(signal, *args, **kwds): # -> ModuleType:
    ...

qspline1d_signature = ...
cspline2d_signature = ...
qspline2d_signature = ...
def cspline1d_eval_signature(cj, newx, *args, **kwds): # -> ModuleType:
    ...

qspline1d_eval_signature = ...
def tf2ss_signature(num, den): # -> ModuleType:
    ...

def unique_roots_signature(p, tol=..., rtype=...): # -> ModuleType:
    ...

def upfirdn_signature(h, x, up=..., down=..., axis=..., mode=..., cval=...): # -> ModuleType:
    ...

def vectorstrength_signature(events, period): # -> ModuleType:
    ...

def wiener_signature(im, mysize=..., noise=...): # -> ModuleType:
    ...

def zoom_fft_signature(x, fn, m=..., *, fs=..., endpoint=..., axis=...): # -> ModuleType:
    ...

