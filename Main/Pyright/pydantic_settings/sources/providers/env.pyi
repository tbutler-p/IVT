"""
This type stub file was generated by pyright.
"""

from collections.abc import Mapping
from typing import Any, TYPE_CHECKING
from pydantic.fields import FieldInfo
from ..base import PydanticBaseEnvSettingsSource
from pydantic_settings.main import BaseSettings

if TYPE_CHECKING:
    ...
class EnvSettingsSource(PydanticBaseEnvSettingsSource):
    """
    Source class for loading settings values from environment variables.
    """
    def __init__(self, settings_cls: type[BaseSettings], case_sensitive: bool | None = ..., env_prefix: str | None = ..., env_nested_delimiter: str | None = ..., env_nested_max_split: int | None = ..., env_ignore_empty: bool | None = ..., env_parse_none_str: str | None = ..., env_parse_enums: bool | None = ...) -> None:
        ...
    
    def get_field_value(self, field: FieldInfo, field_name: str) -> tuple[Any, str, bool]:
        """
        Gets the value for field from environment variables and a flag to determine whether value is complex.

        Args:
            field: The field.
            field_name: The field name.

        Returns:
            A tuple that contains the value (`None` if not found), key, and
                a flag to determine whether value is complex.
        """
        ...
    
    def prepare_field_value(self, field_name: str, field: FieldInfo, value: Any, value_is_complex: bool) -> Any:
        """
        Prepare value for the field.

        * Extract value for nested field.
        * Deserialize value to python object for complex field.

        Args:
            field: The field.
            field_name: The field name.

        Returns:
            A tuple contains prepared value for the field.

        Raises:
            ValuesError: When There is an error in deserializing value for complex field.
        """
        ...
    
    def next_field(self, field: FieldInfo | Any | None, key: str, case_sensitive: bool | None = ...) -> FieldInfo | None:
        """
        Find the field in a sub model by key(env name)

        By having the following models:

            ```py
            class SubSubModel(BaseSettings):
                dvals: Dict

            class SubModel(BaseSettings):
                vals: list[str]
                sub_sub_model: SubSubModel

            class Cfg(BaseSettings):
                sub_model: SubModel
            ```

        Then:
            next_field(sub_model, 'vals') Returns the `vals` field of `SubModel` class
            next_field(sub_model, 'sub_sub_model') Returns `sub_sub_model` field of `SubModel` class

        Args:
            field: The field.
            key: The key (env name).
            case_sensitive: Whether to search for key case sensitively.

        Returns:
            Field if it finds the next field otherwise `None`.
        """
        ...
    
    def explode_env_vars(self, field_name: str, field: FieldInfo, env_vars: Mapping[str, str | None]) -> dict[str, Any]:
        """
        Process env_vars and extract the values of keys containing env_nested_delimiter into nested dictionaries.

        This is applied to a single field, hence filtering by env_var prefix.

        Args:
            field_name: The field name.
            field: The field.
            env_vars: Environment variables.

        Returns:
            A dictionary contains extracted values from nested env values.
        """
        ...
    
    def __repr__(self) -> str:
        ...
    


__all__ = ['EnvSettingsSource']
