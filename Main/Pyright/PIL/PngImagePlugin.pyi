"""
This type stub file was generated by pyright.
"""

from collections.abc import Callable
from enum import IntEnum
from typing import Any, IO, NamedTuple, NoReturn
from . import Image, ImageFile

TYPE_CHECKING = ...
if TYPE_CHECKING:
    ...
logger = ...
is_cid = ...
_MAGIC = ...
_MODES = ...
_simple_palette = ...
MAX_TEXT_CHUNK = ...
MAX_TEXT_MEMORY = ...
class Disposal(IntEnum):
    OP_NONE = ...
    OP_BACKGROUND = ...
    OP_PREVIOUS = ...


class Blend(IntEnum):
    OP_SOURCE = ...
    OP_OVER = ...


class ChunkStream:
    def __init__(self, fp: IO[bytes]) -> None:
        ...
    
    def read(self) -> tuple[bytes, int, int]:
        """Fetch a new chunk. Returns header information."""
        ...
    
    def __enter__(self) -> ChunkStream:
        ...
    
    def __exit__(self, *args: object) -> None:
        ...
    
    def close(self) -> None:
        ...
    
    def push(self, cid: bytes, pos: int, length: int) -> None:
        ...
    
    def call(self, cid: bytes, pos: int, length: int) -> bytes:
        """Call the appropriate chunk handler"""
        ...
    
    def crc(self, cid: bytes, data: bytes) -> None:
        """Read and verify checksum"""
        ...
    
    def crc_skip(self, cid: bytes, data: bytes) -> None:
        """Read checksum"""
        ...
    
    def verify(self, endchunk: bytes = ...) -> list[bytes]:
        ...
    


class iTXt(str):
    """
    Subclass of string to allow iTXt chunks to look like strings while
    keeping their extra information

    """
    lang: str | bytes | None
    tkey: str | bytes | None
    @staticmethod
    def __new__(cls, text: str, lang: str | None = ..., tkey: str | None = ...) -> iTXt:
        """
        :param cls: the class to use when creating the instance
        :param text: value for this key
        :param lang: language code
        :param tkey: UTF-8 version of the key name
        """
        ...
    


class PngInfo:
    """
    PNG chunk container (for use with save(pnginfo=))

    """
    def __init__(self) -> None:
        ...
    
    def add(self, cid: bytes, data: bytes, after_idat: bool = ...) -> None:
        """Appends an arbitrary chunk. Use with caution.

        :param cid: a byte string, 4 bytes long.
        :param data: a byte string of the encoded data
        :param after_idat: for use with private chunks. Whether the chunk
                           should be written after IDAT

        """
        ...
    
    def add_itxt(self, key: str | bytes, value: str | bytes, lang: str | bytes = ..., tkey: str | bytes = ..., zip: bool = ...) -> None:
        """Appends an iTXt chunk.

        :param key: latin-1 encodable text key name
        :param value: value for this key
        :param lang: language code
        :param tkey: UTF-8 version of the key name
        :param zip: compression flag

        """
        ...
    
    def add_text(self, key: str | bytes, value: str | bytes | iTXt, zip: bool = ...) -> None:
        """Appends a text chunk.

        :param key: latin-1 encodable text key name
        :param value: value for this key, text or an
           :py:class:`PIL.PngImagePlugin.iTXt` instance
        :param zip: compression flag

        """
        ...
    


class _RewindState(NamedTuple):
    info: dict[str | tuple[int, int], Any]
    tile: list[ImageFile._Tile]
    seq_num: int | None
    ...


class PngStream(ChunkStream):
    def __init__(self, fp: IO[bytes]) -> None:
        ...
    
    def check_text_memory(self, chunklen: int) -> None:
        ...
    
    def save_rewind(self) -> None:
        ...
    
    def rewind(self) -> None:
        ...
    
    def chunk_iCCP(self, pos: int, length: int) -> bytes:
        ...
    
    def chunk_IHDR(self, pos: int, length: int) -> bytes:
        ...
    
    def chunk_IDAT(self, pos: int, length: int) -> NoReturn:
        ...
    
    def chunk_IEND(self, pos: int, length: int) -> NoReturn:
        ...
    
    def chunk_PLTE(self, pos: int, length: int) -> bytes:
        ...
    
    def chunk_tRNS(self, pos: int, length: int) -> bytes:
        ...
    
    def chunk_gAMA(self, pos: int, length: int) -> bytes:
        ...
    
    def chunk_cHRM(self, pos: int, length: int) -> bytes:
        ...
    
    def chunk_sRGB(self, pos: int, length: int) -> bytes:
        ...
    
    def chunk_pHYs(self, pos: int, length: int) -> bytes:
        ...
    
    def chunk_tEXt(self, pos: int, length: int) -> bytes:
        ...
    
    def chunk_zTXt(self, pos: int, length: int) -> bytes:
        ...
    
    def chunk_iTXt(self, pos: int, length: int) -> bytes:
        ...
    
    def chunk_eXIf(self, pos: int, length: int) -> bytes:
        ...
    
    def chunk_acTL(self, pos: int, length: int) -> bytes:
        ...
    
    def chunk_fcTL(self, pos: int, length: int) -> bytes:
        ...
    
    def chunk_fdAT(self, pos: int, length: int) -> bytes:
        ...
    


class PngImageFile(ImageFile.ImageFile):
    format = ...
    format_description = ...
    @property
    def text(self) -> dict[str, str | iTXt]:
        ...
    
    def verify(self) -> None:
        """Verify PNG file"""
        ...
    
    def seek(self, frame: int) -> None:
        ...
    
    def tell(self) -> int:
        ...
    
    def load_prepare(self) -> None:
        """internal: prepare to read PNG file"""
        ...
    
    def load_read(self, read_bytes: int) -> bytes:
        """internal: read more image data"""
        ...
    
    def load_end(self) -> None:
        """internal: finished reading image data"""
        ...
    
    def getexif(self) -> Image.Exif:
        ...
    


_OUTMODES = ...
def putchunk(fp: IO[bytes], cid: bytes, *data: bytes) -> None:
    """Write a PNG chunk (including CRC field)"""
    ...

class _idat:
    def __init__(self, fp: IO[bytes], chunk: Callable[..., None]) -> None:
        ...
    
    def write(self, data: bytes) -> None:
        ...
    


class _fdat:
    def __init__(self, fp: IO[bytes], chunk: Callable[..., None], seq_num: int) -> None:
        ...
    
    def write(self, data: bytes) -> None:
        ...
    


class _Frame(NamedTuple):
    im: Image.Image
    bbox: tuple[int, int, int, int] | None
    encoderinfo: dict[str, Any]
    ...


def getchunks(im: Image.Image, **params: Any) -> list[tuple[bytes, bytes, bytes]]:
    """Return a list of PNG chunks representing this image."""
    ...

