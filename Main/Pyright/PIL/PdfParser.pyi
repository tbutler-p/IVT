"""
This type stub file was generated by pyright.
"""

import collections
import mmap
import time
from typing import Any, IO, NamedTuple, Union

def encode_text(s: str) -> bytes:
    ...

PDFDocEncoding = ...
def decode_text(b: bytes) -> str:
    ...

class PdfFormatError(RuntimeError):
    """An error that probably indicates a syntactic or semantic error in the
    PDF file structure"""
    ...


def check_format_condition(condition: bool, error_message: str) -> None:
    ...

class IndirectReferenceTuple(NamedTuple):
    object_id: int
    generation: int
    ...


class IndirectReference(IndirectReferenceTuple):
    def __str__(self) -> str:
        ...
    
    def __bytes__(self) -> bytes:
        ...
    
    def __eq__(self, other: object) -> bool:
        ...
    
    def __ne__(self, other: object) -> bool:
        ...
    
    def __hash__(self) -> int:
        ...
    


class IndirectObjectDef(IndirectReference):
    def __str__(self) -> str:
        ...
    


class XrefTable:
    def __init__(self) -> None:
        ...
    
    def __setitem__(self, key: int, value: tuple[int, int]) -> None:
        ...
    
    def __getitem__(self, key: int) -> tuple[int, int]:
        ...
    
    def __delitem__(self, key: int) -> None:
        ...
    
    def __contains__(self, key: int) -> bool:
        ...
    
    def __len__(self) -> int:
        ...
    
    def keys(self) -> set[int]:
        ...
    
    def write(self, f: IO[bytes]) -> int:
        ...
    


class PdfName:
    name: bytes
    def __init__(self, name: PdfName | bytes | str) -> None:
        ...
    
    def name_as_str(self) -> str:
        ...
    
    def __eq__(self, other: object) -> bool:
        ...
    
    def __hash__(self) -> int:
        ...
    
    def __repr__(self) -> str:
        ...
    
    @classmethod
    def from_pdf_stream(cls, data: bytes) -> PdfName:
        ...
    
    allowed_chars = ...
    def __bytes__(self) -> bytes:
        ...
    


class PdfArray(list[Any]):
    def __bytes__(self) -> bytes:
        ...
    


TYPE_CHECKING = ...
if TYPE_CHECKING:
    _DictBase = collections.UserDict[Union[str, bytes], Any]
else:
    ...
class PdfDict(_DictBase):
    def __setattr__(self, key: str, value: Any) -> None:
        ...
    
    def __getattr__(self, key: str) -> str | time.struct_time:
        ...
    
    def __bytes__(self) -> bytes:
        ...
    


class PdfBinary:
    def __init__(self, data: list[int] | bytes) -> None:
        ...
    
    def __bytes__(self) -> bytes:
        ...
    


class PdfStream:
    def __init__(self, dictionary: PdfDict, buf: bytes) -> None:
        ...
    
    def decode(self) -> bytes:
        ...
    


def pdf_repr(x: Any) -> bytes:
    ...

class PdfParser:
    """Based on
    https://www.adobe.com/content/dam/acom/en/devnet/acrobat/pdfs/PDF32000_2008.pdf
    Supports PDF up to 1.4
    """
    def __init__(self, filename: str | None = ..., f: IO[bytes] | None = ..., buf: bytes | bytearray | None = ..., start_offset: int = ..., mode: str = ...) -> None:
        ...
    
    def __enter__(self) -> PdfParser:
        ...
    
    def __exit__(self, *args: object) -> None:
        ...
    
    def start_writing(self) -> None:
        ...
    
    def close_buf(self) -> None:
        ...
    
    def close(self) -> None:
        ...
    
    def seek_end(self) -> None:
        ...
    
    def write_header(self) -> None:
        ...
    
    def write_comment(self, s: str) -> None:
        ...
    
    def write_catalog(self) -> IndirectReference:
        ...
    
    def rewrite_pages(self) -> None:
        ...
    
    def write_xref_and_trailer(self, new_root_ref: IndirectReference | None = ...) -> None:
        ...
    
    def write_page(self, ref: int | IndirectReference | None, *objs: Any, **dict_obj: Any) -> IndirectReference:
        ...
    
    def write_obj(self, ref: IndirectReference | None, *objs: Any, **dict_obj: Any) -> IndirectReference:
        ...
    
    def del_root(self) -> None:
        ...
    
    @staticmethod
    def get_buf_from_file(f: IO[bytes]) -> bytes | mmap.mmap:
        ...
    
    def read_pdf_info(self) -> None:
        ...
    
    def next_object_id(self, offset: int | None = ...) -> IndirectReference:
        ...
    
    delimiter = ...
    delimiter_or_ws = ...
    whitespace = ...
    whitespace_or_hex = ...
    whitespace_optional = ...
    whitespace_mandatory = ...
    whitespace_optional_no_nl = ...
    newline_only = ...
    newline = ...
    re_trailer_end = ...
    re_trailer_prev = ...
    def read_trailer(self) -> None:
        ...
    
    def read_prev_trailer(self, xref_section_offset: int) -> None:
        ...
    
    re_whitespace_optional = ...
    re_name = ...
    re_dict_start = ...
    re_dict_end = ...
    @classmethod
    def interpret_trailer(cls, trailer_data: bytes) -> dict[bytes, Any]:
        ...
    
    re_hashes_in_name = ...
    @classmethod
    def interpret_name(cls, raw: bytes, as_text: bool = ...) -> str | bytes:
        ...
    
    re_null = ...
    re_true = ...
    re_false = ...
    re_int = ...
    re_real = ...
    re_array_start = ...
    re_array_end = ...
    re_string_hex = ...
    re_string_lit = ...
    re_indirect_reference = ...
    re_indirect_def_start = ...
    re_indirect_def_end = ...
    re_comment = ...
    re_stream_start = ...
    re_stream_end = ...
    @classmethod
    def get_value(cls, data: bytes | bytearray | mmap.mmap, offset: int, expect_indirect: IndirectReference | None = ..., max_nesting: int = ...) -> tuple[Any, int | None]:
        ...
    
    re_lit_str_token = ...
    escaped_chars = ...
    @classmethod
    def get_literal_string(cls, data: bytes | bytearray | mmap.mmap, offset: int) -> tuple[bytes, int]:
        ...
    
    re_xref_section_start = ...
    re_xref_subsection_start = ...
    re_xref_entry = ...
    def read_xref_table(self, xref_section_offset: int) -> int:
        ...
    
    def read_indirect(self, ref: IndirectReference, max_nesting: int = ...) -> Any:
        ...
    
    def linearize_page_tree(self, node: PdfDict | None = ...) -> list[IndirectReference]:
        ...
    


