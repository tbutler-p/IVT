"""
This type stub file was generated by pyright.
"""

import abc
from collections.abc import Sequence
from typing import Any, Callable
from . import _imaging
from ._typing import NumpyArray

TYPE_CHECKING = ...
if TYPE_CHECKING:
    ...
class Filter(abc.ABC):
    @abc.abstractmethod
    def filter(self, image: _imaging.ImagingCore) -> _imaging.ImagingCore:
        ...
    


class MultibandFilter(Filter):
    ...


class BuiltinFilter(MultibandFilter):
    filterargs: tuple[Any, ...]
    def filter(self, image: _imaging.ImagingCore) -> _imaging.ImagingCore:
        ...
    


class Kernel(BuiltinFilter):
    """
    Create a convolution kernel. This only supports 3x3 and 5x5 integer and floating
    point kernels.

    Kernels can only be applied to "L" and "RGB" images.

    :param size: Kernel size, given as (width, height). This must be (3,3) or (5,5).
    :param kernel: A sequence containing kernel weights. The kernel will be flipped
                   vertically before being applied to the image.
    :param scale: Scale factor. If given, the result for each pixel is divided by this
                  value. The default is the sum of the kernel weights.
    :param offset: Offset. If given, this value is added to the result, after it has
                   been divided by the scale factor.
    """
    name = ...
    def __init__(self, size: tuple[int, int], kernel: Sequence[float], scale: float | None = ..., offset: float = ...) -> None:
        ...
    


class RankFilter(Filter):
    """
    Create a rank filter.  The rank filter sorts all pixels in
    a window of the given size, and returns the ``rank``'th value.

    :param size: The kernel size, in pixels.
    :param rank: What pixel value to pick.  Use 0 for a min filter,
                 ``size * size / 2`` for a median filter, ``size * size - 1``
                 for a max filter, etc.
    """
    name = ...
    def __init__(self, size: int, rank: int) -> None:
        ...
    
    def filter(self, image: _imaging.ImagingCore) -> _imaging.ImagingCore:
        ...
    


class MedianFilter(RankFilter):
    """
    Create a median filter. Picks the median pixel value in a window with the
    given size.

    :param size: The kernel size, in pixels.
    """
    name = ...
    def __init__(self, size: int = ...) -> None:
        ...
    


class MinFilter(RankFilter):
    """
    Create a min filter.  Picks the lowest pixel value in a window with the
    given size.

    :param size: The kernel size, in pixels.
    """
    name = ...
    def __init__(self, size: int = ...) -> None:
        ...
    


class MaxFilter(RankFilter):
    """
    Create a max filter.  Picks the largest pixel value in a window with the
    given size.

    :param size: The kernel size, in pixels.
    """
    name = ...
    def __init__(self, size: int = ...) -> None:
        ...
    


class ModeFilter(Filter):
    """
    Create a mode filter. Picks the most frequent pixel value in a box with the
    given size.  Pixel values that occur only once or twice are ignored; if no
    pixel value occurs more than twice, the original pixel value is preserved.

    :param size: The kernel size, in pixels.
    """
    name = ...
    def __init__(self, size: int = ...) -> None:
        ...
    
    def filter(self, image: _imaging.ImagingCore) -> _imaging.ImagingCore:
        ...
    


class GaussianBlur(MultibandFilter):
    """Blurs the image with a sequence of extended box filters, which
    approximates a Gaussian kernel. For details on accuracy see
    <https://www.mia.uni-saarland.de/Publications/gwosdek-ssvm11.pdf>

    :param radius: Standard deviation of the Gaussian kernel. Either a sequence of two
                   numbers for x and y, or a single number for both.
    """
    name = ...
    def __init__(self, radius: float | Sequence[float] = ...) -> None:
        ...
    
    def filter(self, image: _imaging.ImagingCore) -> _imaging.ImagingCore:
        ...
    


class BoxBlur(MultibandFilter):
    """Blurs the image by setting each pixel to the average value of the pixels
    in a square box extending radius pixels in each direction.
    Supports float radius of arbitrary size. Uses an optimized implementation
    which runs in linear time relative to the size of the image
    for any radius value.

    :param radius: Size of the box in a direction. Either a sequence of two numbers for
                   x and y, or a single number for both.

                   Radius 0 does not blur, returns an identical image.
                   Radius 1 takes 1 pixel in each direction, i.e. 9 pixels in total.
    """
    name = ...
    def __init__(self, radius: float | Sequence[float]) -> None:
        ...
    
    def filter(self, image: _imaging.ImagingCore) -> _imaging.ImagingCore:
        ...
    


class UnsharpMask(MultibandFilter):
    """Unsharp mask filter.

    See Wikipedia's entry on `digital unsharp masking`_ for an explanation of
    the parameters.

    :param radius: Blur Radius
    :param percent: Unsharp strength, in percent
    :param threshold: Threshold controls the minimum brightness change that
      will be sharpened

    .. _digital unsharp masking: https://en.wikipedia.org/wiki/Unsharp_masking#Digital_unsharp_masking

    """
    name = ...
    def __init__(self, radius: float = ..., percent: int = ..., threshold: int = ...) -> None:
        ...
    
    def filter(self, image: _imaging.ImagingCore) -> _imaging.ImagingCore:
        ...
    


class BLUR(BuiltinFilter):
    name = ...
    filterargs = ...


class CONTOUR(BuiltinFilter):
    name = ...
    filterargs = ...


class DETAIL(BuiltinFilter):
    name = ...
    filterargs = ...


class EDGE_ENHANCE(BuiltinFilter):
    name = ...
    filterargs = ...


class EDGE_ENHANCE_MORE(BuiltinFilter):
    name = ...
    filterargs = ...


class EMBOSS(BuiltinFilter):
    name = ...
    filterargs = ...


class FIND_EDGES(BuiltinFilter):
    name = ...
    filterargs = ...


class SHARPEN(BuiltinFilter):
    name = ...
    filterargs = ...


class SMOOTH(BuiltinFilter):
    name = ...
    filterargs = ...


class SMOOTH_MORE(BuiltinFilter):
    name = ...
    filterargs = ...


class Color3DLUT(MultibandFilter):
    """Three-dimensional color lookup table.

    Transforms 3-channel pixels using the values of the channels as coordinates
    in the 3D lookup table and interpolating the nearest elements.

    This method allows you to apply almost any color transformation
    in constant time by using pre-calculated decimated tables.

    .. versionadded:: 5.2.0

    :param size: Size of the table. One int or tuple of (int, int, int).
                 Minimal size in any dimension is 2, maximum is 65.
    :param table: Flat lookup table. A list of ``channels * size**3``
                  float elements or a list of ``size**3`` channels-sized
                  tuples with floats. Channels are changed first,
                  then first dimension, then second, then third.
                  Value 0.0 corresponds lowest value of output, 1.0 highest.
    :param channels: Number of channels in the table. Could be 3 or 4.
                     Default is 3.
    :param target_mode: A mode for the result image. Should have not less
                        than ``channels`` channels. Default is ``None``,
                        which means that mode wouldn't be changed.
    """
    name = ...
    def __init__(self, size: int | tuple[int, int, int], table: Sequence[float] | Sequence[Sequence[int]] | NumpyArray, channels: int = ..., target_mode: str | None = ..., **kwargs: bool) -> None:
        ...
    
    @classmethod
    def generate(cls, size: int | tuple[int, int, int], callback: Callable[[float, float, float], tuple[float, ...]], channels: int = ..., target_mode: str | None = ...) -> Color3DLUT:
        """Generates new LUT using provided callback.

        :param size: Size of the table. Passed to the constructor.
        :param callback: Function with three parameters which correspond
                         three color channels. Will be called ``size**3``
                         times with values from 0.0 to 1.0 and should return
                         a tuple with ``channels`` elements.
        :param channels: The number of channels which should return callback.
        :param target_mode: Passed to the constructor of the resulting
                            lookup table.
        """
        ...
    
    def transform(self, callback: Callable[..., tuple[float, ...]], with_normals: bool = ..., channels: int | None = ..., target_mode: str | None = ...) -> Color3DLUT:
        """Transforms the table values using provided callback and returns
        a new LUT with altered values.

        :param callback: A function which takes old lookup table values
                         and returns a new set of values. The number
                         of arguments which function should take is
                         ``self.channels`` or ``3 + self.channels``
                         if ``with_normals`` flag is set.
                         Should return a tuple of ``self.channels`` or
                         ``channels`` elements if it is set.
        :param with_normals: If true, ``callback`` will be called with
                             coordinates in the color cube as the first
                             three arguments. Otherwise, ``callback``
                             will be called only with actual color values.
        :param channels: The number of channels in the resulting lookup table.
        :param target_mode: Passed to the constructor of the resulting
                            lookup table.
        """
        ...
    
    def __repr__(self) -> str:
        ...
    
    def filter(self, image: _imaging.ImagingCore) -> _imaging.ImagingCore:
        ...
    


