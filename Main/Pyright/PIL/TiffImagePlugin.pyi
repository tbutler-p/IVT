"""
This type stub file was generated by pyright.
"""

import io
from collections.abc import Iterator, MutableMapping
from fractions import Fraction
from numbers import Rational
from typing import Any, Callable, IO, NoReturn
from . import Image, ImageFile
from ._typing import Buffer, IntegralLike, StrOrBytesPath

TYPE_CHECKING = ...
if TYPE_CHECKING:
    ...
logger = ...
READ_LIBTIFF = ...
WRITE_LIBTIFF = ...
STRIP_SIZE = ...
II = ...
MM = ...
OSUBFILETYPE = ...
IMAGEWIDTH = ...
IMAGELENGTH = ...
BITSPERSAMPLE = ...
COMPRESSION = ...
PHOTOMETRIC_INTERPRETATION = ...
FILLORDER = ...
IMAGEDESCRIPTION = ...
STRIPOFFSETS = ...
SAMPLESPERPIXEL = ...
ROWSPERSTRIP = ...
STRIPBYTECOUNTS = ...
X_RESOLUTION = ...
Y_RESOLUTION = ...
PLANAR_CONFIGURATION = ...
RESOLUTION_UNIT = ...
TRANSFERFUNCTION = ...
SOFTWARE = ...
DATE_TIME = ...
ARTIST = ...
PREDICTOR = ...
COLORMAP = ...
TILEWIDTH = ...
TILELENGTH = ...
TILEOFFSETS = ...
TILEBYTECOUNTS = ...
SUBIFD = ...
EXTRASAMPLES = ...
SAMPLEFORMAT = ...
JPEGTABLES = ...
YCBCRSUBSAMPLING = ...
REFERENCEBLACKWHITE = ...
COPYRIGHT = ...
IPTC_NAA_CHUNK = ...
PHOTOSHOP_CHUNK = ...
ICCPROFILE = ...
EXIFIFD = ...
XMP = ...
JPEGQUALITY = ...
IMAGEJ_META_DATA_BYTE_COUNTS = ...
IMAGEJ_META_DATA = ...
COMPRESSION_INFO = ...
COMPRESSION_INFO_REV = ...
OPEN_INFO = ...
MAX_SAMPLESPERPIXEL = ...
PREFIXES = ...
if not getattr(Image.core, "libtiff_support_custom_tags", True):
    ...
_load_dispatch = ...
_write_dispatch = ...
class IFDRational(Rational):
    """Implements a rational class where 0/0 is a legal value to match
    the in the wild use of exif rationals.

    e.g., DigitalZoomRatio - 0.00/0.00  indicates that no digital zoom was used
    """
    __slots__ = ...
    def __init__(self, value: float | Fraction | IFDRational, denominator: int = ...) -> None:
        """
        :param value: either an integer numerator, a
        float/rational/other number, or an IFDRational
        :param denominator: Optional integer denominator
        """
        ...
    
    @property
    def numerator(self) -> IntegralLike:
        ...
    
    @property
    def denominator(self) -> int:
        ...
    
    def limit_rational(self, max_denominator: int) -> tuple[IntegralLike, int]:
        """

        :param max_denominator: Integer, the maximum denominator value
        :returns: Tuple of (numerator, denominator)
        """
        ...
    
    def __repr__(self) -> str:
        ...
    
    def __hash__(self) -> int:
        ...
    
    def __eq__(self, other: object) -> bool:
        ...
    
    def __getstate__(self) -> list[float | Fraction | IntegralLike]:
        ...
    
    def __setstate__(self, state: list[float | Fraction | IntegralLike]) -> None:
        ...
    
    __add__ = ...
    __radd__ = ...
    __sub__ = ...
    __rsub__ = ...
    __mul__ = ...
    __rmul__ = ...
    __truediv__ = ...
    __rtruediv__ = ...
    __floordiv__ = ...
    __rfloordiv__ = ...
    __mod__ = ...
    __rmod__ = ...
    __pow__ = ...
    __rpow__ = ...
    __pos__ = ...
    __neg__ = ...
    __abs__ = ...
    __trunc__ = ...
    __lt__ = ...
    __gt__ = ...
    __le__ = ...
    __ge__ = ...
    __bool__ = ...
    __ceil__ = ...
    __floor__ = ...
    __round__ = ...
    if hasattr(Fraction, "__int__"):
        __int__ = ...


_LoaderFunc = Callable[["ImageFileDirectory_v2", bytes, bool], Any]
if TYPE_CHECKING:
    _IFDv2Base = MutableMapping[int, Any]
else:
    ...
class ImageFileDirectory_v2(_IFDv2Base):
    """This class represents a TIFF tag directory.  To speed things up, we
    don't decode tags unless they're asked for.

    Exposes a dictionary interface of the tags in the directory::

        ifd = ImageFileDirectory_v2()
        ifd[key] = 'Some Data'
        ifd.tagtype[key] = TiffTags.ASCII
        print(ifd[key])
        'Some Data'

    Individual values are returned as the strings or numbers, sequences are
    returned as tuples of the values.

    The tiff metadata type of each item is stored in a dictionary of
    tag types in
    :attr:`~PIL.TiffImagePlugin.ImageFileDirectory_v2.tagtype`. The types
    are read from a tiff file, guessed from the type added, or added
    manually.

    Data Structures:

        * ``self.tagtype = {}``

          * Key: numerical TIFF tag number
          * Value: integer corresponding to the data type from
            :py:data:`.TiffTags.TYPES`

          .. versionadded:: 3.0.0

    'Internal' data structures:

        * ``self._tags_v2 = {}``

          * Key: numerical TIFF tag number
          * Value: decoded data, as tuple for multiple values

        * ``self._tagdata = {}``

          * Key: numerical TIFF tag number
          * Value: undecoded byte string from file

        * ``self._tags_v1 = {}``

          * Key: numerical TIFF tag number
          * Value: decoded data in the v1 format

    Tags will be found in the private attributes ``self._tagdata``, and in
    ``self._tags_v2`` once decoded.

    ``self.legacy_api`` is a value for internal use, and shouldn't be changed
    from outside code. In cooperation with
    :py:class:`~PIL.TiffImagePlugin.ImageFileDirectory_v1`, if ``legacy_api``
    is true, then decoded tags will be populated into both ``_tags_v1`` and
    ``_tags_v2``. ``_tags_v2`` will be used if this IFD is used in the TIFF
    save routine. Tags should be read from ``_tags_v1`` if
    ``legacy_api == true``.

    """
    _load_dispatch: dict[int, tuple[int, _LoaderFunc]] = ...
    _write_dispatch: dict[int, Callable[..., Any]] = ...
    def __init__(self, ifh: bytes = ..., prefix: bytes | None = ..., group: int | None = ...) -> None:
        """Initialize an ImageFileDirectory.

        To construct an ImageFileDirectory from a real file, pass the 8-byte
        magic header to the constructor.  To only set the endianness, pass it
        as the 'prefix' keyword argument.

        :param ifh: One of the accepted magic headers (cf. PREFIXES); also sets
              endianness.
        :param prefix: Override the endianness of the file.
        """
        ...
    
    prefix = ...
    offset = ...
    @property
    def legacy_api(self) -> bool:
        ...
    
    @legacy_api.setter
    def legacy_api(self, value: bool) -> NoReturn:
        ...
    
    def reset(self) -> None:
        ...
    
    def __str__(self) -> str:
        ...
    
    def named(self) -> dict[str, Any]:
        """
        :returns: dict of name|key: value

        Returns the complete tag dictionary, with named tags where possible.
        """
        ...
    
    def __len__(self) -> int:
        ...
    
    def __getitem__(self, tag: int) -> Any:
        ...
    
    def __contains__(self, tag: object) -> bool:
        ...
    
    def __setitem__(self, tag: int, value: Any) -> None:
        ...
    
    def __delitem__(self, tag: int) -> None:
        ...
    
    def __iter__(self) -> Iterator[int]:
        ...
    
    @_register_loader(1, 1)
    def load_byte(self, data: bytes, legacy_api: bool = ...) -> bytes:
        ...
    
    @_register_writer(1)
    def write_byte(self, data: bytes | int | IFDRational) -> bytes:
        ...
    
    @_register_loader(2, 1)
    def load_string(self, data: bytes, legacy_api: bool = ...) -> str:
        ...
    
    @_register_writer(2)
    def write_string(self, value: str | bytes | int) -> bytes:
        ...
    
    @_register_loader(5, 8)
    def load_rational(self, data: bytes, legacy_api: bool = ...) -> tuple[tuple[int, int] | IFDRational, ...]:
        ...
    
    @_register_writer(5)
    def write_rational(self, *values: IFDRational) -> bytes:
        ...
    
    @_register_loader(7, 1)
    def load_undefined(self, data: bytes, legacy_api: bool = ...) -> bytes:
        ...
    
    @_register_writer(7)
    def write_undefined(self, value: bytes | int | IFDRational) -> bytes:
        ...
    
    @_register_loader(10, 8)
    def load_signed_rational(self, data: bytes, legacy_api: bool = ...) -> tuple[tuple[int, int] | IFDRational, ...]:
        ...
    
    @_register_writer(10)
    def write_signed_rational(self, *values: IFDRational) -> bytes:
        ...
    
    def load(self, fp: IO[bytes]) -> None:
        ...
    
    def tobytes(self, offset: int = ...) -> bytes:
        ...
    
    def save(self, fp: IO[bytes]) -> int:
        ...
    


class ImageFileDirectory_v1(ImageFileDirectory_v2):
    """This class represents the **legacy** interface to a TIFF tag directory.

    Exposes a dictionary interface of the tags in the directory::

        ifd = ImageFileDirectory_v1()
        ifd[key] = 'Some Data'
        ifd.tagtype[key] = TiffTags.ASCII
        print(ifd[key])
        ('Some Data',)

    Also contains a dictionary of tag types as read from the tiff image file,
    :attr:`~PIL.TiffImagePlugin.ImageFileDirectory_v1.tagtype`.

    Values are returned as a tuple.

    ..  deprecated:: 3.0.0
    """
    def __init__(self, *args: Any, **kwargs: Any) -> None:
        ...
    
    tags = ...
    tagdata = ...
    tagtype: dict[int, int]
    @classmethod
    def from_v2(cls, original: ImageFileDirectory_v2) -> ImageFileDirectory_v1:
        """Returns an
        :py:class:`~PIL.TiffImagePlugin.ImageFileDirectory_v1`
        instance with the same data as is contained in the original
        :py:class:`~PIL.TiffImagePlugin.ImageFileDirectory_v2`
        instance.

        :returns: :py:class:`~PIL.TiffImagePlugin.ImageFileDirectory_v1`

        """
        ...
    
    def to_v2(self) -> ImageFileDirectory_v2:
        """Returns an
        :py:class:`~PIL.TiffImagePlugin.ImageFileDirectory_v2`
        instance with the same data as is contained in the original
        :py:class:`~PIL.TiffImagePlugin.ImageFileDirectory_v1`
        instance.

        :returns: :py:class:`~PIL.TiffImagePlugin.ImageFileDirectory_v2`

        """
        ...
    
    def __contains__(self, tag: object) -> bool:
        ...
    
    def __len__(self) -> int:
        ...
    
    def __iter__(self) -> Iterator[int]:
        ...
    
    def __setitem__(self, tag: int, value: Any) -> None:
        ...
    
    def __getitem__(self, tag: int) -> Any:
        ...
    


ImageFileDirectory = ImageFileDirectory_v1
class TiffImageFile(ImageFile.ImageFile):
    format = ...
    format_description = ...
    _close_exclusive_fp_after_loading = ...
    def __init__(self, fp: StrOrBytesPath | IO[bytes], filename: str | bytes | None = ...) -> None:
        ...
    
    @property
    def n_frames(self) -> int:
        ...
    
    def seek(self, frame: int) -> None:
        """Select a given frame as current image"""
        ...
    
    def tell(self) -> int:
        """Return the current frame number"""
        ...
    
    def get_photoshop_blocks(self) -> dict[int, dict[str, bytes]]:
        """
        Returns a dictionary of Photoshop "Image Resource Blocks".
        The keys are the image resource ID. For more information, see
        https://www.adobe.com/devnet-apps/photoshop/fileformatashtml/#50577409_pgfId-1037727

        :returns: Photoshop "Image Resource Blocks" in a dictionary.
        """
        ...
    
    def load(self) -> Image.core.PixelAccess | None:
        ...
    
    def load_prepare(self) -> None:
        ...
    
    def load_end(self) -> None:
        ...
    


SAVE_INFO = ...
class AppendingTiffWriter(io.BytesIO):
    fieldSizes = ...
    Tags = ...
    def __init__(self, fn: StrOrBytesPath | IO[bytes], new: bool = ...) -> None:
        ...
    
    def setup(self) -> None:
        ...
    
    def finalize(self) -> None:
        ...
    
    def newFrame(self) -> None:
        ...
    
    def __enter__(self) -> AppendingTiffWriter:
        ...
    
    def __exit__(self, *args: object) -> None:
        ...
    
    def tell(self) -> int:
        ...
    
    def seek(self, offset: int, whence: int = ...) -> int:
        """
        :param offset: Distance to seek.
        :param whence: Whether the distance is relative to the start,
                       end or current position.
        :returns: The resulting position, relative to the start.
        """
        ...
    
    def goToEnd(self) -> None:
        ...
    
    def setEndian(self, endian: str) -> None:
        ...
    
    def skipIFDs(self) -> None:
        ...
    
    def write(self, data: Buffer, /) -> int:
        ...
    
    def readShort(self) -> int:
        ...
    
    def readLong(self) -> int:
        ...
    
    def rewriteLastShortToLong(self, value: int) -> None:
        ...
    
    def rewriteLastShort(self, value: int) -> None:
        ...
    
    def rewriteLastLong(self, value: int) -> None:
        ...
    
    def writeShort(self, value: int) -> None:
        ...
    
    def writeLong(self, value: int) -> None:
        ...
    
    def close(self) -> None:
        ...
    
    def fixIFD(self) -> None:
        ...
    
    def fixOffsets(self, count: int, isShort: bool = ..., isLong: bool = ...) -> None:
        ...
    


