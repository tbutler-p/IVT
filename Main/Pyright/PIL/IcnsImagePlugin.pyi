"""
This type stub file was generated by pyright.
"""

from typing import IO
from . import Image, ImageFile

enable_jpeg2k = ...
if enable_jpeg2k:
    ...
MAGIC = ...
HEADERSIZE = ...
def nextheader(fobj: IO[bytes]) -> tuple[bytes, int]:
    ...

def read_32t(fobj: IO[bytes], start_length: tuple[int, int], size: tuple[int, int, int]) -> dict[str, Image.Image]:
    ...

def read_32(fobj: IO[bytes], start_length: tuple[int, int], size: tuple[int, int, int]) -> dict[str, Image.Image]:
    """
    Read a 32bit RGB icon resource.  Seems to be either uncompressed or
    an RLE packbits-like scheme.
    """
    ...

def read_mk(fobj: IO[bytes], start_length: tuple[int, int], size: tuple[int, int, int]) -> dict[str, Image.Image]:
    ...

def read_png_or_jpeg2000(fobj: IO[bytes], start_length: tuple[int, int], size: tuple[int, int, int]) -> dict[str, Image.Image]:
    ...

class IcnsFile:
    SIZES = ...
    def __init__(self, fobj: IO[bytes]) -> None:
        """
        fobj is a file-like object as an icns resource
        """
        ...
    
    def itersizes(self) -> list[tuple[int, int, int]]:
        ...
    
    def bestsize(self) -> tuple[int, int, int]:
        ...
    
    def dataforsize(self, size: tuple[int, int, int]) -> dict[str, Image.Image]:
        """
        Get an icon resource as {channel: array}.  Note that
        the arrays are bottom-up like windows bitmaps and will likely
        need to be flipped or transposed in some way.
        """
        ...
    
    def getimage(self, size: tuple[int, int] | tuple[int, int, int] | None = ...) -> Image.Image:
        ...
    


class IcnsImageFile(ImageFile.ImageFile):
    """
    PIL image support for Mac OS .icns files.
    Chooses the best resolution, but will possibly load
    a different size image if you mutate the size attribute
    before calling 'load'.

    The info dictionary has a key 'sizes' that is a list
    of sizes that the icns file has.
    """
    format = ...
    format_description = ...
    @property
    def size(self) -> tuple[int, int] | tuple[int, int, int]:
        ...
    
    @size.setter
    def size(self, value: tuple[int, int] | tuple[int, int, int]) -> None:
        ...
    
    def load(self, scale: int | None = ...) -> Image.core.PixelAccess | None:
        ...
    


if __name__ == "__main__":
    ...
