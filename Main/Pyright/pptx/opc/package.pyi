"""
This type stub file was generated by pyright.
"""

from typing import IO, Iterator, Mapping, TYPE_CHECKING
from pptx.opc.oxml import CT_Relationship, CT_Relationships
from pptx.opc.packuri import PackURI
from pptx.util import lazyproperty
from typing_extensions import Self
from pptx.oxml.xmlchemy import BaseOxmlElement
from pptx.package import Package
from pptx.parts.presentation import PresentationPart

"""Fundamental Open Packaging Convention (OPC) objects.

The :mod:`pptx.packaging` module coheres around the concerns of reading and writing
presentations to and from a .pptx file.
"""
if TYPE_CHECKING:
    ...
class _RelatableMixin:
    """Provide relationship methods required by both the package and each part."""
    def part_related_by(self, reltype: str) -> Part:
        """Return (single) part having relationship to this package of `reltype`.

        Raises |KeyError| if no such relationship is found and |ValueError| if more than one such
        relationship is found.
        """
        ...
    
    def relate_to(self, target: Part | str, reltype: str, is_external: bool = ...) -> str:
        """Return rId key of relationship of `reltype` to `target`.

        If such a relationship already exists, its rId is returned. Otherwise the relationship is
        added and its new rId returned.
        """
        ...
    
    def related_part(self, rId: str) -> Part:
        """Return related |Part| subtype identified by `rId`."""
        ...
    
    def target_ref(self, rId: str) -> str:
        """Return URL contained in target ref of relationship identified by `rId`."""
        ...
    


class OpcPackage(_RelatableMixin):
    """Main API class for |python-opc|.

    A new instance is constructed by calling the :meth:`open` classmethod with a path to a package
    file or file-like object containing a package (.pptx file).
    """
    def __init__(self, pkg_file: str | IO[bytes]) -> None:
        ...
    
    @classmethod
    def open(cls, pkg_file: str | IO[bytes]) -> Self:
        """Return an |OpcPackage| instance loaded with the contents of `pkg_file`."""
        ...
    
    def drop_rel(self, rId: str) -> None:
        """Remove relationship identified by `rId`."""
        ...
    
    def iter_parts(self) -> Iterator[Part]:
        """Generate exactly one reference to each part in the package."""
        ...
    
    def iter_rels(self) -> Iterator[_Relationship]:
        """Generate exactly one reference to each relationship in package.

        Performs a depth-first traversal of the rels graph.
        """
        ...
    
    @property
    def main_document_part(self) -> PresentationPart:
        """Return |Part| subtype serving as the main document part for this package.

        In this case it will be a |Presentation| part.
        """
        ...
    
    def next_partname(self, tmpl: str) -> PackURI:
        """Return |PackURI| next available partname matching `tmpl`.

        `tmpl` is a printf (%)-style template string containing a single replacement item, a '%d'
        to be used to insert the integer portion of the partname. Example:
        '/ppt/slides/slide%d.xml'
        """
        ...
    
    def save(self, pkg_file: str | IO[bytes]) -> None:
        """Save this package to `pkg_file`.

        `file` can be either a path to a file (a string) or a file-like object.
        """
        ...
    


class _PackageLoader:
    """Function-object that loads a package from disk (or other store)."""
    def __init__(self, pkg_file: str | IO[bytes], package: Package) -> None:
        ...
    
    @classmethod
    def load(cls, pkg_file: str | IO[bytes], package: Package) -> tuple[CT_Relationships, dict[PackURI, Part]]:
        """Return (pkg_xml_rels, parts) pair resulting from loading `pkg_file`.

        The returned `parts` value is a {partname: part} mapping with each part in the package
        included and constructed complete with its relationships to other parts in the package.

        The returned `pkg_xml_rels` value is a `CT_Relationships` object containing the parsed
        package relationships. It is the caller's responsibility (the package object) to load
        those relationships into its |_Relationships| object.
        """
        ...
    


class Part(_RelatableMixin):
    """Base class for package parts.

    Provides common properties and methods, but intended to be subclassed in client code to
    implement specific part behaviors. Also serves as the default class for parts that are not yet
    given specific behaviors.
    """
    def __init__(self, partname: PackURI, content_type: str, package: Package, blob: bytes | None = ...) -> None:
        ...
    
    @classmethod
    def load(cls, partname: PackURI, content_type: str, package: Package, blob: bytes) -> Self:
        """Return `cls` instance loaded from arguments.

        This one is a straight pass-through, but subtypes may do some pre-processing, see XmlPart
        for an example.
        """
        ...
    
    @property
    def blob(self) -> bytes:
        """Contents of this package part as a sequence of bytes.

        Intended to be overridden by subclasses. Default behavior is to return the blob initial
        loaded during `Package.open()` operation.
        """
        ...
    
    @blob.setter
    def blob(self, blob: bytes): # -> None:
        """Note that not all subclasses use the part blob as their blob source.

        In particular, the |XmlPart| subclass uses its `self._element` to serialize a blob on
        demand. This works fine for binary parts though.
        """
        ...
    
    @lazyproperty
    def content_type(self) -> str:
        """Content-type (MIME-type) of this part."""
        ...
    
    def load_rels_from_xml(self, xml_rels: CT_Relationships, parts: dict[PackURI, Part]) -> None:
        """load _Relationships for this part from `xml_rels`.

        Part references are resolved using the `parts` dict that maps each partname to the loaded
        part with that partname. These relationships are loaded from a serialized package and so
        already have assigned rIds. This method is only used during package loading.
        """
        ...
    
    @lazyproperty
    def package(self) -> Package:
        """Package this part belongs to."""
        ...
    
    @property
    def partname(self) -> PackURI:
        """|PackURI| partname for this part, e.g. "/ppt/slides/slide1.xml"."""
        ...
    
    @partname.setter
    def partname(self, partname: PackURI): # -> None:
        ...
    
    @lazyproperty
    def rels(self) -> _Relationships:
        """Collection of relationships from this part to other parts."""
        ...
    


class XmlPart(Part):
    """Base class for package parts containing an XML payload, which is most of them.

    Provides additional methods to the |Part| base class that take care of parsing and
    reserializing the XML payload and managing relationships to other parts.
    """
    def __init__(self, partname: PackURI, content_type: str, package: Package, element: BaseOxmlElement) -> None:
        ...
    
    @classmethod
    def load(cls, partname: PackURI, content_type: str, package: Package, blob: bytes): # -> Self:
        """Return instance of `cls` loaded with parsed XML from `blob`."""
        ...
    
    @property
    def blob(self) -> bytes:
        """bytes XML serialization of this part."""
        ...
    
    def drop_rel(self, rId: str) -> None:
        """Remove relationship identified by `rId` if its reference count is under 2.

        Relationships with a reference count of 0 are implicit relationships. Note that only XML
        parts can drop relationships.
        """
        ...
    
    @property
    def part(self): # -> Self:
        """This part.

        This is part of the parent protocol, "children" of the document will not know the part
        that contains them so must ask their parent object. That chain of delegation ends here for
        child objects.
        """
        ...
    


class PartFactory:
    """Constructs a registered subtype of |Part|.

    Client code can register a subclass of |Part| to be used for a package blob based on its
    content type.
    """
    part_type_for: dict[str, type[Part]] = ...
    def __new__(cls, partname: PackURI, content_type: str, package: Package, blob: bytes) -> Part:
        ...
    


class _ContentTypeMap:
    """Value type providing dict semantics for looking up content type by partname."""
    def __init__(self, overrides: dict[str, str], defaults: dict[str, str]) -> None:
        ...
    
    def __getitem__(self, partname: PackURI) -> str:
        """Return content-type (MIME-type) for part identified by *partname*."""
        ...
    
    @classmethod
    def from_xml(cls, content_types_xml: bytes) -> _ContentTypeMap:
        """Return |_ContentTypeMap| instance populated from `content_types_xml`."""
        ...
    


class _Relationships(Mapping[str, "_Relationship"]):
    """Collection of |_Relationship| instances having `dict` semantics.

    Relationships are keyed by their rId, but may also be found in other ways, such as by their
    relationship type. |Relationship| objects are keyed by their rId.

    Iterating this collection has normal mapping semantics, generating the keys (rIds) of the
    mapping. `rels.keys()`, `rels.values()`, and `rels.items() can be used as they would be for a
    `dict`.
    """
    def __init__(self, base_uri: str) -> None:
        ...
    
    def __contains__(self, rId: object) -> bool:
        """Implement 'in' operation, like `"rId7" in relationships`."""
        ...
    
    def __getitem__(self, rId: str) -> _Relationship:
        """Implement relationship lookup by rId using indexed access, like rels[rId]."""
        ...
    
    def __iter__(self) -> Iterator[str]:
        """Implement iteration of rIds (iterating a mapping produces its keys)."""
        ...
    
    def __len__(self) -> int:
        """Return count of relationships in collection."""
        ...
    
    def get_or_add(self, reltype: str, target_part: Part) -> str:
        """Return str rId of `reltype` to `target_part`.

        The rId of an existing matching relationship is used if present. Otherwise, a new
        relationship is added and that rId is returned.
        """
        ...
    
    def get_or_add_ext_rel(self, reltype: str, target_ref: str) -> str:
        """Return str rId of external relationship of `reltype` to `target_ref`.

        The rId of an existing matching relationship is used if present. Otherwise, a new
        relationship is added and that rId is returned.
        """
        ...
    
    def load_from_xml(self, base_uri: str, xml_rels: CT_Relationships, parts: dict[PackURI, Part]) -> None:
        """Replace any relationships in this collection with those from `xml_rels`."""
        ...
    
    def part_with_reltype(self, reltype: str) -> Part:
        """Return target part of relationship with matching `reltype`.

        Raises |KeyError| if not found and |ValueError| if more than one matching relationship is
        found.
        """
        ...
    
    def pop(self, rId: str) -> _Relationship:
        """Return |_Relationship| identified by `rId` after removing it from collection.

        The caller is responsible for ensuring it is no longer required.
        """
        ...
    
    @property
    def xml(self): # -> bytes:
        """bytes XML serialization of this relationship collection.

        This value is suitable for storage as a .rels file in an OPC package. Includes a `<?xml..`
        declaration header with encoding as UTF-8.
        """
        ...
    


class _Relationship:
    """Value object describing link from a part or package to another part."""
    def __init__(self, base_uri: str, rId: str, reltype: str, target_mode: str, target: Part | str) -> None:
        ...
    
    @classmethod
    def from_xml(cls, base_uri: str, rel: CT_Relationship, parts: dict[PackURI, Part]) -> _Relationship:
        """Return |_Relationship| object based on CT_Relationship element `rel`."""
        ...
    
    @lazyproperty
    def is_external(self) -> bool:
        """True if target_mode is `RTM.EXTERNAL`.

        An external relationship is a link to a resource outside the package, such as a
        web-resource (URL).
        """
        ...
    
    @lazyproperty
    def reltype(self) -> str:
        """Member of RELATIONSHIP_TYPE describing relationship of target to source."""
        ...
    
    @lazyproperty
    def rId(self) -> str:
        """str relationship-id, like 'rId9'.

        Corresponds to the `Id` attribute on the `CT_Relationship` element and uniquely identifies
        this relationship within its peers for the source-part or package.
        """
        ...
    
    @lazyproperty
    def target_part(self) -> Part:
        """|Part| or subtype referred to by this relationship."""
        ...
    
    @lazyproperty
    def target_partname(self) -> PackURI:
        """|PackURI| instance containing partname targeted by this relationship.

        Raises `ValueError` on reference if target_mode is external. Use :attr:`target_mode` to
        check before referencing.
        """
        ...
    
    @lazyproperty
    def target_ref(self) -> str:
        """str reference to relationship target.

        For internal relationships this is the relative partname, suitable for serialization
        purposes. For an external relationship it is typically a URL.
        """
        ...
    


