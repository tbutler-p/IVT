"""
This type stub file was generated by pyright.
"""

from typing import Callable, IO, Iterable, Iterator, TYPE_CHECKING
from pptx.enum.shapes import MSO_CONNECTOR_TYPE, MSO_SHAPE, PP_PLACEHOLDER, PROG_ID
from pptx.oxml.shapes.graphfrm import CT_GraphicalObjectFrame
from pptx.oxml.shapes.picture import CT_Picture
from pptx.shapes.autoshape import Shape
from pptx.shapes.base import BaseShape
from pptx.shapes.connector import Connector
from pptx.shapes.freeform import FreeformBuilder
from pptx.shapes.graphfrm import GraphicFrame
from pptx.shapes.group import GroupShape
from pptx.shapes.picture import Picture
from pptx.shapes.placeholder import LayoutPlaceholder, MasterPlaceholder, NotesSlidePlaceholder
from pptx.shared import ParentedElementProxy
from pptx.util import Length
from pptx.chart.chart import Chart
from pptx.chart.data import ChartData
from pptx.enum.chart import XL_CHART_TYPE
from pptx.oxml.shapes import ShapeElement
from pptx.oxml.shapes.groupshape import CT_GroupShape
from pptx.parts.slide import SlidePart
from pptx.slide import Slide, SlideLayout
from pptx.types import ProvidesPart

"""The shape tree, the structure that holds a slide's shapes."""
if TYPE_CHECKING:
    ...
class _BaseShapes(ParentedElementProxy):
    """Base class for a shape collection appearing in a slide-type object.

    Subclasses include Slide, SlideLayout, and SlideMaster. Provides common methods.
    """
    def __init__(self, spTree: CT_GroupShape, parent: ProvidesPart) -> None:
        ...
    
    def __getitem__(self, idx: int) -> BaseShape:
        """Return shape at `idx` in sequence, e.g. `shapes[2]`."""
        ...
    
    def __iter__(self) -> Iterator[BaseShape]:
        """Generate a reference to each shape in the collection, in sequence."""
        ...
    
    def __len__(self) -> int:
        """Return count of shapes in this shape tree.

        A group shape contributes 1 to the total, without regard to the number of shapes contained
        in the group.
        """
        ...
    
    def clone_placeholder(self, placeholder: LayoutPlaceholder) -> None:
        """Add a new placeholder shape based on `placeholder`."""
        ...
    
    def ph_basename(self, ph_type: PP_PLACEHOLDER) -> str:
        """Return the base name for a placeholder of `ph_type` in this shape collection.

        There is some variance between slide types, for example a notes slide uses a different
        name for the body placeholder, so this method can be overriden by subclasses.
        """
        ...
    
    @property
    def turbo_add_enabled(self) -> bool:
        """True if "turbo-add" mode is enabled. Read/Write.

        EXPERIMENTAL: This feature can radically improve performance when adding large numbers
        (hundreds of shapes) to a slide. It works by caching the last shape ID used and
        incrementing that value to assign the next shape id. This avoids repeatedly searching all
        shape ids in the slide each time a new ID is required.

        Performance is not noticeably improved for a slide with a relatively small number of
        shapes, but because the search time rises with the square of the shape count, this option
        can be useful for optimizing generation of a slide composed of many shapes.

        Shape-id collisions can occur (causing a repair error on load) if more than one |Slide|
        object is used to interact with the same slide in the presentation. Note that the |Slides|
        collection creates a new |Slide| object each time a slide is accessed (e.g. `slide =
        prs.slides[0]`, so you must be careful to limit use to a single |Slide| object.
        """
        ...
    
    @turbo_add_enabled.setter
    def turbo_add_enabled(self, value: bool): # -> None:
        ...
    


class _BaseGroupShapes(_BaseShapes):
    """Base class for shape-trees that can add shapes."""
    part: SlidePart
    _element: CT_GroupShape
    def __init__(self, grpSp: CT_GroupShape, parent: ProvidesPart) -> None:
        ...
    
    def add_chart(self, chart_type: XL_CHART_TYPE, x: Length, y: Length, cx: Length, cy: Length, chart_data: ChartData) -> Chart:
        """Add a new chart of `chart_type` to the slide.

        The chart is positioned at (`x`, `y`), has size (`cx`, `cy`), and depicts `chart_data`.
        `chart_type` is one of the :ref:`XlChartType` enumeration values. `chart_data` is a
        |ChartData| object populated with the categories and series values for the chart.

        Note that a |GraphicFrame| shape object is returned, not the |Chart| object contained in
        that graphic frame shape. The chart object may be accessed using the :attr:`chart`
        property of the returned |GraphicFrame| object.
        """
        ...
    
    def add_connector(self, connector_type: MSO_CONNECTOR_TYPE, begin_x: Length, begin_y: Length, end_x: Length, end_y: Length) -> Connector:
        """Add a newly created connector shape to the end of this shape tree.

        `connector_type` is a member of the :ref:`MsoConnectorType` enumeration and the end-point
        values are specified as EMU values. The returned connector is of type `connector_type` and
        has begin and end points as specified.
        """
        ...
    
    def add_group_shape(self, shapes: Iterable[BaseShape] = ...) -> GroupShape:
        """Return a |GroupShape| object newly appended to this shape tree.

        The group shape is empty and must be populated with shapes using methods on its shape
        tree, available on its `.shapes` property. The position and extents of the group shape are
        determined by the shapes it contains; its position and extents are recalculated each time
        a shape is added to it.
        """
        ...
    
    def add_ole_object(self, object_file: str | IO[bytes], prog_id: str, left: Length, top: Length, width: Length | None = ..., height: Length | None = ..., icon_file: str | IO[bytes] | None = ..., icon_width: Length | None = ..., icon_height: Length | None = ...) -> GraphicFrame:
        """Return newly-created GraphicFrame shape embedding `object_file`.

        The returned graphic-frame shape contains `object_file` as an embedded OLE object. It is
        displayed as an icon at `left`, `top` with size `width`, `height`. `width` and `height`
        may be omitted when `prog_id` is a member of `PROG_ID`, in which case the default icon
        size is used. This is advised for best appearance where applicable because it avoids an
        icon with a "stretched" appearance.

        `object_file` may either be a str path to a file or file-like object (such as
        `io.BytesIO`) containing the bytes of the object to be embedded (such as an Excel file).

        `prog_id` can be either a member of `pptx.enum.shapes.PROG_ID` or a str value like
        `"Adobe.Exchange.7"` determined by inspecting the XML generated by PowerPoint for an
        object of the desired type.

        `icon_file` may either be a str path to an image file or a file-like object containing the
        image. The image provided will be displayed in lieu of the OLE object; double-clicking on
        the image opens the object (subject to operating-system limitations). The image file can
        be any supported image file. Those produced by PowerPoint itself are generally EMF and can
        be harvested from a PPTX package that embeds such an object. PNG and JPG also work fine.

        `icon_width` and `icon_height` are `Length` values (e.g. Emu() or Inches()) that describe
        the size of the icon image within the shape. These should be omitted unless a custom
        `icon_file` is provided. The dimensions must be discovered by inspecting the XML.
        Automatic resizing of the OLE-object shape can occur when the icon is double-clicked if
        these values are not as set by PowerPoint. This behavior may only manifest in the Windows
        version of PowerPoint.
        """
        ...
    
    def add_picture(self, image_file: str | IO[bytes], left: Length, top: Length, width: Length | None = ..., height: Length | None = ...) -> Picture:
        """Add picture shape displaying image in `image_file`.

        `image_file` can be either a path to a file (a string) or a file-like object. The picture
        is positioned with its top-left corner at (`top`, `left`). If `width` and `height` are
        both |None|, the native size of the image is used. If only one of `width` or `height` is
        used, the unspecified dimension is calculated to preserve the aspect ratio of the image.
        If both are specified, the picture is stretched to fit, without regard to its native
        aspect ratio.
        """
        ...
    
    def add_shape(self, autoshape_type_id: MSO_SHAPE, left: Length, top: Length, width: Length, height: Length) -> Shape:
        """Return new |Shape| object appended to this shape tree.

        `autoshape_type_id` is a member of :ref:`MsoAutoShapeType` e.g. `MSO_SHAPE.RECTANGLE`
        specifying the type of shape to be added. The remaining arguments specify the new shape's
        position and size.
        """
        ...
    
    def add_textbox(self, left: Length, top: Length, width: Length, height: Length) -> Shape:
        """Return newly added text box shape appended to this shape tree.

        The text box is of the specified size, located at the specified position on the slide.
        """
        ...
    
    def build_freeform(self, start_x: float = ..., start_y: float = ..., scale: tuple[float, float] | float = ...) -> FreeformBuilder:
        """Return |FreeformBuilder| object to specify a freeform shape.

        The optional `start_x` and `start_y` arguments specify the starting pen position in local
        coordinates. They will be rounded to the nearest integer before use and each default to
        zero.

        The optional `scale` argument specifies the size of local coordinates proportional to
        slide coordinates (EMU). If the vertical scale is different than the horizontal scale
        (local coordinate units are "rectangular"), a pair of numeric values can be provided as
        the `scale` argument, e.g. `scale=(1.0, 2.0)`. In this case the first number is
        interpreted as the horizontal (X) scale and the second as the vertical (Y) scale.

        A convenient method for calculating scale is to divide a |Length| object by an equivalent
        count of local coordinate units, e.g. `scale = Inches(1)/1000` for 1000 local units per
        inch.
        """
        ...
    
    def index(self, shape: BaseShape) -> int:
        """Return the index of `shape` in this sequence.

        Raises |ValueError| if `shape` is not in the collection.
        """
        ...
    


class GroupShapes(_BaseGroupShapes):
    """The sequence of child shapes belonging to a group shape.

    Note that this collection can itself contain a group shape, making this part of a recursive,
    tree data structure (acyclic graph).
    """
    ...


class SlideShapes(_BaseGroupShapes):
    """Sequence of shapes appearing on a slide.

    The first shape in the sequence is the backmost in z-order and the last shape is topmost.
    Supports indexed access, len(), index(), and iteration.
    """
    parent: Slide
    def add_movie(self, movie_file: str | IO[bytes], left: Length, top: Length, width: Length, height: Length, poster_frame_image: str | IO[bytes] | None = ..., mime_type: str = ...) -> GraphicFrame:
        """Return newly added movie shape displaying video in `movie_file`.

        **EXPERIMENTAL.** This method has important limitations:

        * The size must be specified; no auto-scaling such as that provided by :meth:`add_picture`
          is performed.
        * The MIME type of the video file should be specified, e.g. 'video/mp4'. The provided
          video file is not interrogated for its type. The MIME type `video/unknown` is used by
          default (and works fine in tests as of this writing).
        * A poster frame image must be provided, it cannot be automatically extracted from the
          video file. If no poster frame is provided, the default "media loudspeaker" image will
          be used.

        Return a newly added movie shape to the slide, positioned at (`left`, `top`), having size
        (`width`, `height`), and containing `movie_file`. Before the video is started,
        `poster_frame_image` is displayed as a placeholder for the video.
        """
        ...
    
    def add_table(self, rows: int, cols: int, left: Length, top: Length, width: Length, height: Length) -> GraphicFrame:
        """Add a |GraphicFrame| object containing a table.

        The table has the specified number of `rows` and `cols` and the specified position and
        size. `width` is evenly distributed between the columns of the new table. Likewise,
        `height` is evenly distributed between the rows. Note that the `.table` property on the
        returned |GraphicFrame| shape must be used to access the enclosed |Table| object.
        """
        ...
    
    def clone_layout_placeholders(self, slide_layout: SlideLayout) -> None:
        """Add placeholder shapes based on those in `slide_layout`.

        Z-order of placeholders is preserved. Latent placeholders (date, slide number, and footer)
        are not cloned.
        """
        ...
    
    @property
    def placeholders(self) -> SlidePlaceholders:
        """Sequence of placeholder shapes in this slide."""
        ...
    
    @property
    def title(self) -> Shape | None:
        """The title placeholder shape on the slide.

        |None| if the slide has no title placeholder.
        """
        ...
    


class LayoutShapes(_BaseShapes):
    """Sequence of shapes appearing on a slide layout.

    The first shape in the sequence is the backmost in z-order and the last shape is topmost.
    Supports indexed access, len(), index(), and iteration.
    """
    ...


class MasterShapes(_BaseShapes):
    """Sequence of shapes appearing on a slide master.

    The first shape in the sequence is the backmost in z-order and the last shape is topmost.
    Supports indexed access, len(), and iteration.
    """
    ...


class NotesSlideShapes(_BaseShapes):
    """Sequence of shapes appearing on a notes slide.

    The first shape in the sequence is the backmost in z-order and the last shape is topmost.
    Supports indexed access, len(), index(), and iteration.
    """
    def ph_basename(self, ph_type: PP_PLACEHOLDER) -> str:
        """Return the base name for a placeholder of `ph_type` in this shape collection.

        A notes slide uses a different name for the body placeholder and has some unique
        placeholder types, so this method overrides the default in the base class.
        """
        ...
    


class BasePlaceholders(_BaseShapes):
    """Base class for placeholder collections.

    Subclasses differentiate behaviors for a master, layout, and slide. By default, placeholder
    shapes are constructed using |BaseShapeFactory|. Subclasses should override
    :method:`_shape_factory` to use custom placeholder classes.
    """
    ...


class LayoutPlaceholders(BasePlaceholders):
    """Sequence of |LayoutPlaceholder| instance for each placeholder shape on a slide layout."""
    __iter__: Callable[[], Iterator[LayoutPlaceholder]]
    def get(self, idx: int, default: LayoutPlaceholder | None = ...) -> LayoutPlaceholder | None:
        """The first placeholder shape with matching `idx` value, or `default` if not found."""
        ...
    


class MasterPlaceholders(BasePlaceholders):
    """Sequence of MasterPlaceholder representing the placeholder shapes on a slide master."""
    __iter__: Callable[[], Iterator[MasterPlaceholder]]
    def get(self, ph_type: PP_PLACEHOLDER, default: MasterPlaceholder | None = ...): # -> MasterPlaceholder | None:
        """Return the first placeholder shape with type `ph_type` (e.g. 'body').

        Returns `default` if no such placeholder shape is present in the collection.
        """
        ...
    


class NotesSlidePlaceholders(MasterPlaceholders):
    """Sequence of placeholder shapes on a notes slide."""
    __iter__: Callable[[], Iterator[NotesSlidePlaceholder]]
    ...


class SlidePlaceholders(ParentedElementProxy):
    """Collection of placeholder shapes on a slide.

    Supports iteration, :func:`len`, and dictionary-style lookup on the `idx` value of the
    placeholders it contains.
    """
    _element: CT_GroupShape
    def __getitem__(self, idx: int): # -> BaseShape:
        """Access placeholder shape having `idx`.

        Note that while this looks like list access, idx is actually a dictionary key and will
        raise |KeyError| if no placeholder with that idx value is in the collection.
        """
        ...
    
    def __iter__(self): # -> Generator[BaseShape, None, None]:
        """Generate placeholder shapes in `idx` order."""
        ...
    
    def __len__(self) -> int:
        """Return count of placeholder shapes."""
        ...
    


def BaseShapeFactory(shape_elm: ShapeElement, parent: ProvidesPart) -> BaseShape:
    """Return an instance of the appropriate shape proxy class for `shape_elm`."""
    ...

def SlideShapeFactory(shape_elm: ShapeElement, parent: ProvidesPart) -> BaseShape:
    """Return appropriate shape object for `shape_elm` on a slide."""
    ...

class _MoviePicElementCreator:
    """Functional service object for creating a new movie p:pic element.

    It's entire external interface is its :meth:`new_movie_pic` class method that returns a new
    `p:pic` element containing the specified video. This class is not intended to be constructed
    or an instance of it retained by the caller; it is a "one-shot" object, really a function
    wrapped in a object such that its helper methods can be organized here.
    """
    def __init__(self, shapes: SlideShapes, shape_id: int, movie_file: str | IO[bytes], x: Length, y: Length, cx: Length, cy: Length, poster_frame_file: str | IO[bytes] | None, mime_type: str | None) -> None:
        ...
    
    @classmethod
    def new_movie_pic(cls, shapes: SlideShapes, shape_id: int, movie_file: str | IO[bytes], x: Length, y: Length, cx: Length, cy: Length, poster_frame_image: str | IO[bytes] | None, mime_type: str | None) -> CT_Picture:
        """Return a new `p:pic` element containing video in `movie_file`.

        If `mime_type` is None, 'video/unknown' is used. If `poster_frame_file` is None, the
        default "media loudspeaker" image is used.
        """
        ...
    


class _OleObjectElementCreator:
    """Functional service object for creating a new OLE-object p:graphicFrame element.

    It's entire external interface is its :meth:`graphicFrame` class method that returns a new
    `p:graphicFrame` element containing the specified embedded OLE-object shape. This class is not
    intended to be constructed or an instance of it retained by the caller; it is a "one-shot"
    object, really a function wrapped in a object such that its helper methods can be organized
    here.
    """
    def __init__(self, shapes: _BaseGroupShapes, shape_id: int, ole_object_file: str | IO[bytes], prog_id: PROG_ID | str, x: Length, y: Length, cx: Length | None, cy: Length | None, icon_file: str | IO[bytes] | None, icon_width: Length | None, icon_height: Length | None) -> None:
        ...
    
    @classmethod
    def graphicFrame(cls, shapes: _BaseGroupShapes, shape_id: int, ole_object_file: str | IO[bytes], prog_id: PROG_ID | str, x: Length, y: Length, cx: Length | None, cy: Length | None, icon_file: str | IO[bytes] | None, icon_width: Length | None, icon_height: Length | None) -> CT_GraphicalObjectFrame:
        """Return new `p:graphicFrame` element containing embedded `ole_object_file`."""
        ...
    


