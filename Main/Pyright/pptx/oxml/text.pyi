"""
This type stub file was generated by pyright.
"""

from typing import Callable, TYPE_CHECKING
from pptx.enum.lang import MSO_LANGUAGE_ID
from pptx.enum.text import MSO_AUTO_SIZE, MSO_TEXT_UNDERLINE_TYPE, MSO_VERTICAL_ANCHOR, PP_PARAGRAPH_ALIGNMENT
from pptx.oxml.xmlchemy import BaseOxmlElement
from pptx.util import Length
from pptx.oxml.action import CT_Hyperlink

"""Custom element classes for text-related XML elements"""
if TYPE_CHECKING:
    ...
class CT_RegularTextRun(BaseOxmlElement):
    """`a:r` custom element class"""
    get_or_add_rPr: Callable[[], CT_TextCharacterProperties]
    rPr: CT_TextCharacterProperties | None = ...
    t: BaseOxmlElement = ...
    @property
    def text(self) -> str:
        """All text of (required) `a:t` child."""
        ...
    
    @text.setter
    def text(self, value: str): # -> None:
        ...
    


class CT_TextBody(BaseOxmlElement):
    """`p:txBody` custom element class.

    Also used for `c:txPr` in charts and perhaps other elements.
    """
    add_p: Callable[[], CT_TextParagraph]
    p_lst: list[CT_TextParagraph]
    bodyPr: CT_TextBodyProperties = ...
    p: CT_TextParagraph = ...
    def clear_content(self): # -> None:
        """Remove all `a:p` children, but leave any others.

        cf. lxml `_Element.clear()` method which removes all children.
        """
        ...
    
    @property
    def defRPr(self) -> CT_TextCharacterProperties:
        """`a:defRPr` element of required first `p` child, added with its ancestors if not present.

        Used when element is a ``c:txPr`` in a chart and the `p` element is used only to specify
        formatting, not content.
        """
        ...
    
    @property
    def is_empty(self) -> bool:
        """True if only a single empty `a:p` element is present."""
        ...
    
    @classmethod
    def new(cls):
        """Return a new `p:txBody` element tree."""
        ...
    
    @classmethod
    def new_a_txBody(cls) -> CT_TextBody:
        """Return a new `a:txBody` element tree.

        Suitable for use in a table cell and possibly other situations.
        """
        ...
    
    @classmethod
    def new_p_txBody(cls):
        """Return a new `p:txBody` element tree, suitable for use in an `p:sp` element."""
        ...
    
    @classmethod
    def new_txPr(cls):
        """Return a `c:txPr` element tree.

        Suitable for use in a chart object like data labels or tick labels.
        """
        ...
    
    def unclear_content(self): # -> None:
        """Ensure p:txBody has at least one a:p child.

        Intuitively, reverse a ".clear_content()" operation to minimum conformance with spec
        (single empty paragraph).
        """
        ...
    


class CT_TextBodyProperties(BaseOxmlElement):
    """`a:bodyPr` custom element class."""
    _add_noAutofit: Callable[[], BaseOxmlElement]
    _add_normAutofit: Callable[[], CT_TextNormalAutofit]
    _add_spAutoFit: Callable[[], BaseOxmlElement]
    _remove_eg_textAutoFit: Callable[[], None]
    noAutofit: BaseOxmlElement | None
    normAutofit: CT_TextNormalAutofit | None
    spAutoFit: BaseOxmlElement | None
    eg_textAutoFit = ...
    lIns: Length = ...
    tIns: Length = ...
    rIns: Length = ...
    bIns: Length = ...
    anchor: MSO_VERTICAL_ANCHOR | None = ...
    wrap: str | None = ...
    @property
    def autofit(self): # -> Literal[MSO_AUTO_SIZE.NONE, MSO_AUTO_SIZE.TEXT_TO_FIT_SHAPE, MSO_AUTO_SIZE.SHAPE_TO_FIT_TEXT] | None:
        """The autofit setting for the text frame, a member of the `MSO_AUTO_SIZE` enumeration."""
        ...
    
    @autofit.setter
    def autofit(self, value: MSO_AUTO_SIZE | None): # -> None:
        ...
    


class CT_TextCharacterProperties(BaseOxmlElement):
    """Custom element class for `a:rPr`, `a:defRPr`, and `a:endParaRPr`.

    'rPr' is short for 'run properties', and it corresponds to the |Font| proxy class.
    """
    get_or_add_hlinkClick: Callable[[], CT_Hyperlink]
    get_or_add_latin: Callable[[], CT_TextFont]
    _remove_latin: Callable[[], None]
    _remove_hlinkClick: Callable[[], None]
    eg_fillProperties = ...
    latin: CT_TextFont | None = ...
    hlinkClick: CT_Hyperlink | None = ...
    lang: MSO_LANGUAGE_ID | None = ...
    sz: int | None = ...
    b: bool | None = ...
    i: bool | None = ...
    u: MSO_TEXT_UNDERLINE_TYPE | None = ...
    def add_hlinkClick(self, rId: str) -> CT_Hyperlink:
        """Add an `a:hlinkClick` child element with r:id attribute set to `rId`."""
        ...
    


class CT_TextField(BaseOxmlElement):
    """`a:fld` field element, for either a slide number or date field."""
    get_or_add_rPr: Callable[[], CT_TextCharacterProperties]
    rPr: CT_TextCharacterProperties | None = ...
    t: BaseOxmlElement | None = ...
    @property
    def text(self) -> str:
        """The text of the `a:t` child element."""
        ...
    


class CT_TextFont(BaseOxmlElement):
    """Custom element class for `a:latin`, `a:ea`, `a:cs`, and `a:sym`.

    These occur as child elements of CT_TextCharacterProperties, e.g. `a:rPr`.
    """
    typeface: str = ...


class CT_TextLineBreak(BaseOxmlElement):
    """`a:br` line break element"""
    get_or_add_rPr: Callable[[], CT_TextCharacterProperties]
    rPr = ...
    @property
    def text(self): # -> Literal['\u000b']:
        """Unconditionally a single vertical-tab character.

        A line break element can contain no text other than the implicit line feed it
        represents.
        """
        ...
    


class CT_TextNormalAutofit(BaseOxmlElement):
    """`a:normAutofit` element specifying fit text to shape font reduction, etc."""
    fontScale = ...


class CT_TextParagraph(BaseOxmlElement):
    """`a:p` custom element class"""
    get_or_add_endParaRPr: Callable[[], CT_TextCharacterProperties]
    get_or_add_pPr: Callable[[], CT_TextParagraphProperties]
    r_lst: list[CT_RegularTextRun]
    _add_br: Callable[[], CT_TextLineBreak]
    _add_r: Callable[[], CT_RegularTextRun]
    pPr: CT_TextParagraphProperties | None = ...
    r = ...
    br = ...
    endParaRPr: CT_TextCharacterProperties | None = ...
    def add_br(self) -> CT_TextLineBreak:
        """Return a newly appended `a:br` element."""
        ...
    
    def add_r(self, text: str | None = ...) -> CT_RegularTextRun:
        """Return a newly appended `a:r` element."""
        ...
    
    def append_text(self, text: str): # -> None:
        """Append `a:r` and `a:br` elements to `p` based on `text`.

        Any `\n` or `\v` (vertical-tab) characters in `text` delimit `a:r` (run) elements and
        themselves are translated to `a:br` (line-break) elements. The vertical-tab character
        appears in clipboard text from PowerPoint at "soft" line-breaks (new-line, but not new
        paragraph).
        """
        ...
    
    @property
    def content_children(self) -> tuple[CT_RegularTextRun | CT_TextLineBreak | CT_TextField, ...]:
        """Sequence containing text-container child elements of this `a:p` element.

        These include `a:r`, `a:br`, and `a:fld`.
        """
        ...
    
    @property
    def text(self) -> str:
        """str text contained in this paragraph."""
        ...
    


class CT_TextParagraphProperties(BaseOxmlElement):
    """`a:pPr` custom element class."""
    get_or_add_defRPr: Callable[[], CT_TextCharacterProperties]
    _add_lnSpc: Callable[[], CT_TextSpacing]
    _add_spcAft: Callable[[], CT_TextSpacing]
    _add_spcBef: Callable[[], CT_TextSpacing]
    _remove_lnSpc: Callable[[], None]
    _remove_spcAft: Callable[[], None]
    _remove_spcBef: Callable[[], None]
    _tag_seq = ...
    lnSpc: CT_TextSpacing | None = ...
    spcBef: CT_TextSpacing | None = ...
    spcAft: CT_TextSpacing | None = ...
    defRPr: CT_TextCharacterProperties | None = ...
    lvl: int = ...
    algn: PP_PARAGRAPH_ALIGNMENT | None = ...
    @property
    def line_spacing(self) -> float | Length | None:
        """The spacing between baselines of successive lines in this paragraph.

        A float value indicates a number of lines. A |Length| value indicates a fixed spacing.
        Value is contained in `./a:lnSpc/a:spcPts/@val` or `./a:lnSpc/a:spcPct/@val`. Value is
        |None| if no element is present.
        """
        ...
    
    @line_spacing.setter
    def line_spacing(self, value: float | Length | None): # -> None:
        ...
    
    @property
    def space_after(self) -> Length | None:
        """The EMU equivalent of the centipoints value in `./a:spcAft/a:spcPts/@val`."""
        ...
    
    @space_after.setter
    def space_after(self, value: Length | None): # -> None:
        ...
    
    @property
    def space_before(self): # -> None:
        """The EMU equivalent of the centipoints value in `./a:spcBef/a:spcPts/@val`."""
        ...
    
    @space_before.setter
    def space_before(self, value: Length | None): # -> None:
        ...
    


class CT_TextSpacing(BaseOxmlElement):
    """Used for `a:lnSpc`, `a:spcBef`, and `a:spcAft` elements."""
    get_or_add_spcPct: Callable[[], CT_TextSpacingPercent]
    get_or_add_spcPts: Callable[[], CT_TextSpacingPoint]
    _remove_spcPct: Callable[[], None]
    _remove_spcPts: Callable[[], None]
    spcPct: CT_TextSpacingPercent | None = ...
    spcPts: CT_TextSpacingPoint | None = ...
    def set_spcPct(self, value: float): # -> None:
        """Set spacing to `value` lines, e.g. 1.75 lines.

        A ./a:spcPts child is removed if present.
        """
        ...
    
    def set_spcPts(self, value: Length): # -> None:
        """Set spacing to `value` points. A ./a:spcPct child is removed if present."""
        ...
    


class CT_TextSpacingPercent(BaseOxmlElement):
    """`a:spcPct` element, specifying spacing in thousandths of a percent in its `val` attribute."""
    val: float = ...


class CT_TextSpacingPoint(BaseOxmlElement):
    """`a:spcPts` element, specifying spacing in centipoints in its `val` attribute."""
    val: Length = ...


