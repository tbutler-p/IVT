"""
This type stub file was generated by pyright.
"""

from datetime import datetime, timezone
from enum import Enum
from typing import Final, Generic, Hashable, List, Literal, Optional, TypeVar
from pydantic import AfterValidator, AnyUrl, BaseModel, Field, PlainSerializer, StrictStr, StringConstraints, ValidationInfo, WrapValidator, field_validator
from pydantic.types import NonNegativeInt
from typing_extensions import Annotated
from docling_core.search.mapping import es_field
from docling_core.search.package import VERSION_PATTERN
from docling_core.utils.alias import AliasModel
from docling_core.utils.validators import validate_datetime, validate_unique_list

"""Define common models across types."""
_JSON_POINTER_REGEX: Final[str] = ...
LanguageT = TypeVar("LanguageT", bound=str)
IdentifierTypeT = TypeVar("IdentifierTypeT", bound=str)
DescriptionAdvancedT = TypeVar("DescriptionAdvancedT", bound=BaseModel)
DescriptionAnalyticsT = TypeVar("DescriptionAnalyticsT", bound=BaseModel)
SubjectTypeT = TypeVar("SubjectTypeT", bound=str)
SubjectNameTypeT = TypeVar("SubjectNameTypeT", bound=str)
PredicateValueTypeT = TypeVar("PredicateValueTypeT", bound=str)
PredicateKeyNameT = TypeVar("PredicateKeyNameT", bound=str)
PredicateKeyTypeT = TypeVar("PredicateKeyTypeT", bound=str)
ProvenanceTypeT = TypeVar("ProvenanceTypeT", bound=str)
CollectionNameTypeT = TypeVar("CollectionNameTypeT", bound=str)
Coordinates = Annotated[list[float], Field(min_length=2, max_length=2, json_schema_extra=es_field(type="geo_point")),]
T = TypeVar("T", bound=Hashable)
UniqueList = Annotated[List[T], AfterValidator(validate_unique_list), Field(json_schema_extra={ "uniqueItems": True }),]
StrictDateTime = Annotated[datetime, WrapValidator(validate_datetime), PlainSerializer(lambda x: x.astimezone(tz=timezone.utc).isoformat(), return_type=str),]
ACQUISITION_TYPE = Literal["API", "FTP", "Download", "Link", "Web scraping/Crawling", "Other"]
class Identifier(AliasModel, Generic[IdentifierTypeT], extra="forbid"):
    """Unique identifier of a Docling data object."""
    type_: IdentifierTypeT = ...
    value: StrictStr = ...
    name: str = ...
    @field_validator("name")
    @classmethod
    def name_from_type_value(cls, v, info: ValidationInfo):
        """Validate the reference field for indexes of type Document."""
        ...
    


class Log(AliasModel, extra="forbid"):
    """Log entry to describe an ETL task on a document."""
    task: Optional[StrictStr] = ...
    agent: StrictStr = ...
    type_: StrictStr = ...
    comment: Optional[StrictStr] = ...
    date: StrictDateTime = ...


class FileInfoObject(AliasModel):
    """Filing information for any data object to be stored in a Docling database."""
    filename: StrictStr = ...
    fileprov: Optional[StrictStr] = ...
    document_hash: StrictStr = ...


class CollectionTypeEnum(str, Enum):
    """Enumeration of valid Docling collection types."""
    generic = ...
    document = ...
    record = ...


CollectionTypeT = TypeVar("CollectionTypeT", bound=CollectionTypeEnum)
class CollectionInfo(BaseModel, Generic[CollectionNameTypeT, CollectionTypeT], extra="forbid"):
    """Information of a collection."""
    name: Optional[CollectionNameTypeT] = ...
    type: CollectionTypeT = ...
    version: Optional[Annotated[str, StringConstraints(pattern=VERSION_PATTERN, strict=True)]] = ...
    alias: Optional[list[StrictStr]] = ...


class CollectionDocumentInfo(CollectionInfo[CollectionNameTypeT, Literal[CollectionTypeEnum.document]], Generic[CollectionNameTypeT], extra="forbid"):
    """Information of a collection of type Document."""
    ...


class CollectionRecordInfo(CollectionInfo[CollectionNameTypeT, Literal[CollectionTypeEnum.record]], Generic[CollectionNameTypeT], extra="forbid"):
    """Information of a collection of type Record."""
    ...


class Acquisition(BaseModel, extra="forbid"):
    """Information on how the data was obtained."""
    type: ACQUISITION_TYPE = ...
    date: Optional[StrictDateTime] = ...
    link: Optional[AnyUrl] = ...
    size: Optional[NonNegativeInt] = ...


