"""
This type stub file was generated by pyright.
"""

import typing
import pandas as pd
from enum import Enum
from pathlib import Path
from typing import Any, Dict, Final, List, Literal, Optional, Sequence, Tuple, Union
from PIL import Image as PILImage
from pydantic import AnyUrl, BaseModel, Field, StringConstraints, computed_field, field_validator, model_validator, validate_call
from typing_extensions import Annotated, Self, deprecated
from docling_core.search.package import VERSION_PATTERN
from docling_core.types.doc import BoundingBox, Size
from docling_core.types.doc.base import ImageRefMode
from docling_core.types.doc.labels import CodeLanguageLabel, DocItemLabel, GraphCellLabel, GraphLinkLabel, GroupLabel

"""Models for the Docling Document data type."""
_logger = ...
Uint64 = typing.Annotated[int, Field(ge=0, le=(2 ** 64 - 1))]
LevelNumber = typing.Annotated[int, Field(ge=1, le=100)]
CURRENT_VERSION: Final = ...
DEFAULT_EXPORT_LABELS = ...
DOCUMENT_TOKENS_EXPORT_LABELS = ...
class BaseAnnotation(BaseModel):
    """Base class for all annotation types."""
    kind: str
    ...


class PictureClassificationClass(BaseModel):
    """PictureClassificationData."""
    class_name: str
    confidence: float
    ...


class PictureClassificationData(BaseAnnotation):
    """PictureClassificationData."""
    kind: Literal["classification"] = ...
    provenance: str
    predicted_classes: List[PictureClassificationClass]


class DescriptionAnnotation(BaseAnnotation):
    """DescriptionAnnotation."""
    kind: Literal["description"] = ...
    text: str
    provenance: str


class PictureMoleculeData(BaseAnnotation):
    """PictureMoleculeData."""
    kind: Literal["molecule_data"] = ...
    smi: str
    confidence: float
    class_name: str
    segmentation: List[Tuple[float, float]]
    provenance: str


class MiscAnnotation(BaseAnnotation):
    """MiscAnnotation."""
    kind: Literal["misc"] = ...
    content: Dict[str, Any]


class ChartLine(BaseModel):
    """Represents a line in a line chart.

    Attributes:
        label (str): The label for the line.
        values (List[Tuple[float, float]]): A list of (x, y) coordinate pairs
            representing the line's data points.
    """
    label: str
    values: List[Tuple[float, float]]
    ...


class ChartBar(BaseModel):
    """Represents a bar in a bar chart.

    Attributes:
        label (str): The label for the bar.
        values (float): The value associated with the bar.
    """
    label: str
    values: float
    ...


class ChartStackedBar(BaseModel):
    """Represents a stacked bar in a stacked bar chart.

    Attributes:
        label (List[str]): The labels for the stacked bars. Multiple values are stored
            in cases where the chart is "double stacked," meaning bars are stacked both
            horizontally and vertically.
        values (List[Tuple[str, int]]): A list of values representing different segments
            of the stacked bar along with their label.
    """
    label: List[str]
    values: List[Tuple[str, int]]
    ...


class ChartSlice(BaseModel):
    """Represents a slice in a pie chart.

    Attributes:
        label (str): The label for the slice.
        value (float): The value represented by the slice.
    """
    label: str
    value: float
    ...


class ChartPoint(BaseModel):
    """Represents a point in a scatter chart.

    Attributes:
        value (Tuple[float, float]): A (x, y) coordinate pair representing a point in a
            chart.
    """
    value: Tuple[float, float]
    ...


class PictureChartData(BaseAnnotation):
    """Base class for picture chart data.

    Attributes:
        title (str): The title of the chart.
    """
    title: str
    ...


class PictureLineChartData(PictureChartData):
    """Represents data of a line chart.

    Attributes:
        kind (Literal["line_chart_data"]): The type of the chart.
        x_axis_label (str): The label for the x-axis.
        y_axis_label (str): The label for the y-axis.
        lines (List[ChartLine]): A list of lines in the chart.
    """
    kind: Literal["line_chart_data"] = ...
    x_axis_label: str
    y_axis_label: str
    lines: List[ChartLine]


class PictureBarChartData(PictureChartData):
    """Represents data of a bar chart.

    Attributes:
        kind (Literal["bar_chart_data"]): The type of the chart.
        x_axis_label (str): The label for the x-axis.
        y_axis_label (str): The label for the y-axis.
        bars (List[ChartBar]): A list of bars in the chart.
    """
    kind: Literal["bar_chart_data"] = ...
    x_axis_label: str
    y_axis_label: str
    bars: List[ChartBar]


class PictureStackedBarChartData(PictureChartData):
    """Represents data of a stacked bar chart.

    Attributes:
        kind (Literal["stacked_bar_chart_data"]): The type of the chart.
        x_axis_label (str): The label for the x-axis.
        y_axis_label (str): The label for the y-axis.
        stacked_bars (List[ChartStackedBar]): A list of stacked bars in the chart.
    """
    kind: Literal["stacked_bar_chart_data"] = ...
    x_axis_label: str
    y_axis_label: str
    stacked_bars: List[ChartStackedBar]


class PicturePieChartData(PictureChartData):
    """Represents data of a pie chart.

    Attributes:
        kind (Literal["pie_chart_data"]): The type of the chart.
        slices (List[ChartSlice]): A list of slices in the pie chart.
    """
    kind: Literal["pie_chart_data"] = ...
    slices: List[ChartSlice]


class PictureScatterChartData(PictureChartData):
    """Represents data of a scatter chart.

    Attributes:
        kind (Literal["scatter_chart_data"]): The type of the chart.
        x_axis_label (str): The label for the x-axis.
        y_axis_label (str): The label for the y-axis.
        points (List[ChartPoint]): A list of points in the scatter chart.
    """
    kind: Literal["scatter_chart_data"] = ...
    x_axis_label: str
    y_axis_label: str
    points: List[ChartPoint]


class TableCell(BaseModel):
    """TableCell."""
    bbox: Optional[BoundingBox] = ...
    row_span: int = ...
    col_span: int = ...
    start_row_offset_idx: int
    end_row_offset_idx: int
    start_col_offset_idx: int
    end_col_offset_idx: int
    text: str
    column_header: bool = ...
    row_header: bool = ...
    row_section: bool = ...
    fillable: bool = ...
    @model_validator(mode="before")
    @classmethod
    def from_dict_format(cls, data: Any) -> Any:
        """from_dict_format."""
        ...
    


class RichTableCell(TableCell):
    """RichTableCell."""
    ref: RefItem
    ...


AnyTableCell = Annotated[Union[RichTableCell, TableCell], Field(union_mode="left_to_right"),]
class TableData(BaseModel):
    """BaseTableData."""
    table_cells: List[AnyTableCell] = ...
    num_rows: int = ...
    num_cols: int = ...
    @computed_field
    @property
    def grid(self) -> List[List[TableCell]]:
        """grid."""
        ...
    
    def remove_rows(self, indices: List[int], doc: Optional[DoclingDocument] = ...) -> List[List[TableCell]]:
        """Remove rows from the table by their indices.

        :param indices: List[int]: A list of indices of the rows to remove. (Starting from 0)

        :return: List[List[TableCell]]: A list representation of the removed rows as lists of TableCell objects.
        """
        ...
    
    def pop_row(self, doc: Optional[DoclingDocument] = ...) -> List[TableCell]:
        """Remove and return the last row from the table.

        :returns: List[TableCell]: A list of TableCell objects representing the popped row.
        """
        ...
    
    def remove_row(self, row_index: int, doc: Optional[DoclingDocument] = ...) -> List[TableCell]:
        """Remove a row from the table by its index.

        :param row_index: int: The index of the row to remove. (Starting from 0)

        :returns: List[TableCell]: A list of TableCell objects representing the removed row.
        """
        ...
    
    def insert_rows(self, row_index: int, rows: List[List[str]], after: bool = ...) -> None:
        """Insert multiple new rows from a list of lists of strings before/after a specific index in the table.

        :param row_index: int: The index at which to insert the new rows. (Starting from 0)
        :param rows: List[List[str]]: A list of lists, where each inner list represents the content of a new row.
        :param after: bool: If True, insert the rows after the specified index, otherwise before it. (Default is False)

        :returns: None
        """
        ...
    
    def insert_row(self, row_index: int, row: List[str], after: bool = ...) -> None:
        """Insert a new row from a list of strings before/after a specific index in the table.

        :param row_index: int: The index at which to insert the new row. (Starting from 0)
        :param row: List[str]: A list of strings representing the content of the new row.
        :param after: bool: If True, insert the row after the specified index, otherwise before it. (Default is False)

        :returns: None
        """
        ...
    
    def add_rows(self, rows: List[List[str]]) -> None:
        """Add multiple new rows to the table from a list of lists of strings.

        :param rows: List[List[str]]: A list of lists, where each inner list represents the content of a new row.

        :returns: None
        """
        ...
    
    def add_row(self, row: List[str]) -> None:
        """Add a new row to the table from a list of strings.

        :param row: List[str]: A list of strings representing the content of the new row.

        :returns: None
        """
        ...
    
    def get_row_bounding_boxes(self) -> dict[int, BoundingBox]:
        """Get the minimal bounding box for each row in the table.

        Returns:
        List[Optional[BoundingBox]]: A list where each element is the minimal
        bounding box that encompasses all cells in that row, or None if no
        cells in the row have bounding boxes.
        """
        ...
    
    def get_column_bounding_boxes(self) -> dict[int, BoundingBox]:
        """Get the minimal bounding box for each column in the table.

        Returns:
            List[Optional[BoundingBox]]: A list where each element is the minimal
            bounding box that encompasses all cells in that column, or None if no
            cells in the column have bounding boxes.
        """
        ...
    


class PictureTabularChartData(PictureChartData):
    """Base class for picture chart data.

    Attributes:
        title (str): The title of the chart.
        chart_data (TableData): Chart data in the table format.
    """
    kind: Literal["tabular_chart_data"] = ...
    chart_data: TableData


PictureDataType = Annotated[Union[DescriptionAnnotation, MiscAnnotation, PictureClassificationData, PictureMoleculeData, PictureTabularChartData, PictureLineChartData, PictureBarChartData, PictureStackedBarChartData, PicturePieChartData, PictureScatterChartData,], Field(discriminator="kind"),]
class DocumentOrigin(BaseModel):
    """FileSource."""
    mimetype: str
    binary_hash: Uint64
    filename: str
    uri: Optional[AnyUrl] = ...
    _extra_mimetypes: typing.ClassVar[List[str]] = ...
    @field_validator("binary_hash", mode="before")
    @classmethod
    def parse_hex_string(cls, value):
        """parse_hex_string."""
        ...
    
    @field_validator("mimetype")
    @classmethod
    def validate_mimetype(cls, v):
        """validate_mimetype."""
        ...
    


class RefItem(BaseModel):
    """RefItem."""
    cref: str = ...
    def get_ref(self): # -> Self:
        """get_ref."""
        ...
    
    model_config = ...
    def resolve(self, doc: DoclingDocument): # -> Any:
        """Resolve the path in the document."""
        ...
    


class ImageRef(BaseModel):
    """ImageRef."""
    mimetype: str
    dpi: int
    size: Size
    uri: Union[AnyUrl, Path] = ...
    _pil: Optional[PILImage.Image] = ...
    @property
    def pil_image(self) -> Optional[PILImage.Image]:
        """Return the PIL Image."""
        ...
    
    @field_validator("mimetype")
    @classmethod
    def validate_mimetype(cls, v):
        """validate_mimetype."""
        ...
    
    @classmethod
    def from_pil(cls, image: PILImage.Image, dpi: int) -> Self:
        """Construct ImageRef from a PIL Image."""
        ...
    


class DocTagsPage(BaseModel):
    """DocTagsPage."""
    model_config = ...
    tokens: str
    image: Optional[PILImage.Image] = ...


class DocTagsDocument(BaseModel):
    """DocTagsDocument."""
    pages: List[DocTagsPage] = ...
    @classmethod
    def from_doctags_and_image_pairs(cls, doctags: typing.Sequence[Union[Path, str]], images: Optional[List[Union[Path, PILImage.Image]]]): # -> Self:
        """from_doctags_and_image_pairs."""
        ...
    
    @classmethod
    def from_multipage_doctags_and_images(cls, doctags: Union[Path, str], images: Optional[List[Union[Path, PILImage.Image]]]): # -> Self:
        """From doctags with `<page_break>` and corresponding list of page images."""
        ...
    


class ProvenanceItem(BaseModel):
    """ProvenanceItem."""
    page_no: int
    bbox: BoundingBox
    charspan: Tuple[int, int]
    ...


class ContentLayer(str, Enum):
    """ContentLayer."""
    BODY = ...
    FURNITURE = ...
    BACKGROUND = ...
    INVISIBLE = ...
    NOTES = ...


DEFAULT_CONTENT_LAYERS = ...
class _ExtraAllowingModel(BaseModel):
    """Base model allowing extra fields."""
    model_config = ...
    def get_custom_part(self) -> dict[str, Any]:
        """Get the extra fields as a dictionary."""
        ...
    
    def __setattr__(self, name: str, value: Any) -> None:
        ...
    
    def set_custom_field(self, namespace: str, name: str, value: Any) -> str:
        """Set a custom field and return the key."""
        ...
    


class BasePrediction(_ExtraAllowingModel):
    """Prediction field."""
    confidence: Optional[float] = ...
    created_by: Optional[str] = ...


class SummaryMetaField(BasePrediction):
    """Summary data."""
    text: str
    ...


class MetaFieldName(str, Enum):
    """Standard meta field names."""
    SUMMARY = ...
    DESCRIPTION = ...
    CLASSIFICATION = ...
    MOLECULE = ...
    TABULAR_CHART = ...


class BaseMeta(_ExtraAllowingModel):
    """Base class for metadata."""
    summary: Optional[SummaryMetaField] = ...


class DescriptionMetaField(BasePrediction):
    """Description metadata field."""
    text: str
    ...


class PictureClassificationPrediction(BasePrediction):
    """Picture classification instance."""
    class_name: str
    ...


class PictureClassificationMetaField(_ExtraAllowingModel):
    """Picture classification metadata field."""
    predictions: list[PictureClassificationPrediction] = ...
    def get_main_prediction(self) -> PictureClassificationPrediction:
        """Get prediction with highest confidence (if confidence not available, first is used by convention)."""
        ...
    


class MoleculeMetaField(BasePrediction):
    """Molecule metadata field."""
    smi: str = ...


class TabularChartMetaField(BasePrediction):
    """Tabular chart metadata field."""
    title: Optional[str] = ...
    chart_data: TableData


class FloatingMeta(BaseMeta):
    """Metadata model for floating."""
    description: Optional[DescriptionMetaField] = ...


class PictureMeta(FloatingMeta):
    """Metadata model for pictures."""
    classification: Optional[PictureClassificationMetaField] = ...
    molecule: Optional[MoleculeMetaField] = ...
    tabular_chart: Optional[TabularChartMetaField] = ...


class NodeItem(BaseModel):
    """NodeItem."""
    self_ref: str = ...
    parent: Optional[RefItem] = ...
    children: List[RefItem] = ...
    content_layer: ContentLayer = ...
    model_config = ...
    meta: Optional[BaseMeta] = ...
    def get_ref(self) -> RefItem:
        """get_ref."""
        ...
    


class GroupItem(NodeItem):
    """GroupItem."""
    name: str = ...
    label: GroupLabel = ...


class ListGroup(GroupItem):
    """ListGroup."""
    label: typing.Literal[GroupLabel.LIST] = ...
    @field_validator("label", mode="before")
    @classmethod
    def patch_ordered(cls, value): # -> Literal[GroupLabel.LIST]:
        """patch_ordered."""
        ...
    
    def first_item_is_enumerated(self, doc: DoclingDocument): # -> bool:
        """Whether the first list item is enumerated."""
        ...
    


@deprecated("Use ListGroup instead.")
class OrderedList(GroupItem):
    """OrderedList."""
    label: typing.Literal[GroupLabel.ORDERED_LIST] = ...


class InlineGroup(GroupItem):
    """InlineGroup."""
    label: typing.Literal[GroupLabel.INLINE] = ...


class DocItem(NodeItem):
    """DocItem."""
    label: DocItemLabel
    prov: List[ProvenanceItem] = ...
    def get_location_tokens(self, doc: DoclingDocument, new_line: str = ..., xsize: int = ..., ysize: int = ...) -> str:
        """Get the location string for the BaseCell."""
        ...
    
    def get_image(self, doc: DoclingDocument, prov_index: int = ...) -> Optional[PILImage.Image]:
        """Returns the image of this DocItem.

        The function returns None if this DocItem has no valid provenance or
        if a valid image of the page containing this DocItem is not available
        in doc.
        """
        ...
    
    def get_annotations(self) -> Sequence[BaseAnnotation]:
        """Get the annotations of this DocItem."""
        ...
    


class Script(str, Enum):
    """Text script position."""
    BASELINE = ...
    SUB = ...
    SUPER = ...


class Formatting(BaseModel):
    """Formatting."""
    bold: bool = ...
    italic: bool = ...
    underline: bool = ...
    strikethrough: bool = ...
    script: Script = ...


class TextItem(DocItem):
    """TextItem."""
    label: typing.Literal[DocItemLabel.CAPTION, DocItemLabel.CHECKBOX_SELECTED, DocItemLabel.CHECKBOX_UNSELECTED, DocItemLabel.FOOTNOTE, DocItemLabel.PAGE_FOOTER, DocItemLabel.PAGE_HEADER, DocItemLabel.PARAGRAPH, DocItemLabel.REFERENCE, DocItemLabel.TEXT, DocItemLabel.EMPTY_VALUE,]
    orig: str
    text: str
    formatting: Optional[Formatting] = ...
    hyperlink: Optional[Union[AnyUrl, Path]] = ...
    @deprecated("Use export_to_doctags() instead.")
    def export_to_document_tokens(self, *args, **kwargs): # -> str:
        r"""Export to DocTags format."""
        ...
    
    def export_to_doctags(self, doc: DoclingDocument, new_line: str = ..., xsize: int = ..., ysize: int = ..., add_location: bool = ..., add_content: bool = ...): # -> str:
        r"""Export text element to document tokens format.

        :param doc: "DoclingDocument":
        :param new_line: str (Default value = "")  Deprecated
        :param xsize: int:  (Default value = 500)
        :param ysize: int:  (Default value = 500)
        :param add_location: bool:  (Default value = True)
        :param add_content: bool:  (Default value = True)

        """
        ...
    


class TitleItem(TextItem):
    """TitleItem."""
    label: typing.Literal[DocItemLabel.TITLE] = ...


class SectionHeaderItem(TextItem):
    """SectionItem."""
    label: typing.Literal[DocItemLabel.SECTION_HEADER] = ...
    level: LevelNumber = ...
    @deprecated("Use export_to_doctags() instead.")
    def export_to_document_tokens(self, *args, **kwargs): # -> str:
        r"""Export to DocTags format."""
        ...
    
    def export_to_doctags(self, doc: DoclingDocument, new_line: str = ..., xsize: int = ..., ysize: int = ..., add_location: bool = ..., add_content: bool = ...): # -> str:
        r"""Export text element to document tokens format.

        :param doc: "DoclingDocument":
        :param new_line: str (Default value = "")  Deprecated
        :param xsize: int:  (Default value = 500)
        :param ysize: int:  (Default value = 500)
        :param add_location: bool:  (Default value = True)
        :param add_content: bool:  (Default value = True)

        """
        ...
    


class ListItem(TextItem):
    """SectionItem."""
    label: typing.Literal[DocItemLabel.LIST_ITEM] = ...
    enumerated: bool = ...
    marker: str = ...


class FloatingItem(DocItem):
    """FloatingItem."""
    meta: Optional[FloatingMeta] = ...
    captions: List[RefItem] = ...
    references: List[RefItem] = ...
    footnotes: List[RefItem] = ...
    image: Optional[ImageRef] = ...
    def caption_text(self, doc: DoclingDocument) -> str:
        """Computes the caption as a single text."""
        ...
    
    def get_image(self, doc: DoclingDocument, prov_index: int = ...) -> Optional[PILImage.Image]:
        """Returns the image corresponding to this FloatingItem.

        This function returns the PIL image from self.image if one is available.
        Otherwise, it uses DocItem.get_image to get an image of this FloatingItem.

        In particular, when self.image is None, the function returns None if this
        FloatingItem has no valid provenance or the doc does not contain a valid image
        for the required page.
        """
        ...
    


class CodeItem(FloatingItem, TextItem):
    """CodeItem."""
    label: typing.Literal[DocItemLabel.CODE] = ...
    code_language: CodeLanguageLabel = ...
    @deprecated("Use export_to_doctags() instead.")
    def export_to_document_tokens(self, *args, **kwargs): # -> str:
        r"""Export to DocTags format."""
        ...
    
    def export_to_doctags(self, doc: DoclingDocument, new_line: str = ..., xsize: int = ..., ysize: int = ..., add_location: bool = ..., add_content: bool = ...): # -> str:
        r"""Export text element to document tokens format.

        :param doc: "DoclingDocument":
        :param new_line: str (Default value = "")  Deprecated
        :param xsize: int:  (Default value = 500)
        :param ysize: int:  (Default value = 500)
        :param add_location: bool:  (Default value = True)
        :param add_content: bool:  (Default value = True)

        """
        ...
    


class FormulaItem(TextItem):
    """FormulaItem."""
    label: typing.Literal[DocItemLabel.FORMULA] = ...


class MetaUtils:
    """Metadata-related utilities."""
    _META_FIELD_NAMESPACE_DELIMITER: Final = ...
    _META_FIELD_LEGACY_NAMESPACE: Final = ...
    @classmethod
    def create_meta_field_name(cls, *, namespace: str, name: str) -> str:
        """Create a meta field name."""
        ...
    


class PictureItem(FloatingItem):
    """PictureItem."""
    label: typing.Literal[DocItemLabel.PICTURE, DocItemLabel.CHART] = ...
    meta: Optional[PictureMeta] = ...
    annotations: Annotated[List[PictureDataType], deprecated("Field `annotations` is deprecated; use `meta` instead."),] = ...
    def export_to_markdown(self, doc: DoclingDocument, add_caption: bool = ..., image_mode: ImageRefMode = ..., image_placeholder: str = ...) -> str:
        """Export picture to Markdown format."""
        ...
    
    def export_to_html(self, doc: DoclingDocument, add_caption: bool = ..., image_mode: ImageRefMode = ...) -> str:
        """Export picture to HTML format."""
        ...
    
    @deprecated("Use export_to_doctags() instead.")
    def export_to_document_tokens(self, *args, **kwargs): # -> str:
        r"""Export to DocTags format."""
        ...
    
    def export_to_doctags(self, doc: DoclingDocument, new_line: str = ..., xsize: int = ..., ysize: int = ..., add_location: bool = ..., add_caption: bool = ..., add_content: bool = ...): # -> str:
        r"""Export picture to document tokens format.

        :param doc: "DoclingDocument":
        :param new_line: str (Default value = "")  Deprecated
        :param xsize: int:  (Default value = 500)
        :param ysize: int:  (Default value = 500)
        :param add_location: bool:  (Default value = True)
        :param add_caption: bool:  (Default value = True)
        :param add_content: bool:  (Default value = True)
        :param # not used at the moment

        """
        ...
    
    def get_annotations(self) -> Sequence[BaseAnnotation]:
        """Get the annotations of this PictureItem."""
        ...
    


TableAnnotationType = Annotated[Union[DescriptionAnnotation, MiscAnnotation,], Field(discriminator="kind"),]
class TableItem(FloatingItem):
    """TableItem."""
    data: TableData
    label: typing.Literal[DocItemLabel.DOCUMENT_INDEX, DocItemLabel.TABLE,] = ...
    annotations: Annotated[List[TableAnnotationType], deprecated("Field `annotations` is deprecated; use `meta` instead."),] = ...
    @model_validator(mode="before")
    @classmethod
    def migrate_annotations_to_meta(cls, data: Any) -> Any:
        """Migrate the `annotations` field to `meta`."""
        ...
    
    def export_to_dataframe(self, doc: Optional[DoclingDocument] = ...) -> pd.DataFrame:
        """Export the table as a Pandas DataFrame."""
        ...
    
    def export_to_markdown(self, doc: Optional[DoclingDocument] = ...) -> str:
        """Export the table as markdown."""
        ...
    
    def export_to_html(self, doc: Optional[DoclingDocument] = ..., add_caption: bool = ...) -> str:
        """Export the table as html."""
        ...
    
    def export_to_otsl(self, doc: DoclingDocument, add_cell_location: bool = ..., add_cell_text: bool = ..., xsize: int = ..., ysize: int = ..., **kwargs: Any) -> str:
        """Export the table as OTSL."""
        ...
    
    @deprecated("Use export_to_doctags() instead.")
    def export_to_document_tokens(self, *args, **kwargs): # -> str:
        r"""Export to DocTags format."""
        ...
    
    def export_to_doctags(self, doc: DoclingDocument, new_line: str = ..., xsize: int = ..., ysize: int = ..., add_location: bool = ..., add_cell_location: bool = ..., add_cell_text: bool = ..., add_caption: bool = ...): # -> str:
        r"""Export table to document tokens format.

        :param doc: "DoclingDocument":
        :param new_line: str (Default value = "")  Deprecated
        :param xsize: int:  (Default value = 500)
        :param ysize: int:  (Default value = 500)
        :param add_location: bool:  (Default value = True)
        :param add_cell_location: bool:  (Default value = True)
        :param add_cell_text: bool:  (Default value = True)
        :param add_caption: bool:  (Default value = True)

        """
        ...
    
    @validate_call
    def add_annotation(self, annotation: TableAnnotationType) -> None:
        """Add an annotation to the table."""
        ...
    
    def get_annotations(self) -> Sequence[BaseAnnotation]:
        """Get the annotations of this TableItem."""
        ...
    


class GraphCell(BaseModel):
    """GraphCell."""
    label: GraphCellLabel
    cell_id: int
    text: str
    orig: str
    prov: Optional[ProvenanceItem] = ...
    item_ref: Optional[RefItem] = ...


class GraphLink(BaseModel):
    """GraphLink."""
    label: GraphLinkLabel
    source_cell_id: int
    target_cell_id: int
    ...


class GraphData(BaseModel):
    """GraphData."""
    cells: List[GraphCell] = ...
    links: List[GraphLink] = ...
    @field_validator("links")
    @classmethod
    def validate_links(cls, links, info):
        """Ensure that each link is valid."""
        ...
    


class KeyValueItem(FloatingItem):
    """KeyValueItem."""
    label: typing.Literal[DocItemLabel.KEY_VALUE_REGION] = ...
    graph: GraphData
    def export_to_document_tokens(self, doc: DoclingDocument, new_line: str = ..., xsize: int = ..., ysize: int = ..., add_location: bool = ..., add_content: bool = ...): # -> str:
        r"""Export key value item to document tokens format.

        :param doc: "DoclingDocument":
        :param new_line: str (Default value = "")  Deprecated
        :param xsize: int:  (Default value = 500)
        :param ysize: int:  (Default value = 500)
        :param add_location: bool:  (Default value = True)
        :param add_content: bool:  (Default value = True)

        """
        ...
    


class FormItem(FloatingItem):
    """FormItem."""
    label: typing.Literal[DocItemLabel.FORM] = ...
    graph: GraphData


ContentItem = Annotated[Union[TextItem, TitleItem, SectionHeaderItem, ListItem, CodeItem, FormulaItem, PictureItem, TableItem, KeyValueItem,], Field(discriminator="label"),]
class PageItem(BaseModel):
    """PageItem."""
    size: Size
    image: Optional[ImageRef] = ...
    page_no: int


class DoclingDocument(BaseModel):
    """DoclingDocument."""
    schema_name: typing.Literal["DoclingDocument"] = ...
    version: Annotated[str, StringConstraints(pattern=VERSION_PATTERN, strict=True)] = ...
    name: str
    origin: Optional[DocumentOrigin] = ...
    furniture: Annotated[GroupItem, Field(deprecated=True)] = ...
    body: GroupItem = ...
    groups: List[Union[ListGroup, InlineGroup, GroupItem]] = ...
    texts: List[Union[TitleItem, SectionHeaderItem, ListItem, CodeItem, FormulaItem, TextItem]] = ...
    pictures: List[PictureItem] = ...
    tables: List[TableItem] = ...
    key_value_items: List[KeyValueItem] = ...
    form_items: List[FormItem] = ...
    pages: Dict[int, PageItem] = ...
    @model_validator(mode="before")
    @classmethod
    def transform_to_content_layer(cls, data: dict) -> dict:
        """transform_to_content_layer."""
        ...
    
    def append_child_item(self, *, child: NodeItem, parent: Optional[NodeItem] = ...) -> None:
        """Adds an item."""
        ...
    
    def insert_item_after_sibling(self, *, new_item: NodeItem, sibling: NodeItem) -> None:
        """Inserts an item, given its node_item instance, after other as a sibling."""
        ...
    
    def insert_item_before_sibling(self, *, new_item: NodeItem, sibling: NodeItem) -> None:
        """Inserts an item, given its node_item instance, before other as a sibling."""
        ...
    
    def delete_items(self, *, node_items: List[NodeItem]) -> None:
        """Deletes an item, given its instance or ref, and any children it has."""
        ...
    
    def replace_item(self, *, new_item: NodeItem, old_item: NodeItem) -> None:
        """Replace item with new item."""
        ...
    
    def add_list_group(self, name: Optional[str] = ..., parent: Optional[NodeItem] = ..., content_layer: Optional[ContentLayer] = ...) -> ListGroup:
        """add_list_group."""
        ...
    
    @deprecated("Use add_list_group() instead.")
    def add_ordered_list(self, name: Optional[str] = ..., parent: Optional[NodeItem] = ..., content_layer: Optional[ContentLayer] = ...) -> GroupItem:
        """add_ordered_list."""
        ...
    
    @deprecated("Use add_list_group() instead.")
    def add_unordered_list(self, name: Optional[str] = ..., parent: Optional[NodeItem] = ..., content_layer: Optional[ContentLayer] = ...) -> GroupItem:
        """add_unordered_list."""
        ...
    
    def add_inline_group(self, name: Optional[str] = ..., parent: Optional[NodeItem] = ..., content_layer: Optional[ContentLayer] = ...) -> InlineGroup:
        """add_inline_group."""
        ...
    
    def add_group(self, label: Optional[GroupLabel] = ..., name: Optional[str] = ..., parent: Optional[NodeItem] = ..., content_layer: Optional[ContentLayer] = ...) -> GroupItem:
        """add_group.

        :param label: Optional[GroupLabel]:  (Default value = None)
        :param name: Optional[str]:  (Default value = None)
        :param parent: Optional[NodeItem]:  (Default value = None)

        """
        ...
    
    def add_list_item(self, text: str, enumerated: bool = ..., marker: Optional[str] = ..., orig: Optional[str] = ..., prov: Optional[ProvenanceItem] = ..., parent: Optional[NodeItem] = ..., content_layer: Optional[ContentLayer] = ..., formatting: Optional[Formatting] = ..., hyperlink: Optional[Union[AnyUrl, Path]] = ...): # -> ListItem:
        """add_list_item.

        :param label: str:
        :param text: str:
        :param orig: Optional[str]:  (Default value = None)
        :param prov: Optional[ProvenanceItem]:  (Default value = None)
        :param parent: Optional[NodeItem]:  (Default value = None)

        """
        ...
    
    def add_text(self, label: DocItemLabel, text: str, orig: Optional[str] = ..., prov: Optional[ProvenanceItem] = ..., parent: Optional[NodeItem] = ..., content_layer: Optional[ContentLayer] = ..., formatting: Optional[Formatting] = ..., hyperlink: Optional[Union[AnyUrl, Path]] = ...): # -> TitleItem | ListItem | SectionHeaderItem | CodeItem | FormulaItem | TextItem:
        """add_text.

        :param label: str:
        :param text: str:
        :param orig: Optional[str]:  (Default value = None)
        :param prov: Optional[ProvenanceItem]:  (Default value = None)
        :param parent: Optional[NodeItem]:  (Default value = None)

        """
        ...
    
    def add_table(self, data: TableData, caption: Optional[Union[TextItem, RefItem]] = ..., prov: Optional[ProvenanceItem] = ..., parent: Optional[NodeItem] = ..., label: DocItemLabel = ..., content_layer: Optional[ContentLayer] = ..., annotations: Optional[list[TableAnnotationType]] = ...): # -> TableItem:
        """add_table.

        :param data: TableData:
        :param caption: Optional[Union[TextItem, RefItem]]:  (Default value = None)
        :param prov: Optional[ProvenanceItem]:  (Default value = None)
        :param parent: Optional[NodeItem]:  (Default value = None)
        :param label: DocItemLabel:  (Default value = DocItemLabel.TABLE)

        """
        ...
    
    def add_picture(self, annotations: Optional[List[PictureDataType]] = ..., image: Optional[ImageRef] = ..., caption: Optional[Union[TextItem, RefItem]] = ..., prov: Optional[ProvenanceItem] = ..., parent: Optional[NodeItem] = ..., content_layer: Optional[ContentLayer] = ...): # -> PictureItem:
        """add_picture.

        :param data: Optional[List[PictureData]]: (Default value = None)
        :param caption: Optional[Union[TextItem:
        :param RefItem]]:  (Default value = None)
        :param prov: Optional[ProvenanceItem]:  (Default value = None)
        :param parent: Optional[NodeItem]:  (Default value = None)
        """
        ...
    
    def add_title(self, text: str, orig: Optional[str] = ..., prov: Optional[ProvenanceItem] = ..., parent: Optional[NodeItem] = ..., content_layer: Optional[ContentLayer] = ..., formatting: Optional[Formatting] = ..., hyperlink: Optional[Union[AnyUrl, Path]] = ...): # -> TitleItem:
        """add_title.

        :param text: str:
        :param orig: Optional[str]:  (Default value = None)
        :param level: LevelNumber:  (Default value = 1)
        :param prov: Optional[ProvenanceItem]:  (Default value = None)
        :param parent: Optional[NodeItem]:  (Default value = None)
        """
        ...
    
    def add_code(self, text: str, code_language: Optional[CodeLanguageLabel] = ..., orig: Optional[str] = ..., caption: Optional[Union[TextItem, RefItem]] = ..., prov: Optional[ProvenanceItem] = ..., parent: Optional[NodeItem] = ..., content_layer: Optional[ContentLayer] = ..., formatting: Optional[Formatting] = ..., hyperlink: Optional[Union[AnyUrl, Path]] = ...): # -> CodeItem:
        """add_code.

        :param text: str:
        :param code_language: Optional[str]: (Default value = None)
        :param orig: Optional[str]:  (Default value = None)
        :param caption: Optional[Union[TextItem:
        :param RefItem]]:  (Default value = None)
        :param prov: Optional[ProvenanceItem]:  (Default value = None)
        :param parent: Optional[NodeItem]:  (Default value = None)
        """
        ...
    
    def add_formula(self, text: str, orig: Optional[str] = ..., prov: Optional[ProvenanceItem] = ..., parent: Optional[NodeItem] = ..., content_layer: Optional[ContentLayer] = ..., formatting: Optional[Formatting] = ..., hyperlink: Optional[Union[AnyUrl, Path]] = ...): # -> FormulaItem:
        """add_formula.

        :param text: str:
        :param orig: Optional[str]:  (Default value = None)
        :param level: LevelNumber:  (Default value = 1)
        :param prov: Optional[ProvenanceItem]:  (Default value = None)
        :param parent: Optional[NodeItem]:  (Default value = None)
        """
        ...
    
    def add_heading(self, text: str, orig: Optional[str] = ..., level: LevelNumber = ..., prov: Optional[ProvenanceItem] = ..., parent: Optional[NodeItem] = ..., content_layer: Optional[ContentLayer] = ..., formatting: Optional[Formatting] = ..., hyperlink: Optional[Union[AnyUrl, Path]] = ...): # -> SectionHeaderItem:
        """add_heading.

        :param label: DocItemLabel:
        :param text: str:
        :param orig: Optional[str]:  (Default value = None)
        :param level: LevelNumber:  (Default value = 1)
        :param prov: Optional[ProvenanceItem]:  (Default value = None)
        :param parent: Optional[NodeItem]:  (Default value = None)
        """
        ...
    
    def add_key_values(self, graph: GraphData, prov: Optional[ProvenanceItem] = ..., parent: Optional[NodeItem] = ...): # -> KeyValueItem:
        """add_key_values.

        :param graph: GraphData:
        :param prov: Optional[ProvenanceItem]:  (Default value = None)
        :param parent: Optional[NodeItem]:  (Default value = None)
        """
        ...
    
    def add_form(self, graph: GraphData, prov: Optional[ProvenanceItem] = ..., parent: Optional[NodeItem] = ...): # -> FormItem:
        """add_form.

        :param graph: GraphData:
        :param prov: Optional[ProvenanceItem]:  (Default value = None)
        :param parent: Optional[NodeItem]:  (Default value = None)
        """
        ...
    
    def insert_list_group(self, sibling: NodeItem, name: Optional[str] = ..., content_layer: Optional[ContentLayer] = ..., after: bool = ...) -> ListGroup:
        """Creates a new ListGroup item and inserts it into the document.

        :param sibling: NodeItem:
        :param name: Optional[str]:  (Default value = None)
        :param content_layer: Optional[ContentLayer]:  (Default value = None)
        :param after: bool:  (Default value = True)

        :returns: ListGroup: The newly created ListGroup item.
        """
        ...
    
    def insert_inline_group(self, sibling: NodeItem, name: Optional[str] = ..., content_layer: Optional[ContentLayer] = ..., after: bool = ...) -> InlineGroup:
        """Creates a new InlineGroup item and inserts it into the document.

        :param sibling: NodeItem:
        :param name: Optional[str]:  (Default value = None)
        :param content_layer: Optional[ContentLayer]:  (Default value = None)
        :param after: bool:  (Default value = True)

        :returns: InlineGroup: The newly created InlineGroup item.
        """
        ...
    
    def insert_group(self, sibling: NodeItem, label: Optional[GroupLabel] = ..., name: Optional[str] = ..., content_layer: Optional[ContentLayer] = ..., after: bool = ...) -> GroupItem:
        """Creates a new GroupItem item and inserts it into the document.

        :param sibling: NodeItem:
        :param label: Optional[GroupLabel]:  (Default value = None)
        :param name: Optional[str]:  (Default value = None)
        :param content_layer: Optional[ContentLayer]:  (Default value = None)
        :param after: bool:  (Default value = True)

        :returns: GroupItem: The newly created GroupItem.
        """
        ...
    
    def insert_list_item(self, sibling: NodeItem, text: str, enumerated: bool = ..., marker: Optional[str] = ..., orig: Optional[str] = ..., prov: Optional[ProvenanceItem] = ..., content_layer: Optional[ContentLayer] = ..., formatting: Optional[Formatting] = ..., hyperlink: Optional[Union[AnyUrl, Path]] = ..., after: bool = ...) -> ListItem:
        """Creates a new ListItem item and inserts it into the document.

        :param sibling: NodeItem:
        :param text: str:
        :param enumerated: bool:  (Default value = False)
        :param marker: Optional[str]:  (Default value = None)
        :param orig: Optional[str]:  (Default value = None)
        :param prov: Optional[ProvenanceItem]:  (Default value = None)
        :param content_layer: Optional[ContentLayer]:  (Default value = None)
        :param formatting: Optional[Formatting]:  (Default value = None)
        :param hyperlink: Optional[Union[AnyUrl, Path]]:  (Default value = None)
        :param after: bool:  (Default value = True)

        :returns: ListItem: The newly created ListItem item.
        """
        ...
    
    def insert_text(self, sibling: NodeItem, label: DocItemLabel, text: str, orig: Optional[str] = ..., prov: Optional[ProvenanceItem] = ..., content_layer: Optional[ContentLayer] = ..., formatting: Optional[Formatting] = ..., hyperlink: Optional[Union[AnyUrl, Path]] = ..., after: bool = ...) -> TextItem:
        """Creates a new TextItem item and inserts it into the document.

        :param sibling: NodeItem:
        :param label: DocItemLabel:
        :param text: str:
        :param orig: Optional[str]:  (Default value = None)
        :param prov: Optional[ProvenanceItem]:  (Default value = None)
        :param content_layer: Optional[ContentLayer]:  (Default value = None)
        :param formatting: Optional[Formatting]:  (Default value = None)
        :param hyperlink: Optional[Union[AnyUrl, Path]]:  (Default value = None)
        :param after: bool:  (Default value = True)

        :returns: TextItem: The newly created TextItem item.
        """
        ...
    
    def insert_table(self, sibling: NodeItem, data: TableData, caption: Optional[Union[TextItem, RefItem]] = ..., prov: Optional[ProvenanceItem] = ..., label: DocItemLabel = ..., content_layer: Optional[ContentLayer] = ..., annotations: Optional[list[TableAnnotationType]] = ..., after: bool = ...) -> TableItem:
        """Creates a new TableItem item and inserts it into the document.

        :param sibling: NodeItem:
        :param data: TableData:
        :param caption: Optional[Union[TextItem, RefItem]]:  (Default value = None)
        :param prov: Optional[ProvenanceItem]:  (Default value = None)
        :param label: DocItemLabel:  (Default value = DocItemLabel.TABLE)
        :param content_layer: Optional[ContentLayer]:  (Default value = None)
        :param annotations: Optional[List[TableAnnotationType]]: (Default value = None)
        :param after: bool:  (Default value = True)

        :returns: TableItem: The newly created TableItem item.
        """
        ...
    
    def insert_picture(self, sibling: NodeItem, annotations: Optional[List[PictureDataType]] = ..., image: Optional[ImageRef] = ..., caption: Optional[Union[TextItem, RefItem]] = ..., prov: Optional[ProvenanceItem] = ..., content_layer: Optional[ContentLayer] = ..., after: bool = ...) -> PictureItem:
        """Creates a new PictureItem item and inserts it into the document.

        :param sibling: NodeItem:
        :param annotations: Optional[List[PictureDataType]]: (Default value = None)
        :param image: Optional[ImageRef]:  (Default value = None)
        :param caption: Optional[Union[TextItem, RefItem]]:  (Default value = None)
        :param prov: Optional[ProvenanceItem]:  (Default value = None)
        :param content_layer: Optional[ContentLayer]:  (Default value = None)
        :param after: bool:  (Default value = True)

        :returns: PictureItem: The newly created PictureItem item.
        """
        ...
    
    def insert_title(self, sibling: NodeItem, text: str, orig: Optional[str] = ..., prov: Optional[ProvenanceItem] = ..., content_layer: Optional[ContentLayer] = ..., formatting: Optional[Formatting] = ..., hyperlink: Optional[Union[AnyUrl, Path]] = ..., after: bool = ...) -> TitleItem:
        """Creates a new TitleItem item and inserts it into the document.

        :param sibling: NodeItem:
        :param text: str:
        :param orig: Optional[str]:  (Default value = None)
        :param prov: Optional[ProvenanceItem]:  (Default value = None)
        :param content_layer: Optional[ContentLayer]:  (Default value = None)
        :param formatting: Optional[Formatting]:  (Default value = None)
        :param hyperlink: Optional[Union[AnyUrl, Path]]:  (Default value = None)
        :param after: bool:  (Default value = True)

        :returns: TitleItem: The newly created TitleItem item.
        """
        ...
    
    def insert_code(self, sibling: NodeItem, text: str, code_language: Optional[CodeLanguageLabel] = ..., orig: Optional[str] = ..., caption: Optional[Union[TextItem, RefItem]] = ..., prov: Optional[ProvenanceItem] = ..., content_layer: Optional[ContentLayer] = ..., formatting: Optional[Formatting] = ..., hyperlink: Optional[Union[AnyUrl, Path]] = ..., after: bool = ...) -> CodeItem:
        """Creates a new CodeItem item and inserts it into the document.

        :param sibling: NodeItem:
        :param text: str:
        :param code_language: Optional[str]: (Default value = None)
        :param orig: Optional[str]:  (Default value = None)
        :param caption: Optional[Union[TextItem, RefItem]]:  (Default value = None)
        :param prov: Optional[ProvenanceItem]:  (Default value = None)
        :param content_layer: Optional[ContentLayer]:  (Default value = None)
        :param formatting: Optional[Formatting]:  (Default value = None)
        :param hyperlink: Optional[Union[AnyUrl, Path]]:  (Default value = None)
        :param after: bool:  (Default value = True)

        :returns: CodeItem: The newly created CodeItem item.
        """
        ...
    
    def insert_formula(self, sibling: NodeItem, text: str, orig: Optional[str] = ..., prov: Optional[ProvenanceItem] = ..., content_layer: Optional[ContentLayer] = ..., formatting: Optional[Formatting] = ..., hyperlink: Optional[Union[AnyUrl, Path]] = ..., after: bool = ...) -> FormulaItem:
        """Creates a new FormulaItem item and inserts it into the document.

        :param sibling: NodeItem:
        :param text: str:
        :param orig: Optional[str]:  (Default value = None)
        :param prov: Optional[ProvenanceItem]:  (Default value = None)
        :param content_layer: Optional[ContentLayer]:  (Default value = None)
        :param formatting: Optional[Formatting]:  (Default value = None)
        :param hyperlink: Optional[Union[AnyUrl, Path]]:  (Default value = None)
        :param after: bool:  (Default value = True)

        :returns: FormulaItem: The newly created FormulaItem item.
        """
        ...
    
    def insert_heading(self, sibling: NodeItem, text: str, orig: Optional[str] = ..., level: LevelNumber = ..., prov: Optional[ProvenanceItem] = ..., content_layer: Optional[ContentLayer] = ..., formatting: Optional[Formatting] = ..., hyperlink: Optional[Union[AnyUrl, Path]] = ..., after: bool = ...) -> SectionHeaderItem:
        """Creates a new SectionHeaderItem item and inserts it into the document.

        :param sibling: NodeItem:
        :param text: str:
        :param orig: Optional[str]:  (Default value = None)
        :param level: LevelNumber:  (Default value = 1)
        :param prov: Optional[ProvenanceItem]:  (Default value = None)
        :param content_layer: Optional[ContentLayer]:  (Default value = None)
        :param formatting: Optional[Formatting]:  (Default value = None)
        :param hyperlink: Optional[Union[AnyUrl, Path]]:  (Default value = None)
        :param after: bool:  (Default value = True)

        :returns: SectionHeaderItem: The newly created SectionHeaderItem item.
        """
        ...
    
    def insert_key_values(self, sibling: NodeItem, graph: GraphData, prov: Optional[ProvenanceItem] = ..., after: bool = ...) -> KeyValueItem:
        """Creates a new KeyValueItem item and inserts it into the document.

        :param sibling: NodeItem:
        :param graph: GraphData:
        :param prov: Optional[ProvenanceItem]:  (Default value = None)
        :param after: bool:  (Default value = True)

        :returns: KeyValueItem: The newly created KeyValueItem item.
        """
        ...
    
    def insert_form(self, sibling: NodeItem, graph: GraphData, prov: Optional[ProvenanceItem] = ..., after: bool = ...) -> FormItem:
        """Creates a new FormItem item and inserts it into the document.

        :param sibling: NodeItem:
        :param graph: GraphData:
        :param prov: Optional[ProvenanceItem]:  (Default value = None)
        :param after: bool:  (Default value = True)

        :returns: FormItem: The newly created FormItem item.
        """
        ...
    
    def delete_items_range(self, *, start: NodeItem, end: NodeItem, start_inclusive: bool = ..., end_inclusive: bool = ...) -> None:
        """Deletes all NodeItems and their children in the range from the start NodeItem to the end NodeItem.

        :param start: NodeItem:  The starting NodeItem of the range
        :param end: NodeItem:  The ending NodeItem of the range
        :param start_inclusive: bool:  (Default value = True):  If True, the start NodeItem will also be deleted
        :param end_inclusive: bool:  (Default value = True):  If True, the end NodeItem will also be deleted

        :returns: None
        """
        ...
    
    def extract_items_range(self, *, start: NodeItem, end: NodeItem, start_inclusive: bool = ..., end_inclusive: bool = ..., delete: bool = ...) -> DoclingDocument:
        """Extracts NodeItems and children in the range from the start NodeItem to the end as a new DoclingDocument.

        :param start: NodeItem:  The starting NodeItem of the range (must be a direct child of the document body)
        :param end: NodeItem:  The ending NodeItem of the range  (must be a direct child of the document body)
        :param start_inclusive: bool:  (Default value = True):  If True, the start NodeItem will also be extracted
        :param end_inclusive: bool:  (Default value = True):  If True, the end NodeItem will also be extracted
        :param delete: bool:  (Default value = False):  If True, extracted items are deleted in the original document

        :returns: DoclingDocument: A new document containing the extracted NodeItems and their children
        """
        ...
    
    def insert_document(self, doc: DoclingDocument, sibling: NodeItem, after: bool = ...) -> None:
        """Inserts the content from the body of a DoclingDocument into this document at a specific position.

        :param doc: DoclingDocument: The document whose content will be inserted
        :param sibling: NodeItem: The NodeItem after/before which the new items will be inserted
        :param after: bool: If True, insert after the sibling; if False, insert before (Default value = True)

        :returns: None
        """
        ...
    
    def add_document(self, doc: DoclingDocument, parent: Optional[NodeItem] = ...) -> None:
        """Adds the content from the body of a DoclingDocument to this document under a specific parent.

        :param doc: DoclingDocument: The document whose content will be added
        :param parent: Optional[NodeItem]: The parent NodeItem under which new items are added (Default value = None)

        :returns: None
        """
        ...
    
    def add_node_items(self, node_items: List[NodeItem], doc: DoclingDocument, parent: Optional[NodeItem] = ...) -> None:
        """Adds multiple NodeItems and their children under a parent in this document.

        :param node_items: list[NodeItem]: The NodeItems to be added
        :param doc: DoclingDocument: The document to which the NodeItems and their children belong
        :param parent: Optional[NodeItem]: The parent NodeItem under which new items are added (Default value = None)

        :returns: None
        """
        ...
    
    def insert_node_items(self, sibling: NodeItem, node_items: List[NodeItem], doc: DoclingDocument, after: bool = ...) -> None:
        """Insert multiple NodeItems and their children at a specific position in the document.

        :param sibling: NodeItem: The NodeItem after/before which the new items will be inserted
        :param node_items: list[NodeItem]: The NodeItems to be inserted
        :param doc: DoclingDocument: The document to which the NodeItems and their children belong
        :param after: bool: If True, insert after the sibling; if False, insert before (Default value = True)

        :returns: None
        """
        ...
    
    def num_pages(self): # -> int:
        """num_pages."""
        ...
    
    def validate_tree(self, root: NodeItem) -> bool:
        """validate_tree."""
        ...
    
    def iterate_items(self, root: Optional[NodeItem] = ..., with_groups: bool = ..., traverse_pictures: bool = ..., page_no: Optional[int] = ..., included_content_layers: Optional[set[ContentLayer]] = ..., _level: int = ...) -> typing.Iterable[Tuple[NodeItem, int]]:
        """Iterate elements with level."""
        ...
    
    def print_element_tree(self): # -> None:
        """Print_element_tree."""
        ...
    
    def export_to_element_tree(self) -> str:
        """Export_to_element_tree."""
        ...
    
    def save_as_json(self, filename: Union[str, Path], artifacts_dir: Optional[Path] = ..., image_mode: ImageRefMode = ..., indent: int = ..., coord_precision: Optional[int] = ..., confid_precision: Optional[int] = ...): # -> None:
        """Save as json."""
        ...
    
    @classmethod
    def load_from_json(cls, filename: Union[str, Path]) -> DoclingDocument:
        """load_from_json.

        :param filename: The filename to load a saved DoclingDocument from a .json.
        :type filename: Path

        :returns: The loaded DoclingDocument.
        :rtype: DoclingDocument

        """
        ...
    
    def save_as_yaml(self, filename: Union[str, Path], artifacts_dir: Optional[Path] = ..., image_mode: ImageRefMode = ..., default_flow_style: bool = ..., coord_precision: Optional[int] = ..., confid_precision: Optional[int] = ...): # -> None:
        """Save as yaml."""
        ...
    
    @classmethod
    def load_from_yaml(cls, filename: Union[str, Path]) -> DoclingDocument:
        """load_from_yaml.

        Args:
            filename: The filename to load a YAML-serialized DoclingDocument from.

        Returns:
            DoclingDocument: the loaded DoclingDocument
        """
        ...
    
    def export_to_dict(self, mode: str = ..., by_alias: bool = ..., exclude_none: bool = ..., coord_precision: Optional[int] = ..., confid_precision: Optional[int] = ...) -> Dict[str, Any]:
        """Export to dict."""
        ...
    
    def save_as_markdown(self, filename: Union[str, Path], artifacts_dir: Optional[Path] = ..., delim: str = ..., from_element: int = ..., to_element: int = ..., labels: Optional[set[DocItemLabel]] = ..., strict_text: bool = ..., escape_html: bool = ..., escaping_underscores: bool = ..., image_placeholder: str = ..., image_mode: ImageRefMode = ..., indent: int = ..., text_width: int = ..., page_no: Optional[int] = ..., included_content_layers: Optional[set[ContentLayer]] = ..., page_break_placeholder: Optional[str] = ..., include_annotations: bool = ..., *, mark_meta: bool = ..., use_legacy_annotations: bool = ...): # -> None:
        """Save to markdown."""
        ...
    
    def export_to_markdown(self, delim: str = ..., from_element: int = ..., to_element: int = ..., labels: Optional[set[DocItemLabel]] = ..., strict_text: bool = ..., escape_html: bool = ..., escape_underscores: bool = ..., image_placeholder: str = ..., enable_chart_tables: bool = ..., image_mode: ImageRefMode = ..., indent: int = ..., text_width: int = ..., page_no: Optional[int] = ..., included_content_layers: Optional[set[ContentLayer]] = ..., page_break_placeholder: Optional[str] = ..., include_annotations: bool = ..., mark_annotations: bool = ..., *, use_legacy_annotations: bool = ..., allowed_meta_names: Optional[set[str]] = ..., blocked_meta_names: Optional[set[str]] = ..., mark_meta: bool = ...) -> str:
        r"""Serialize to Markdown.

        Operates on a slice of the document's body as defined through arguments
        from_element and to_element; defaulting to the whole document.

        :param delim: Deprecated.
        :type delim: str = "\n\n"
        :param from_element: Body slicing start index (inclusive).
                (Default value = 0).
        :type from_element: int = 0
        :param to_element: Body slicing stop index
                (exclusive). (Default value = maxint).
        :type to_element: int = sys.maxsize
        :param labels: The set of document labels to include in the export. None falls
            back to the system-defined default.
        :type labels: Optional[set[DocItemLabel]] = None
        :param strict_text: Deprecated.
        :type strict_text: bool = False
        :param escape_html: bool: Whether to escape HTML reserved characters in the
            text content of the document. (Default value = True).
        :param escape_underscores: bool: Whether to escape underscores in the
            text content of the document. (Default value = True).
        :type escape_underscores: bool = True
        :param image_placeholder: The placeholder to include to position
            images in the markdown. (Default value = "\<!-- image --\>").
        :type image_placeholder: str = "<!-- image -->"
        :param image_mode: The mode to use for including images in the
            markdown. (Default value = ImageRefMode.PLACEHOLDER).
        :type image_mode: ImageRefMode = ImageRefMode.PLACEHOLDER
        :param indent: The indent in spaces of the nested lists.
            (Default value = 4).
        :type indent: int = 4
        :param included_content_layers: The set of layels to include in the export. None
            falls back to the system-defined default.
        :type included_content_layers: Optional[set[ContentLayer]] = None
        :param page_break_placeholder: The placeholder to include for marking page
            breaks. None means no page break placeholder will be used.
        :type page_break_placeholder: Optional[str] = None
        :param include_annotations: bool: Whether to include annotations in the export.
            (Default value = True).
        :type include_annotations: bool = True
        :param mark_annotations: bool: Whether to mark annotations in the export; only
            relevant if include_annotations is True. (Default value = False).
        :type mark_annotations: bool = False
        :param use_legacy_annotations: bool: Whether to use legacy annotation serialization.
            (Default value = False).
        :type use_legacy_annotations: bool = False
        :param mark_meta: bool: Whether to mark meta in the export; only
            relevant if use_legacy_annotations is False. (Default value = False).
        :type mark_meta: bool = False
        :returns: The exported Markdown representation.
        :rtype: str
        :param allowed_meta_names: Optional[set[str]]: Meta names to allow; None means all meta names are allowed.
        :type allowed_meta_names: Optional[set[str]] = None
        :param blocked_meta_names: Optional[set[str]]: Meta names to block; takes precedence over allowed_meta_names.
        :type blocked_meta_names: Optional[set[str]] = None
        """
        ...
    
    def export_to_text(self, delim: str = ..., from_element: int = ..., to_element: int = ..., labels: Optional[set[DocItemLabel]] = ...) -> str:
        """export_to_text."""
        ...
    
    def save_as_html(self, filename: Union[str, Path], artifacts_dir: Optional[Path] = ..., from_element: int = ..., to_element: int = ..., labels: Optional[set[DocItemLabel]] = ..., image_mode: ImageRefMode = ..., formula_to_mathml: bool = ..., page_no: Optional[int] = ..., html_lang: str = ..., html_head: str = ..., included_content_layers: Optional[set[ContentLayer]] = ..., split_page_view: bool = ..., include_annotations: bool = ...): # -> None:
        """Save to HTML."""
        ...
    
    def export_to_html(self, from_element: int = ..., to_element: int = ..., labels: Optional[set[DocItemLabel]] = ..., enable_chart_tables: bool = ..., image_mode: ImageRefMode = ..., formula_to_mathml: bool = ..., page_no: Optional[int] = ..., html_lang: str = ..., html_head: str = ..., included_content_layers: Optional[set[ContentLayer]] = ..., split_page_view: bool = ..., include_annotations: bool = ...) -> str:
        r"""Serialize to HTML."""
        ...
    
    @staticmethod
    def load_from_doctags(doctag_document: DocTagsDocument, document_name: str = ...) -> DoclingDocument:
        r"""Load Docling document from lists of DocTags and Images."""
        ...
    
    @deprecated("Use save_as_doctags instead.")
    def save_as_document_tokens(self, *args, **kwargs): # -> None:
        r"""Save the document content to a DocumentToken format."""
        ...
    
    def save_as_doctags(self, filename: Union[str, Path], delim: str = ..., from_element: int = ..., to_element: int = ..., labels: Optional[set[DocItemLabel]] = ..., xsize: int = ..., ysize: int = ..., add_location: bool = ..., add_content: bool = ..., add_page_index: bool = ..., add_table_cell_location: bool = ..., add_table_cell_text: bool = ..., minified: bool = ...): # -> None:
        r"""Save the document content to DocTags format."""
        ...
    
    @deprecated("Use export_to_doctags() instead.")
    def export_to_document_tokens(self, *args, **kwargs): # -> str:
        r"""Export to DocTags format."""
        ...
    
    def export_to_doctags(self, delim: str = ..., from_element: int = ..., to_element: int = ..., labels: Optional[set[DocItemLabel]] = ..., xsize: int = ..., ysize: int = ..., add_location: bool = ..., add_content: bool = ..., add_page_index: bool = ..., add_table_cell_location: bool = ..., add_table_cell_text: bool = ..., minified: bool = ..., pages: Optional[set[int]] = ...) -> str:
        r"""Exports the document content to a DocumentToken format.

        Operates on a slice of the document's body as defined through arguments
        from_element and to_element; defaulting to the whole main_text.

        :param delim: str:  (Default value = "")  Deprecated
        :param from_element: int:  (Default value = 0)
        :param to_element: Optional[int]:  (Default value = None)
        :param labels: set[DocItemLabel]
        :param xsize: int:  (Default value = 500)
        :param ysize: int:  (Default value = 500)
        :param add_location: bool:  (Default value = True)
        :param add_content: bool:  (Default value = True)
        :param add_page_index: bool:  (Default value = True)
        :param # table specific flagsadd_table_cell_location: bool
        :param add_table_cell_text: bool:  (Default value = True)
        :param minified: bool:  (Default value = False)
        :param pages: set[int]: (Default value = None)
        :returns: The content of the document formatted as a DocTags string.
        :rtype: str
        """
        ...
    
    def add_page(self, page_no: int, size: Size, image: Optional[ImageRef] = ...) -> PageItem:
        """add_page.

        :param page_no: int:
        :param size: Size:

        """
        ...
    
    def get_visualization(self, show_label: bool = ..., show_branch_numbering: bool = ..., viz_mode: Literal["reading_order", "key_value"] = ..., show_cell_id: bool = ...) -> dict[Optional[int], PILImage.Image]:
        """Get visualization of the document as images by page.

        :param show_label: Show labels on elements (applies to all visualizers).
        :type show_label: bool
        :param show_branch_numbering: Show branch numbering (reading order visualizer only).
        :type show_branch_numbering: bool
        :param visualizer: Which visualizer to use. One of 'reading_order' (default), 'key_value'.
        :type visualizer: str
        :param show_cell_id: Show cell IDs (key value visualizer only).
        :type show_cell_id: bool

        :returns: Dictionary mapping page numbers to PIL images.
        :rtype: dict[Optional[int], PILImage.Image]
        """
        ...
    
    @field_validator("version")
    @classmethod
    def check_version_is_compatible(cls, v: str) -> str:
        """Check if this document version is compatible with SDK schema version."""
        ...
    
    @model_validator(mode="after")
    def validate_document(self) -> Self:
        """validate_document."""
        ...
    
    @model_validator(mode="after")
    def validate_misplaced_list_items(self): # -> Self:
        """validate_misplaced_list_items."""
        ...
    
    class _DocIndex(BaseModel):
        """A document merge buffer."""
        groups: list[GroupItem] = ...
        texts: list[TextItem] = ...
        pictures: list[PictureItem] = ...
        tables: list[TableItem] = ...
        key_value_items: list[KeyValueItem] = ...
        form_items: list[FormItem] = ...
        pages: dict[int, PageItem] = ...
        _body: Optional[GroupItem] = ...
        _max_page: int = ...
        _names: list[str] = ...
        def get_item_list(self, key: str) -> list[NodeItem]:
            ...
        
        def index(self, doc: DoclingDocument, page_nrs: Optional[set[int]] = ...) -> None:
            ...
        
        def get_name(self) -> str:
            ...
        
    
    
    def filter(self, page_nrs: Optional[set[int]] = ...) -> DoclingDocument:
        """Create a new document based on the provided filter parameters."""
        ...
    
    @classmethod
    def concatenate(cls, docs: Sequence[DoclingDocument]) -> DoclingDocument:
        """Concatenate multiple documents into a single document."""
        ...
    
    def add_table_cell(self, table_item: TableItem, cell: TableCell) -> None:
        """Add a table cell to the table."""
        ...
    


BasePictureData = BaseAnnotation
PictureDescriptionData = DescriptionAnnotation
PictureMiscData = MiscAnnotation
UnorderedList = ListGroup
