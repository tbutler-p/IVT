"""
This type stub file was generated by pyright.
"""

from enum import Enum
from typing import Any, List, Tuple
from pydantic import BaseModel

"""Models for the base data types."""
class ImageRefMode(str, Enum):
    """ImageRefMode."""
    PLACEHOLDER = ...
    EMBEDDED = ...
    REFERENCED = ...


class CoordOrigin(str, Enum):
    """CoordOrigin."""
    TOPLEFT = ...
    BOTTOMLEFT = ...


class PydanticSerCtxKey(str, Enum):
    """Pydantic serialization context keys."""
    COORD_PREC = ...
    CONFID_PREC = ...


def round_pydantic_float(val: float, ctx: Any, precision_ctx_key: PydanticSerCtxKey) -> float:
    """Round float, provided the precision is available in the context."""
    ...

class Size(BaseModel):
    """Size."""
    width: float = ...
    height: float = ...
    def as_tuple(self): # -> tuple[float, float]:
        """as_tuple."""
        ...
    


class BoundingBox(BaseModel):
    """BoundingBox."""
    l: float
    t: float
    r: float
    b: float
    coord_origin: CoordOrigin = ...
    @property
    def width(self): # -> float:
        """width."""
        ...
    
    @property
    def height(self): # -> float:
        """height."""
        ...
    
    def resize_by_scale(self, x_scale: float, y_scale: float): # -> BoundingBox:
        """resize_by_scale."""
        ...
    
    def scale_to_size(self, old_size: Size, new_size: Size): # -> BoundingBox:
        """scale_to_size."""
        ...
    
    def scaled(self, scale: float): # -> BoundingBox:
        """scaled."""
        ...
    
    def normalized(self, page_size: Size): # -> BoundingBox:
        """normalized."""
        ...
    
    def expand_by_scale(self, x_scale: float, y_scale: float) -> BoundingBox:
        """expand_to_size."""
        ...
    
    def as_tuple(self) -> Tuple[float, float, float, float]:
        """as_tuple."""
        ...
    
    @classmethod
    def from_tuple(cls, coord: Tuple[float, ...], origin: CoordOrigin): # -> BoundingBox:
        """from_tuple.

        :param coord: Tuple[float:
        :param ...]:
        :param origin: CoordOrigin:

        """
        ...
    
    def area(self) -> float:
        """area."""
        ...
    
    def intersection_area_with(self, other: BoundingBox) -> float:
        """Calculate the intersection area with another bounding box."""
        ...
    
    def intersection_over_union(self, other: BoundingBox, eps: float = ...) -> float:
        """intersection_over_union."""
        ...
    
    def intersection_over_self(self, other: BoundingBox, eps: float = ...) -> float:
        """intersection_over_self."""
        ...
    
    def to_bottom_left_origin(self, page_height: float) -> BoundingBox:
        """to_bottom_left_origin.

        :param page_height:

        """
        ...
    
    def to_top_left_origin(self, page_height: float) -> BoundingBox:
        """to_top_left_origin.

        :param page_height:

        """
        ...
    
    def overlaps(self, other: BoundingBox) -> bool:
        """overlaps."""
        ...
    
    def overlaps_horizontally(self, other: BoundingBox) -> bool:
        """Check if two bounding boxes overlap horizontally."""
        ...
    
    def overlaps_vertically(self, other: BoundingBox) -> bool:
        """Check if two bounding boxes overlap vertically."""
        ...
    
    def overlaps_vertically_with_iou(self, other: BoundingBox, iou: float) -> bool:
        """overlaps_y_with_iou."""
        ...
    
    def is_left_of(self, other: BoundingBox) -> bool:
        """is_left_of."""
        ...
    
    def is_strictly_left_of(self, other: BoundingBox, eps: float = ...) -> bool:
        """is_strictly_left_of."""
        ...
    
    def is_above(self, other: BoundingBox) -> bool:
        """is_above."""
        ...
    
    def is_strictly_above(self, other: BoundingBox, eps: float = ...) -> bool:
        """is_strictly_above."""
        ...
    
    def is_horizontally_connected(self, elem_i: BoundingBox, elem_j: BoundingBox) -> bool:
        """is_horizontally_connected."""
        ...
    
    @classmethod
    def enclosing_bbox(cls, boxes: List[BoundingBox]) -> BoundingBox:
        """Create a bounding box that covers all of the given boxes."""
        ...
    
    def x_overlap_with(self, other: BoundingBox) -> float:
        """Calculates the horizontal overlap with another bounding box."""
        ...
    
    def y_overlap_with(self, other: BoundingBox) -> float:
        """Calculates the vertical overlap with another bounding box, respecting coordinate origin."""
        ...
    
    def union_area_with(self, other: BoundingBox) -> float:
        """Calculates the union area with another bounding box."""
        ...
    
    def x_union_with(self, other: BoundingBox) -> float:
        """Calculates the horizontal union dimension with another bounding box."""
        ...
    
    def y_union_with(self, other: BoundingBox) -> float:
        """Calculates the vertical union dimension with another bounding box, respecting coordinate origin."""
        ...
    


