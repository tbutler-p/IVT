"""
This type stub file was generated by pyright.
"""

import typing
from enum import Enum
from pathlib import Path
from typing import Annotated, Any, Dict, Iterator, List, Literal, NamedTuple, Optional, Tuple, Union
from PIL import Image as PILImage
from pydantic import AnyUrl, BaseModel, Field, model_validator
from docling_core.types.doc.base import BoundingBox, CoordOrigin
from docling_core.types.doc.document import ImageRef

"""Datastructures for PaginatedDocument."""
_logger = ...
PageNumber = typing.Annotated[int, Field(ge=1)]
class TextCellUnit(str, Enum):
    """Enumeration of text cell units for segmented PDF page processing."""
    CHAR = ...
    WORD = ...
    LINE = ...
    def __str__(self) -> str:
        """Return string representation of the enum value."""
        ...
    


class PdfPageBoundaryType(str, Enum):
    """Enumeration of PDF page boundary types."""
    ART_BOX = ...
    BLEED_BOX = ...
    CROP_BOX = ...
    MEDIA_BOX = ...
    TRIM_BOX = ...
    def __str__(self) -> str:
        """Return string representation of the enum value."""
        ...
    


ColorChannelValue = Annotated[int, Field(ge=0, le=255)]
class ColorRGBA(BaseModel):
    """Model representing an RGBA color value."""
    r: ColorChannelValue
    g: ColorChannelValue
    b: ColorChannelValue
    a: ColorChannelValue = ...
    def as_tuple(self) -> tuple[int, int, int, int]:
        """Return the color components as a tuple."""
        ...
    
    def __iter__(self): # -> Generator[ColorChannelValue, Any, None]:
        """Yield the color components for iteration."""
        ...
    


class Coord2D(NamedTuple):
    """A 2D coordinate with x and y components."""
    x: float
    y: float
    ...


class BoundingRectangle(BaseModel):
    """Model representing a rectangular boundary with four corner points."""
    r_x0: float
    r_y0: float
    r_x1: float
    r_y1: float
    r_x2: float
    r_y2: float
    r_x3: float
    r_y3: float
    coord_origin: CoordOrigin = ...
    @property
    def width(self) -> float:
        """Calculate the width of the rectangle."""
        ...
    
    @property
    def height(self) -> float:
        """Calculate the height of the rectangle."""
        ...
    
    @property
    def angle(self) -> float:
        """Calculate the angle of the rectangle in radians (0-2pi range)."""
        ...
    
    @property
    def angle_360(self) -> int:
        """Calculate the angle of the rectangle in degrees (0-360 range)."""
        ...
    
    @property
    def centre(self): # -> tuple[float, float]:
        """Calculate the center point of the rectangle."""
        ...
    
    def to_bounding_box(self) -> BoundingBox:
        """Convert to a BoundingBox representation."""
        ...
    
    @classmethod
    def from_bounding_box(cls, bbox: BoundingBox) -> BoundingRectangle:
        """Convert a BoundingBox into a BoundingRectangle."""
        ...
    
    def to_polygon(self) -> List[Coord2D]:
        """Convert to a list of point coordinates forming a polygon."""
        ...
    
    def to_bottom_left_origin(self, page_height: float) -> BoundingRectangle:
        """Convert coordinates to use bottom-left origin.

        Args:
            page_height: The height of the page

        Returns:
            BoundingRectangle with bottom-left origin
        """
        ...
    
    def to_top_left_origin(self, page_height: float) -> BoundingRectangle:
        """Convert coordinates to use top-left origin.

        Args:
            page_height: The height of the page

        Returns:
            BoundingRectangle with top-left origin
        """
        ...
    


class OrderedElement(BaseModel):
    """Base model for elements that have an ordering index."""
    index: int = ...


class ColorMixin(BaseModel):
    """Mixin class that adds color attributes to a model."""
    rgba: ColorRGBA = ...


class TextDirection(str, Enum):
    """Enumeration for text direction options."""
    LEFT_TO_RIGHT = ...
    RIGHT_TO_LEFT = ...
    UNSPECIFIED = ...


class TextCell(ColorMixin, OrderedElement):
    """Model representing a text cell with positioning and content information."""
    rect: BoundingRectangle
    text: str
    orig: str
    text_direction: TextDirection = ...
    confidence: float = ...
    from_ocr: bool
    def to_bounding_box(self) -> BoundingBox:
        """Convert the cell rectangle to a BoundingBox."""
        ...
    
    def to_bottom_left_origin(self, page_height: float): # -> None:
        """Convert the cell's coordinates to use bottom-left origin.

        Args:
            page_height: The height of the page
        """
        ...
    
    def to_top_left_origin(self, page_height: float): # -> None:
        """Convert the cell's coordinates to use top-left origin.

        Args:
            page_height: The height of the page
        """
        ...
    


class PdfCellRenderingMode(int, Enum):
    """Text Rendering Mode, according to PDF32000."""
    FILL_TEXT = ...
    STROKE_TEXT = ...
    FILL_THEN_STROKE = ...
    INVISIBLE = ...
    FILL_AND_CLIPPING = ...
    STROKE_AND_CLIPPING = ...
    FILL_THEN_STROKE_AND_CLIPPING = ...
    ONLY_CLIPPING = ...
    UNKNOWN = ...


class PdfTextCell(TextCell):
    """Specialized text cell for PDF documents with font information."""
    rendering_mode: PdfCellRenderingMode
    widget: bool
    font_key: str
    font_name: str
    from_ocr: Literal[False] = ...
    @model_validator(mode="before")
    @classmethod
    def update_ltr_property(cls, data: dict) -> dict:
        """Update text direction property from left_to_right flag."""
        ...
    


class BitmapResource(OrderedElement):
    """Model representing a bitmap resource with positioning and URI information."""
    rect: BoundingRectangle
    uri: Optional[AnyUrl] = ...
    def to_bottom_left_origin(self, page_height: float): # -> None:
        """Convert the resource's coordinates to use bottom-left origin.

        Args:
            page_height: The height of the page
        """
        ...
    
    def to_top_left_origin(self, page_height: float): # -> None:
        """Convert the resource's coordinates to use top-left origin.

        Args:
            page_height: The height of the page
        """
        ...
    


class PdfLine(ColorMixin, OrderedElement):
    """Model representing a line in a PDF document."""
    parent_id: int
    points: List[Coord2D]
    width: float = ...
    coord_origin: CoordOrigin = ...
    def __len__(self) -> int:
        """Return the number of points in the line."""
        ...
    
    def iterate_segments(self) -> Iterator[Tuple[Coord2D, Coord2D]]:
        """Iterate through line segments defined by consecutive point pairs."""
        ...
    
    def to_bottom_left_origin(self, page_height: float): # -> Self | None:
        """Convert the line's coordinates to use bottom-left origin.

        Args:
            page_height: The height of the page
        """
        ...
    
    def to_top_left_origin(self, page_height: float): # -> Self | None:
        """Convert the line's coordinates to use top-left origin.

        Args:
            page_height: The height of the page
        """
        ...
    


class PageGeometry(BaseModel):
    """Model representing dimensions of a page."""
    angle: float
    rect: BoundingRectangle
    @property
    def width(self): # -> float:
        """Get the width of the page."""
        ...
    
    @property
    def height(self): # -> float:
        """Get the height of the page."""
        ...
    
    @property
    def origin(self): # -> tuple[float, float]:
        """Get the origin point of the page."""
        ...
    


class PdfPageGeometry(PageGeometry):
    """Extended dimensions model specific to PDF pages with boundary types."""
    boundary_type: PdfPageBoundaryType
    art_bbox: BoundingBox
    bleed_bbox: BoundingBox
    crop_bbox: BoundingBox
    media_bbox: BoundingBox
    trim_bbox: BoundingBox
    @property
    def width(self): # -> float:
        """Get the width of the PDF page based on crop box."""
        ...
    
    @property
    def height(self): # -> float:
        """Get the height of the PDF page based on crop box."""
        ...
    
    @property
    def origin(self): # -> tuple[float, float]:
        """Get the origin point of the PDF page based on crop box."""
        ...
    


class SegmentedPage(BaseModel):
    """Model representing a segmented page with text cells and resources."""
    dimension: PageGeometry
    bitmap_resources: List[BitmapResource] = ...
    char_cells: List[TextCell] = ...
    word_cells: List[TextCell] = ...
    textline_cells: List[TextCell] = ...
    has_chars: bool = ...
    has_words: bool = ...
    has_lines: bool = ...
    image: Optional[ImageRef] = ...
    @model_validator(mode="after")
    def validate_page(self) -> SegmentedPage:
        """Validate page."""
        ...
    
    def iterate_cells(self, unit_type: TextCellUnit) -> Iterator[TextCell]:
        """Iterate through text cells of the specified unit type.

        Args:
            unit_type: Type of text unit to iterate through

        Returns:
            Iterator of text cells

        Raises:
            ValueError: If an incompatible unit type is provided
        """
        ...
    


class SegmentedPdfPage(SegmentedPage):
    """Extended segmented page model specific to PDF documents."""
    dimension: PdfPageGeometry
    lines: List[PdfLine] = ...
    char_cells: List[Union[PdfTextCell, TextCell]]
    word_cells: List[Union[PdfTextCell, TextCell]]
    textline_cells: List[Union[PdfTextCell, TextCell]]
    def get_cells_in_bbox(self, cell_unit: TextCellUnit, bbox: BoundingBox, ios: float = ...) -> List[Union[PdfTextCell, TextCell]]:
        """Get text cells that are within the specified bounding box.

        Args:
            cell_unit: Type of text unit to check
            bbox: Bounding box to check against
            ios: Minimum intersection over self ratio

        Returns:
            List of text cells within the bounding box
        """
        ...
    
    def export_to_dict(self) -> Dict[str, Any]:
        """Export the page data to a dictionary.

        Returns:
            Dictionary representation of the page
        """
        ...
    
    def save_as_json(self, filename: Union[str, Path], indent: int = ...): # -> None:
        """Save the page data as a JSON file.

        Args:
            filename: Path to save the JSON file
            indent: Indentation level for JSON formatting
        """
        ...
    
    @classmethod
    def load_from_json(cls, filename: Union[str, Path]) -> SegmentedPdfPage:
        """Load page data from a JSON file.

        Args:
            filename: Path to the JSON file

        Returns:
            Instantiated SegmentedPdfPage object
        """
        ...
    
    def crop_text(self, cell_unit: TextCellUnit, bbox: BoundingBox, eps: float = ...) -> str:
        """Extract text from cells within the specified bounding box.

        Args:
            cell_unit: Type of text unit to extract
            bbox: Bounding box to extract from
            eps: Epsilon value for position comparison
        Returns:
            Extracted text from the cells
        """
        ...
    
    def export_to_textlines(self, cell_unit: TextCellUnit, add_location: bool = ..., add_fontkey: bool = ..., add_fontname: bool = ..., add_text_direction: bool = ...) -> List[str]:
        """Export text cells as formatted text lines.

        Args:
            cell_unit: Type of text unit to export
            add_location: Whether to include position information
            add_fontkey: Whether to include font key information
            add_fontname: Whether to include font name information

        Returns:
            List of formatted text lines
        """
        ...
    
    def render_as_image(self, cell_unit: TextCellUnit, boundary_type: PdfPageBoundaryType = ..., draw_cells_bbox: bool = ..., draw_cells_text: bool = ..., draw_cells_bl: bool = ..., draw_cells_tr: bool = ..., cell_outline: str = ..., cell_color: str = ..., cell_alpha: float = ..., cell_bl_color: str = ..., cell_bl_outline: str = ..., cell_bl_alpha: float = ..., cell_bl_radius: float = ..., cell_tr_color: str = ..., cell_tr_outline: str = ..., cell_tr_alpha: float = ..., cell_tr_radius: float = ..., draw_bitmap_resources: bool = ..., bitmap_resources_outline: str = ..., bitmap_resources_fill: str = ..., bitmap_resources_alpha: float = ..., draw_lines: bool = ..., line_color: str = ..., line_width: int = ..., line_alpha: float = ..., draw_annotations: bool = ..., annotations_outline: str = ..., annotations_color: str = ..., annotations_alpha: float = ..., draw_crop_box: bool = ..., cropbox_outline: str = ..., cropbox_width: int = ..., cropbox_alpha: float = ...) -> PILImage.Image:
        """Render the page as an image with various visualization options.

        Args:
            cell_unit: Type of text unit to render
            boundary_type: Type of page boundary to use
            draw_cells_bbox: Whether to draw bounding boxes for cells
            draw_cells_text: Whether to draw text content of cells
            draw_cells_bl: Whether to draw bottom left points of cells
            draw_cells_tr: Whether to draw top right points of cells
            cell_outline: Color for cell outlines
            cell_color: Fill color for cells
            cell_alpha: Alpha value for cell visualization
            cell_bl_color: Color for bottom left points
            cell_bl_outline: Outline color for bottom left points
            cell_bl_alpha: Alpha value for bottom left points
            cell_bl_radius: Radius for bottom left points
            cell_tr_color: Color for top right points
            cell_tr_outline: Outline color for top right points
            cell_tr_alpha: Alpha value for top right points
            cell_tr_radius: Radius for top right points
            draw_bitmap_resources: Whether to draw bitmap resources
            bitmap_resources_outline: Outline color for bitmap resources
            bitmap_resources_fill: Fill color for bitmap resources
            bitmap_resources_alpha: Alpha value for bitmap resources
            draw_lines: Whether to draw lines
            line_color: Color for lines
            line_width: Width for lines
            line_alpha: Alpha value for lines
            draw_annotations: Whether to draw annotations
            annotations_outline: Outline color for annotations
            annotations_color: Fill color for annotations
            annotations_alpha: Alpha value for annotations
            draw_crop_box: Whether to draw crop box
            cropbox_outline: Color for crop box outline
            cropbox_width: Width for crop box outline
            cropbox_alpha: Alpha value for crop box

        Returns:
            PIL Image of the rendered page
        """
        ...
    


class PdfMetaData(BaseModel):
    """Model representing PDF metadata extracted from XML."""
    xml: str = ...
    data: Dict[str, str] = ...
    def initialise(self): # -> None:
        """Initialize metadata by parsing the XML content."""
        ...
    


class PdfTableOfContents(BaseModel):
    """Model representing a PDF table of contents entry with hierarchical structure."""
    text: str
    orig: str = ...
    marker: str = ...
    children: List[PdfTableOfContents] = ...
    def export_to_dict(self, mode: str = ...) -> Dict[str, Any]:
        """Export the table of contents to a dictionary.

        Args:
            mode: Serialization mode

        Returns:
            Dictionary representation of the table of contents
        """
        ...
    
    def save_as_json(self, filename: Union[str, Path], indent: int = ...): # -> None:
        """Save the table of contents as a JSON file.

        Args:
            filename: Path to save the JSON file
            indent: Indentation level for JSON formatting
        """
        ...
    
    @classmethod
    def load_from_json(cls, filename: Union[str, Path]) -> PdfTableOfContents:
        """Load table of contents from a JSON file.

        Args:
            filename: Path to the JSON file

        Returns:
            Instantiated PdfTableOfContents object
        """
        ...
    


class ParsedPdfDocument(BaseModel):
    """Model representing a completely parsed PDF document with all components."""
    pages: Dict[PageNumber, SegmentedPdfPage] = ...
    meta_data: Optional[PdfMetaData] = ...
    table_of_contents: Optional[PdfTableOfContents] = ...
    def iterate_pages(self) -> Iterator[Tuple[int, SegmentedPdfPage]]:
        """Iterate through all pages in the document.

        Returns:
            Iterator of (page number, page) tuples
        """
        ...
    
    def export_to_dict(self, mode: str = ...) -> Dict[str, Any]:
        """Export the document to a dictionary.

        Args:
            mode: Serialization mode

        Returns:
            Dictionary representation of the document
        """
        ...
    
    def save_as_json(self, filename: Union[str, Path], indent: int = ...): # -> None:
        """Save the document as a JSON file.

        Args:
            filename: Path to save the JSON file
            indent: Indentation level for JSON formatting
        """
        ...
    
    @classmethod
    def load_from_json(cls, filename: Union[str, Path]) -> ParsedPdfDocument:
        """Load document from a JSON file.

        Args:
            filename: Path to the JSON file

        Returns:
            Instantiated ParsedPdfDocument object
        """
        ...
    


