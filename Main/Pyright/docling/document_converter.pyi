"""
This type stub file was generated by pyright.
"""

from collections.abc import Iterable, Iterator
from pathlib import Path
from typing import Optional, Type, Union
from pydantic import ConfigDict, model_validator, validate_call
from typing_extensions import Self
from docling.backend.abstract_backend import AbstractDocumentBackend
from docling.backend.xml.uspto_backend import PatentUsptoDocumentBackend
from docling.datamodel.backend_options import BackendOptions, HTMLBackendOptions, MarkdownBackendOptions, PdfBackendOptions
from docling.datamodel.base_models import BaseFormatOption, DocumentStream, InputFormat
from docling.datamodel.document import ConversionResult
from docling.datamodel.settings import PageRange
from docling.pipeline.base_pipeline import BasePipeline

"""
This type stub file was generated by pyright.
"""
_log = ...
_PIPELINE_CACHE_LOCK = ...
class FormatOption(BaseFormatOption):
    pipeline_cls: Type[BasePipeline]
    backend_options: Optional[BackendOptions] = ...
    @model_validator(mode="after")
    def set_optional_field_default(self) -> Self:
        ...
    


class CsvFormatOption(FormatOption):
    pipeline_cls: Type = ...
    backend: Type[AbstractDocumentBackend] = ...


class ExcelFormatOption(FormatOption):
    pipeline_cls: Type = ...
    backend: Type[AbstractDocumentBackend] = ...


class WordFormatOption(FormatOption):
    pipeline_cls: Type = ...
    backend: Type[AbstractDocumentBackend] = ...


class PowerpointFormatOption(FormatOption):
    pipeline_cls: Type = ...
    backend: Type[AbstractDocumentBackend] = ...


class MarkdownFormatOption(FormatOption):
    pipeline_cls: Type = ...
    backend: Type[AbstractDocumentBackend] = ...
    backend_options: Optional[MarkdownBackendOptions] = ...


class AsciiDocFormatOption(FormatOption):
    pipeline_cls: Type = ...
    backend: Type[AbstractDocumentBackend] = ...


class HTMLFormatOption(FormatOption):
    pipeline_cls: Type = ...
    backend: Type[AbstractDocumentBackend] = ...
    backend_options: Optional[HTMLBackendOptions] = ...


class PatentUsptoFormatOption(FormatOption):
    pipeline_cls: Type = ...
    backend: Type[PatentUsptoDocumentBackend] = ...


class XMLJatsFormatOption(FormatOption):
    pipeline_cls: Type = ...
    backend: Type[AbstractDocumentBackend] = ...


class ImageFormatOption(FormatOption):
    pipeline_cls: Type = ...
    backend: Type[AbstractDocumentBackend] = ...


class PdfFormatOption(FormatOption):
    pipeline_cls: Type = ...
    backend: Type[AbstractDocumentBackend] = ...
    backend_options: Optional[PdfBackendOptions] = ...


class AudioFormatOption(FormatOption):
    pipeline_cls: Type = ...
    backend: Type[AbstractDocumentBackend] = ...


class DocumentConverter:
    _default_download_filename = ...
    def __init__(self, allowed_formats: Optional[list[InputFormat]] = ..., format_options: Optional[dict[InputFormat, FormatOption]] = ...) -> None:
        ...
    
    def initialize_pipeline(self, format: InputFormat):
        """Initialize the conversion pipeline for the selected format."""
        ...
    
    @validate_call(config=ConfigDict(strict=True))
    def convert(self, source: Union[Path, str, DocumentStream], headers: Optional[dict[str, str]] = ..., raises_on_error: bool = ..., max_num_pages: int = ..., max_file_size: int = ..., page_range: PageRange = ...) -> ConversionResult:
        ...
    
    @validate_call(config=ConfigDict(strict=True))
    def convert_all(self, source: Iterable[Union[Path, str, DocumentStream]], headers: Optional[dict[str, str]] = ..., raises_on_error: bool = ..., max_num_pages: int = ..., max_file_size: int = ..., page_range: PageRange = ...) -> Iterator[ConversionResult]:
        ...
    
    @validate_call(config=ConfigDict(strict=True))
    def convert_string(self, content: str, format: InputFormat, name: Optional[str]) -> ConversionResult:
        ...
    


