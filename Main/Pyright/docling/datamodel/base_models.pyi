"""
This type stub file was generated by pyright.
"""

from enum import Enum
from typing import Optional, TYPE_CHECKING, Type, Union
from docling_core.types.doc import BoundingBox, DocItemLabel, NodeItem, PictureDataType, Size, TableCell
from docling_core.types.doc.page import SegmentedPdfPage, TextCell
from PIL.Image import Image
from pydantic import BaseModel, computed_field
from docling.backend.pdf_backend import PdfPageBackend
from docling.backend.abstract_backend import AbstractDocumentBackend
from docling.datamodel.pipeline_options import PipelineOptions

"""
This type stub file was generated by pyright.
"""
if TYPE_CHECKING:
    ...
class BaseFormatOption(BaseModel):
    """Base class for format options used by _DocumentConversionInput."""
    pipeline_options: Optional[PipelineOptions] = ...
    backend: Type[AbstractDocumentBackend]
    model_config = ...


class ConversionStatus(str, Enum):
    PENDING = ...
    STARTED = ...
    FAILURE = ...
    SUCCESS = ...
    PARTIAL_SUCCESS = ...
    SKIPPED = ...


class InputFormat(str, Enum):
    """A document format supported by document backend parsers."""
    DOCX = ...
    PPTX = ...
    HTML = ...
    IMAGE = ...
    PDF = ...
    ASCIIDOC = ...
    MD = ...
    CSV = ...
    XLSX = ...
    XML_USPTO = ...
    XML_JATS = ...
    METS_GBS = ...
    JSON_DOCLING = ...
    AUDIO = ...
    VTT = ...


class OutputFormat(str, Enum):
    MARKDOWN = ...
    JSON = ...
    HTML = ...
    HTML_SPLIT_PAGE = ...
    TEXT = ...
    DOCTAGS = ...


FormatToExtensions: dict[InputFormat, list[str]] = ...
FormatToMimeType: dict[InputFormat, list[str]] = ...
MimeTypeToFormat: dict[str, list[InputFormat]] = ...
class DocInputType(str, Enum):
    PATH = ...
    STREAM = ...


class DoclingComponentType(str, Enum):
    DOCUMENT_BACKEND = ...
    MODEL = ...
    DOC_ASSEMBLER = ...
    USER_INPUT = ...


class VlmStopReason(str, Enum):
    LENGTH = ...
    STOP_SEQUENCE = ...
    END_OF_SEQUENCE = ...
    UNSPECIFIED = ...


class ErrorItem(BaseModel):
    component_type: DoclingComponentType
    module_name: str
    error_message: str
    ...


class Cluster(BaseModel):
    id: int
    label: DocItemLabel
    bbox: BoundingBox
    confidence: float = ...
    cells: list[TextCell] = ...
    children: list[Cluster] = ...


class BasePageElement(BaseModel):
    label: DocItemLabel
    id: int
    page_no: int
    cluster: Cluster
    text: Optional[str] = ...


class LayoutPrediction(BaseModel):
    clusters: list[Cluster] = ...


class VlmPredictionToken(BaseModel):
    text: str = ...
    token: int = ...
    logprob: float = ...


class VlmPrediction(BaseModel):
    text: str = ...
    generated_tokens: list[VlmPredictionToken] = ...
    generation_time: float = ...
    num_tokens: Optional[int] = ...
    stop_reason: VlmStopReason = ...


class ContainerElement(BasePageElement):
    ...


class Table(BasePageElement):
    otsl_seq: list[str]
    num_rows: int = ...
    num_cols: int = ...
    table_cells: list[TableCell]


class TableStructurePrediction(BaseModel):
    table_map: dict[int, Table] = ...


class TextElement(BasePageElement):
    text: str
    ...


class FigureElement(BasePageElement):
    annotations: list[PictureDataType] = ...
    provenance: Optional[str] = ...
    predicted_class: Optional[str] = ...
    confidence: Optional[float] = ...


class FigureClassificationPrediction(BaseModel):
    figure_count: int = ...
    figure_map: dict[int, FigureElement] = ...


class EquationPrediction(BaseModel):
    equation_count: int = ...
    equation_map: dict[int, TextElement] = ...


class PagePredictions(BaseModel):
    layout: Optional[LayoutPrediction] = ...
    tablestructure: Optional[TableStructurePrediction] = ...
    figures_classification: Optional[FigureClassificationPrediction] = ...
    equations_prediction: Optional[EquationPrediction] = ...
    vlm_response: Optional[VlmPrediction] = ...


PageElement = Union[TextElement, Table, FigureElement, ContainerElement]
class AssembledUnit(BaseModel):
    elements: list[PageElement] = ...
    body: list[PageElement] = ...
    headers: list[PageElement] = ...


class ItemAndImageEnrichmentElement(BaseModel):
    model_config = ...
    item: NodeItem
    image: Image


class Page(BaseModel):
    model_config = ...
    page_no: int
    size: Optional[Size] = ...
    parsed_page: Optional[SegmentedPdfPage] = ...
    predictions: PagePredictions = ...
    assembled: Optional[AssembledUnit] = ...
    _backend: Optional[PdfPageBackend] = ...
    _default_image_scale: float = ...
    _image_cache: dict[float, Image] = ...
    @property
    def cells(self) -> list[TextCell]:
        """Return text cells as a read-only view of parsed_page.textline_cells."""
        ...
    
    def get_image(self, scale: float = ..., max_size: Optional[int] = ..., cropbox: Optional[BoundingBox] = ...) -> Optional[Image]:
        ...
    
    @property
    def image(self) -> Optional[Image]:
        ...
    


class OpenAiChatMessage(BaseModel):
    role: str
    content: str
    ...


class OpenAiResponseChoice(BaseModel):
    index: int
    message: OpenAiChatMessage
    finish_reason: Optional[str]
    ...


class OpenAiResponseUsage(BaseModel):
    prompt_tokens: int
    completion_tokens: int
    total_tokens: int
    ...


class OpenAiApiResponse(BaseModel):
    model_config = ...
    id: str
    model: Optional[str] = ...
    choices: list[OpenAiResponseChoice]
    created: int
    usage: OpenAiResponseUsage


ScoreValue = float
class QualityGrade(str, Enum):
    POOR = ...
    FAIR = ...
    GOOD = ...
    EXCELLENT = ...
    UNSPECIFIED = ...


class PageConfidenceScores(BaseModel):
    parse_score: ScoreValue = ...
    layout_score: ScoreValue = ...
    table_score: ScoreValue = ...
    ocr_score: ScoreValue = ...
    @computed_field
    @property
    def mean_grade(self) -> QualityGrade:
        ...
    
    @computed_field
    @property
    def low_grade(self) -> QualityGrade:
        ...
    
    @computed_field
    @property
    def mean_score(self) -> ScoreValue:
        ...
    
    @computed_field
    @property
    def low_score(self) -> ScoreValue:
        ...
    


class ConfidenceReport(PageConfidenceScores):
    pages: dict[int, PageConfidenceScores] = ...
    @computed_field
    @property
    def mean_score(self) -> ScoreValue:
        ...
    
    @computed_field
    @property
    def low_score(self) -> ScoreValue:
        ...
    


