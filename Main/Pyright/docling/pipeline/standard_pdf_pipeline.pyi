"""
This type stub file was generated by pyright.
"""

from dataclasses import dataclass
from typing import Any, Callable, List, Optional, Tuple
from docling.backend.abstract_backend import AbstractDocumentBackend
from docling.datamodel.base_models import Page
from docling.datamodel.document import ConversionResult
from docling.datamodel.pipeline_options import ThreadedPdfPipelineOptions
from docling.pipeline.base_pipeline import ConvertPipeline

"""Thread-safe, production-ready PDF pipeline
================================================
A self-contained, thread-safe PDF conversion pipeline exploiting parallelism between pipeline stages and models.

* **Per-run isolation** - every :py:meth:`execute` call uses its own bounded queues and worker
  threads so that concurrent invocations never share mutable state.
* **Deterministic run identifiers** - pages are tracked with an internal *run-id* instead of
  relying on :pyfunc:`id`, which may clash after garbage collection.
* **Explicit back-pressure & shutdown** - producers block on full queues; queue *close()*
  propagates downstream so stages terminate deterministically without sentinels.
* **Minimal shared state** - heavyweight models are initialised once per pipeline instance
  and only read by worker threads; no runtime mutability is exposed.
* **Strict typing & clean API usage** - code is fully annotated and respects *coding_rules.md*.
"""
_log = ...
@dataclass
class ThreadedItem:
    """Envelope that travels between pipeline stages."""
    payload: Optional[Page]
    run_id: int
    page_no: int
    conv_res: ConversionResult
    error: Optional[Exception] = ...
    is_failed: bool = ...


@dataclass
class ProcessingResult:
    """Aggregated outcome of a pipeline run."""
    pages: List[Page] = ...
    failed_pages: List[Tuple[int, Exception]] = ...
    total_expected: int = ...
    @property
    def success_count(self) -> int:
        ...
    
    @property
    def failure_count(self) -> int:
        ...
    
    @property
    def is_partial_success(self) -> bool:
        ...
    
    @property
    def is_complete_failure(self) -> bool:
        ...
    


class ThreadedQueue:
    """Bounded queue with blocking put/ get_batch and explicit *close()* semantics."""
    __slots__ = ...
    def __init__(self, max_size: int) -> None:
        ...
    
    def put(self, item: ThreadedItem, timeout: Optional[float] | None = ...) -> bool:
        """Block until queue accepts *item* or is closed.  Returns *False* if closed."""
        ...
    
    def get_batch(self, size: int, timeout: Optional[float] | None = ...) -> List[ThreadedItem]:
        """Return up to *size* items.  Blocks until â‰¥1 item present or queue closed/timeout."""
        ...
    
    def close(self) -> None:
        ...
    
    @property
    def closed(self) -> bool:
        ...
    


class ThreadedPipelineStage:
    """A single pipeline stage backed by one worker thread."""
    def __init__(self, *, name: str, model: Any, batch_size: int, batch_timeout: float, queue_max_size: int, postprocess: Optional[Callable[[ThreadedItem], None]] = ...) -> None:
        ...
    
    def add_output_queue(self, q: ThreadedQueue) -> None:
        ...
    
    def start(self) -> None:
        ...
    
    def stop(self) -> None:
        ...
    


class PreprocessThreadedStage(ThreadedPipelineStage):
    """Pipeline stage that lazily loads PDF backends just-in-time."""
    def __init__(self, *, batch_timeout: float, queue_max_size: int, model: Any) -> None:
        ...
    


@dataclass
class RunContext:
    """Wiring for a single *execute* call."""
    stages: list[ThreadedPipelineStage]
    first_stage: ThreadedPipelineStage
    output_queue: ThreadedQueue
    ...


class StandardPdfPipeline(ConvertPipeline):
    """High-performance PDF pipeline with multi-threaded stages."""
    def __init__(self, pipeline_options: ThreadedPdfPipelineOptions) -> None:
        ...
    
    @classmethod
    def get_default_options(cls) -> ThreadedPdfPipelineOptions:
        ...
    
    @classmethod
    def is_backend_supported(cls, backend: AbstractDocumentBackend) -> bool:
        ...
    


