"""
This type stub file was generated by pyright.
"""

import re
from io import BytesIO
from pathlib import Path
from typing import Annotated, ClassVar, Literal, Optional, Union
from docling_core.types.doc import DoclingDocument
from pydantic import BaseModel, Field, field_validator, model_validator
from pydantic.types import StringConstraints
from typing_extensions import Self, override
from docling.backend.abstract_backend import DeclarativeDocumentBackend
from docling.datamodel.base_models import InputFormat
from docling.datamodel.document import InputDocument

_log = ...
class _WebVTTTimestamp(BaseModel):
    """Model representing a WebVTT timestamp.

    A WebVTT timestamp is always interpreted relative to the current playback position
    of the media data that the WebVTT file is to be synchronized with.
    """
    model_config = ...
    raw: Annotated[str, Field(description="A representation of the WebVTT Timestamp as a single string"),]
    _pattern: ClassVar[re.Pattern] = ...
    _hours: int
    _minutes: int
    _seconds: int
    _millis: int
    @model_validator(mode="after")
    def validate_raw(self) -> Self:
        ...
    
    @property
    def seconds(self) -> float:
        """A representation of the WebVTT Timestamp in seconds"""
        ...
    
    @override
    def __str__(self) -> str:
        ...
    


_WebVTTCueIdentifier = Annotated[str, StringConstraints(strict=True, pattern=r"^(?!.*-->)[^\n\r]+$")]
class _WebVTTCueTimings(BaseModel):
    """Model representating WebVTT cue timings."""
    start: Annotated[_WebVTTTimestamp, Field(description="Start time offset of the cue")]
    end: Annotated[_WebVTTTimestamp, Field(description="End time offset of the cue")]
    @model_validator(mode="after")
    def check_order(self) -> Self:
        ...
    
    @override
    def __str__(self) -> str:
        ...
    


class _WebVTTCueTextSpan(BaseModel):
    """Model representing a WebVTT cue text span."""
    text: str
    span_type: Literal["text"] = ...
    @field_validator("text", mode="after")
    @classmethod
    def validate_text(cls, value: str) -> str:
        ...
    
    @override
    def __str__(self) -> str:
        ...
    


class _WebVTTCueVoiceSpan(BaseModel):
    """Model representing a WebVTT cue voice span."""
    annotation: Annotated[str, Field(description="Cue span start tag annotation text representing the name of thevoice"),]
    classes: Annotated[list[str], Field(description="List of classes representing the cue span's significance"),] = ...
    components: Annotated[list[_WebVTTCueComponent], Field(description="The components representing the cue internal text"),] = ...
    span_type: Literal["v"] = ...
    @field_validator("annotation", mode="after")
    @classmethod
    def validate_annotation(cls, value: str) -> str:
        ...
    
    @field_validator("classes", mode="after")
    @classmethod
    def validate_classes(cls, value: list[str]) -> list[str]:
        ...
    
    @override
    def __str__(self) -> str:
        ...
    


class _WebVTTCueClassSpan(BaseModel):
    span_type: Literal["c"] = ...
    components: list[_WebVTTCueComponent]
    @override
    def __str__(self) -> str:
        ...
    


class _WebVTTCueItalicSpan(BaseModel):
    span_type: Literal["i"] = ...
    components: list[_WebVTTCueComponent]
    @override
    def __str__(self) -> str:
        ...
    


class _WebVTTCueBoldSpan(BaseModel):
    span_type: Literal["b"] = ...
    components: list[_WebVTTCueComponent]
    @override
    def __str__(self) -> str:
        ...
    


class _WebVTTCueUnderlineSpan(BaseModel):
    span_type: Literal["u"] = ...
    components: list[_WebVTTCueComponent]
    @override
    def __str__(self) -> str:
        ...
    


_WebVTTCueComponent = Annotated[Union[_WebVTTCueTextSpan, _WebVTTCueClassSpan, _WebVTTCueItalicSpan, _WebVTTCueBoldSpan, _WebVTTCueUnderlineSpan, _WebVTTCueVoiceSpan,], Field(discriminator="span_type", description="The WebVTT cue component"),]
class _WebVTTCueBlock(BaseModel):
    """Model representing a WebVTT cue block.

    The optional WebVTT cue settings list is not supported.
    The cue payload is limited to the following spans: text, class, italic, bold,
    underline, and voice.
    """
    model_config = ...
    identifier: Optional[_WebVTTCueIdentifier] = ...
    timings: Annotated[_WebVTTCueTimings, Field(description="The WebVTT cue timings")]
    payload: Annotated[list[_WebVTTCueComponent], Field(description="The cue payload")]
    _pattern_block: ClassVar[re.Pattern] = ...
    _pattern_voice_tag: ClassVar[re.Pattern] = ...
    @field_validator("payload", mode="after")
    @classmethod
    def validate_payload(cls, payload):
        ...
    
    @classmethod
    def parse(cls, raw: str) -> _WebVTTCueBlock:
        ...
    
    def __str__(self) -> str:
        ...
    


class _WebVTTFile(BaseModel):
    """A model representing a WebVTT file."""
    cue_blocks: list[_WebVTTCueBlock]
    @staticmethod
    def verify_signature(content: str) -> bool:
        ...
    
    @classmethod
    def parse(cls, raw: str) -> _WebVTTFile:
        ...
    
    def __iter__(self): # -> Iterator[_WebVTTCueBlock]:
        ...
    
    def __getitem__(self, idx):
        ...
    
    def __len__(self): # -> int:
        ...
    


class WebVTTDocumentBackend(DeclarativeDocumentBackend):
    """Declarative backend for WebVTT (.vtt) files.

    This parser reads the content of a WebVTT file and converts
    it to a DoclingDocument, following the W3C specs on https://www.w3.org/TR/webvtt1

    Each cue becomes a TextItem and the items are appended to the
    document body by the cue's start time.
    """
    @override
    def __init__(self, in_doc: InputDocument, path_or_stream: Union[BytesIO, Path]) -> None:
        ...
    
    @override
    def is_valid(self) -> bool:
        ...
    
    @classmethod
    @override
    def supports_pagination(cls) -> bool:
        ...
    
    @override
    def unload(self): # -> None:
        ...
    
    @classmethod
    @override
    def supported_formats(cls) -> set[InputFormat]:
        ...
    
    @override
    def convert(self) -> DoclingDocument:
        ...
    


