"""
This type stub file was generated by pyright.
"""

import typing_extensions
from collections.abc import Generator, Mapping
from typing import Any, Callable, ClassVar, Dict, Literal, TYPE_CHECKING, TypeVar, Union, overload
from pydantic_core import CoreSchema, SchemaSerializer, SchemaValidator
from typing_extensions import Self, TypeAlias, Unpack
from ._internal import _decorators, _forward_ref, _generics, _model_construction, _repr, _utils
from .annotated_handlers import GetCoreSchemaHandler, GetJsonSchemaHandler
from .config import ConfigDict, ExtraValues
from .json_schema import GenerateJsonSchema, JsonSchemaMode, JsonSchemaValue
from .plugin._schema_validator import PluggableSchemaValidator
from inspect import Signature
from pathlib import Path
from ._internal._namespace_utils import MappingNamespace
from ._internal._utils import AbstractSetIntStr, MappingIntStrAny
from .deprecated.parse import Protocol as DeprecatedParseProtocol
from .fields import ComputedFieldInfo, FieldInfo, ModelPrivateAttr

"""Logic for creating models."""
if TYPE_CHECKING:
    ...
__all__ = ('BaseModel', 'create_model')
TupleGenerator: TypeAlias = Generator[tuple[str, Any], None, None]
IncEx: TypeAlias = Union[set[int], set[str], Mapping[int, Union['IncEx', bool]], Mapping[str, Union['IncEx', bool]]]
_object_setattr = ...
_SIMPLE_SETATTR_HANDLERS: Mapping[str, Callable[[BaseModel, str, Any], None]] = ...
class BaseModel(metaclass=_model_construction.ModelMetaclass):
    """!!! abstract "Usage Documentation"
        [Models](../concepts/models.md)

    A base class for creating Pydantic models.

    Attributes:
        __class_vars__: The names of the class variables defined on the model.
        __private_attributes__: Metadata about the private attributes of the model.
        __signature__: The synthesized `__init__` [`Signature`][inspect.Signature] of the model.

        __pydantic_complete__: Whether model building is completed, or if there are still undefined fields.
        __pydantic_core_schema__: The core schema of the model.
        __pydantic_custom_init__: Whether the model has a custom `__init__` function.
        __pydantic_decorators__: Metadata containing the decorators defined on the model.
            This replaces `Model.__validators__` and `Model.__root_validators__` from Pydantic V1.
        __pydantic_generic_metadata__: Metadata for generic models; contains data used for a similar purpose to
            __args__, __origin__, __parameters__ in typing-module generics. May eventually be replaced by these.
        __pydantic_parent_namespace__: Parent namespace of the model, used for automatic rebuilding of models.
        __pydantic_post_init__: The name of the post-init method for the model, if defined.
        __pydantic_root_model__: Whether the model is a [`RootModel`][pydantic.root_model.RootModel].
        __pydantic_serializer__: The `pydantic-core` `SchemaSerializer` used to dump instances of the model.
        __pydantic_validator__: The `pydantic-core` `SchemaValidator` used to validate instances of the model.

        __pydantic_fields__: A dictionary of field names and their corresponding [`FieldInfo`][pydantic.fields.FieldInfo] objects.
        __pydantic_computed_fields__: A dictionary of computed field names and their corresponding [`ComputedFieldInfo`][pydantic.fields.ComputedFieldInfo] objects.

        __pydantic_extra__: A dictionary containing extra values, if [`extra`][pydantic.config.ConfigDict.extra]
            is set to `'allow'`.
        __pydantic_fields_set__: The names of fields explicitly set during instantiation.
        __pydantic_private__: Values of private attributes set on the model instance.
    """
    model_config: ClassVar[ConfigDict] = ...
    __class_vars__: ClassVar[set[str]]
    __private_attributes__: ClassVar[Dict[str, ModelPrivateAttr]]
    __signature__: ClassVar[Signature]
    __pydantic_complete__: ClassVar[bool] = ...
    __pydantic_core_schema__: ClassVar[CoreSchema]
    __pydantic_custom_init__: ClassVar[bool]
    __pydantic_decorators__: ClassVar[_decorators.DecoratorInfos] = ...
    __pydantic_generic_metadata__: ClassVar[_generics.PydanticGenericMetadata]
    __pydantic_parent_namespace__: ClassVar[Dict[str, Any] | None] = ...
    __pydantic_post_init__: ClassVar[None | Literal['model_post_init']]
    __pydantic_root_model__: ClassVar[bool] = ...
    __pydantic_serializer__: ClassVar[SchemaSerializer]
    __pydantic_validator__: ClassVar[SchemaValidator | PluggableSchemaValidator]
    __pydantic_fields__: ClassVar[Dict[str, FieldInfo]]
    __pydantic_setattr_handlers__: ClassVar[Dict[str, Callable[[BaseModel, str, Any], None]]]
    __pydantic_computed_fields__: ClassVar[Dict[str, ComputedFieldInfo]]
    __pydantic_extra__: Dict[str, Any] | None = ...
    __pydantic_fields_set__: set[str] = ...
    __pydantic_private__: Dict[str, Any] | None = ...
    if not TYPE_CHECKING:
        ...
    __slots__ = ...
    def __init__(self, /, **data: Any) -> None:
        """Create a new model by parsing and validating input data from keyword arguments.

        Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be
        validated to form a valid model.

        `self` is explicitly positional-only to allow `self` as a field name.
        """
        ...
    
    @_utils.deprecated_instance_property
    @classmethod
    def model_fields(cls) -> dict[str, FieldInfo]:
        """A mapping of field names to their respective [`FieldInfo`][pydantic.fields.FieldInfo] instances.

        !!! warning
            Accessing this attribute from a model instance is deprecated, and will not work in Pydantic V3.
            Instead, you should access this attribute from the model class.
        """
        ...
    
    @_utils.deprecated_instance_property
    @classmethod
    def model_computed_fields(cls) -> dict[str, ComputedFieldInfo]:
        """A mapping of computed field names to their respective [`ComputedFieldInfo`][pydantic.fields.ComputedFieldInfo] instances.

        !!! warning
            Accessing this attribute from a model instance is deprecated, and will not work in Pydantic V3.
            Instead, you should access this attribute from the model class.
        """
        ...
    
    @property
    def model_extra(self) -> dict[str, Any] | None:
        """Get extra fields set during validation.

        Returns:
            A dictionary of extra fields, or `None` if `config.extra` is not set to `"allow"`.
        """
        ...
    
    @property
    def model_fields_set(self) -> set[str]:
        """Returns the set of fields that have been explicitly set on this model instance.

        Returns:
            A set of strings representing the fields that have been set,
                i.e. that were not filled from defaults.
        """
        ...
    
    @classmethod
    def model_construct(cls, _fields_set: set[str] | None = ..., **values: Any) -> Self:
        """Creates a new instance of the `Model` class with validated data.

        Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.
        Default values are respected, but no other validation is performed.

        !!! note
            `model_construct()` generally respects the `model_config.extra` setting on the provided model.
            That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`
            and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.
            Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in
            an error if extra values are passed, but they will be ignored.

        Args:
            _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,
                this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.
                Otherwise, the field names from the `values` argument will be used.
            values: Trusted or pre-validated data dictionary.

        Returns:
            A new instance of the `Model` class with validated data.
        """
        ...
    
    def model_copy(self, *, update: Mapping[str, Any] | None = ..., deep: bool = ...) -> Self:
        """!!! abstract "Usage Documentation"
            [`model_copy`](../concepts/models.md#model-copy)

        Returns a copy of the model.

        !!! note
            The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This
            might have unexpected side effects if you store anything in it, on top of the model
            fields (e.g. the value of [cached properties][functools.cached_property]).

        Args:
            update: Values to change/add in the new model. Note: the data is not validated
                before creating the new model. You should trust this data.
            deep: Set to `True` to make a deep copy of the model.

        Returns:
            New model instance.
        """
        ...
    
    def model_dump(self, *, mode: Literal['json', 'python'] | str = ..., include: IncEx | None = ..., exclude: IncEx | None = ..., context: Any | None = ..., by_alias: bool | None = ..., exclude_unset: bool = ..., exclude_defaults: bool = ..., exclude_none: bool = ..., exclude_computed_fields: bool = ..., round_trip: bool = ..., warnings: bool | Literal['none', 'warn', 'error'] = ..., fallback: Callable[[Any], Any] | None = ..., serialize_as_any: bool = ...) -> dict[str, Any]:
        """!!! abstract "Usage Documentation"
            [`model_dump`](../concepts/serialization.md#python-mode)

        Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.

        Args:
            mode: The mode in which `to_python` should run.
                If mode is 'json', the output will only contain JSON serializable types.
                If mode is 'python', the output may contain non-JSON-serializable Python objects.
            include: A set of fields to include in the output.
            exclude: A set of fields to exclude from the output.
            context: Additional context to pass to the serializer.
            by_alias: Whether to use the field's alias in the dictionary key if defined.
            exclude_unset: Whether to exclude fields that have not been explicitly set.
            exclude_defaults: Whether to exclude fields that are set to their default value.
            exclude_none: Whether to exclude fields that have a value of `None`.
            exclude_computed_fields: Whether to exclude computed fields.
                While this can be useful for round-tripping, it is usually recommended to use the dedicated
                `round_trip` parameter instead.
            round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
            warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
                "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
            fallback: A function to call when an unknown value is encountered. If not provided,
                a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
            serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.

        Returns:
            A dictionary representation of the model.
        """
        ...
    
    def model_dump_json(self, *, indent: int | None = ..., ensure_ascii: bool = ..., include: IncEx | None = ..., exclude: IncEx | None = ..., context: Any | None = ..., by_alias: bool | None = ..., exclude_unset: bool = ..., exclude_defaults: bool = ..., exclude_none: bool = ..., exclude_computed_fields: bool = ..., round_trip: bool = ..., warnings: bool | Literal['none', 'warn', 'error'] = ..., fallback: Callable[[Any], Any] | None = ..., serialize_as_any: bool = ...) -> str:
        """!!! abstract "Usage Documentation"
            [`model_dump_json`](../concepts/serialization.md#json-mode)

        Generates a JSON representation of the model using Pydantic's `to_json` method.

        Args:
            indent: Indentation to use in the JSON output. If None is passed, the output will be compact.
            ensure_ascii: If `True`, the output is guaranteed to have all incoming non-ASCII characters escaped.
                If `False` (the default), these characters will be output as-is.
            include: Field(s) to include in the JSON output.
            exclude: Field(s) to exclude from the JSON output.
            context: Additional context to pass to the serializer.
            by_alias: Whether to serialize using field aliases.
            exclude_unset: Whether to exclude fields that have not been explicitly set.
            exclude_defaults: Whether to exclude fields that are set to their default value.
            exclude_none: Whether to exclude fields that have a value of `None`.
            exclude_computed_fields: Whether to exclude computed fields.
                While this can be useful for round-tripping, it is usually recommended to use the dedicated
                `round_trip` parameter instead.
            round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
            warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
                "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
            fallback: A function to call when an unknown value is encountered. If not provided,
                a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
            serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.

        Returns:
            A JSON string representation of the model.
        """
        ...
    
    @classmethod
    def model_json_schema(cls, by_alias: bool = ..., ref_template: str = ..., schema_generator: type[GenerateJsonSchema] = ..., mode: JsonSchemaMode = ..., *, union_format: Literal['any_of', 'primitive_type_array'] = ...) -> dict[str, Any]:
        """Generates a JSON schema for a model class.

        Args:
            by_alias: Whether to use attribute aliases or not.
            ref_template: The reference template.
            union_format: The format to use when combining schemas from unions together. Can be one of:

                - `'any_of'`: Use the [`anyOf`](https://json-schema.org/understanding-json-schema/reference/combining#anyOf)
                keyword to combine schemas (the default).
                - `'primitive_type_array'`: Use the [`type`](https://json-schema.org/understanding-json-schema/reference/type)
                keyword as an array of strings, containing each type of the combination. If any of the schemas is not a primitive
                type (`string`, `boolean`, `null`, `integer` or `number`) or contains constraints/metadata, falls back to
                `any_of`.
            schema_generator: To override the logic used to generate the JSON schema, as a subclass of
                `GenerateJsonSchema` with your desired modifications
            mode: The mode in which to generate the schema.

        Returns:
            The JSON schema for the given model class.
        """
        ...
    
    @classmethod
    def model_parametrized_name(cls, params: tuple[type[Any], ...]) -> str:
        """Compute the class name for parametrizations of generic classes.

        This method can be overridden to achieve a custom naming scheme for generic BaseModels.

        Args:
            params: Tuple of types of the class. Given a generic class
                `Model` with 2 type variables and a concrete model `Model[str, int]`,
                the value `(str, int)` would be passed to `params`.

        Returns:
            String representing the new class where `params` are passed to `cls` as type variables.

        Raises:
            TypeError: Raised when trying to generate concrete names for non-generic models.
        """
        ...
    
    def model_post_init(self, context: Any, /) -> None:
        """Override this method to perform additional initialization after `__init__` and `model_construct`.
        This is useful if you want to do some validation that requires the entire model to be initialized.
        """
        ...
    
    @classmethod
    def model_rebuild(cls, *, force: bool = ..., raise_errors: bool = ..., _parent_namespace_depth: int = ..., _types_namespace: MappingNamespace | None = ...) -> bool | None:
        """Try to rebuild the pydantic-core schema for the model.

        This may be necessary when one of the annotations is a ForwardRef which could not be resolved during
        the initial attempt to build the schema, and automatic rebuilding fails.

        Args:
            force: Whether to force the rebuilding of the model schema, defaults to `False`.
            raise_errors: Whether to raise errors, defaults to `True`.
            _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.
            _types_namespace: The types namespace, defaults to `None`.

        Returns:
            Returns `None` if the schema is already "complete" and rebuilding was not required.
            If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.
        """
        ...
    
    @classmethod
    def model_validate(cls, obj: Any, *, strict: bool | None = ..., extra: ExtraValues | None = ..., from_attributes: bool | None = ..., context: Any | None = ..., by_alias: bool | None = ..., by_name: bool | None = ...) -> Self:
        """Validate a pydantic model instance.

        Args:
            obj: The object to validate.
            strict: Whether to enforce types strictly.
            extra: Whether to ignore, allow, or forbid extra data during model validation.
                See the [`extra` configuration value][pydantic.ConfigDict.extra] for details.
            from_attributes: Whether to extract data from object attributes.
            context: Additional context to pass to the validator.
            by_alias: Whether to use the field's alias when validating against the provided input data.
            by_name: Whether to use the field's name when validating against the provided input data.

        Raises:
            ValidationError: If the object could not be validated.

        Returns:
            The validated model instance.
        """
        ...
    
    @classmethod
    def model_validate_json(cls, json_data: str | bytes | bytearray, *, strict: bool | None = ..., extra: ExtraValues | None = ..., context: Any | None = ..., by_alias: bool | None = ..., by_name: bool | None = ...) -> Self:
        """!!! abstract "Usage Documentation"
            [JSON Parsing](../concepts/json.md#json-parsing)

        Validate the given JSON data against the Pydantic model.

        Args:
            json_data: The JSON data to validate.
            strict: Whether to enforce types strictly.
            extra: Whether to ignore, allow, or forbid extra data during model validation.
                See the [`extra` configuration value][pydantic.ConfigDict.extra] for details.
            context: Extra variables to pass to the validator.
            by_alias: Whether to use the field's alias when validating against the provided input data.
            by_name: Whether to use the field's name when validating against the provided input data.

        Returns:
            The validated Pydantic model.

        Raises:
            ValidationError: If `json_data` is not a JSON string or the object could not be validated.
        """
        ...
    
    @classmethod
    def model_validate_strings(cls, obj: Any, *, strict: bool | None = ..., extra: ExtraValues | None = ..., context: Any | None = ..., by_alias: bool | None = ..., by_name: bool | None = ...) -> Self:
        """Validate the given object with string data against the Pydantic model.

        Args:
            obj: The object containing string data to validate.
            strict: Whether to enforce types strictly.
            extra: Whether to ignore, allow, or forbid extra data during model validation.
                See the [`extra` configuration value][pydantic.ConfigDict.extra] for details.
            context: Extra variables to pass to the validator.
            by_alias: Whether to use the field's alias when validating against the provided input data.
            by_name: Whether to use the field's name when validating against the provided input data.

        Returns:
            The validated Pydantic model.
        """
        ...
    
    @classmethod
    def __get_pydantic_core_schema__(cls, source: type[BaseModel], handler: GetCoreSchemaHandler, /) -> CoreSchema:
        ...
    
    @classmethod
    def __get_pydantic_json_schema__(cls, core_schema: CoreSchema, handler: GetJsonSchemaHandler, /) -> JsonSchemaValue:
        """Hook into generating the model's JSON schema.

        Args:
            core_schema: A `pydantic-core` CoreSchema.
                You can ignore this argument and call the handler with a new CoreSchema,
                wrap this CoreSchema (`{'type': 'nullable', 'schema': current_schema}`),
                or just call the handler with the original schema.
            handler: Call into Pydantic's internal JSON schema generation.
                This will raise a `pydantic.errors.PydanticInvalidForJsonSchema` if JSON schema
                generation fails.
                Since this gets called by `BaseModel.model_json_schema` you can override the
                `schema_generator` argument to that function to change JSON schema generation globally
                for a type.

        Returns:
            A JSON schema, as a Python object.
        """
        ...
    
    @classmethod
    def __pydantic_init_subclass__(cls, **kwargs: Any) -> None:
        """This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`
        only after basic class initialization is complete. In particular, attributes like `model_fields` will
        be present when this is called, but forward annotations are not guaranteed to be resolved yet,
        meaning that creating an instance of the class may fail.

        This is necessary because `__init_subclass__` will always be called by `type.__new__`,
        and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that
        `type.__new__` was called in such a manner that the class would already be sufficiently initialized.

        This will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,
        any kwargs passed to the class definition that aren't used internally by Pydantic.

        Args:
            **kwargs: Any keyword arguments passed to the class definition that aren't used internally
                by Pydantic.

        Note:
            You may want to override [`__pydantic_on_complete__()`][pydantic.main.BaseModel.__pydantic_on_complete__]
            instead, which is called once the class and its fields are fully initialized and ready for validation.
        """
        ...
    
    @classmethod
    def __pydantic_on_complete__(cls) -> None:
        """This is called once the class and its fields are fully initialized and ready to be used.

        This typically happens when the class is created (just before
        [`__pydantic_init_subclass__()`][pydantic.main.BaseModel.__pydantic_init_subclass__] is called on the superclass),
        except when forward annotations are used that could not immediately be resolved.
        In that case, it will be called later, when the model is rebuilt automatically or explicitly using
        [`model_rebuild()`][pydantic.main.BaseModel.model_rebuild].
        """
        ...
    
    def __class_getitem__(cls, typevar_values: type[Any] | tuple[type[Any], ...]) -> type[BaseModel] | _forward_ref.PydanticRecursiveRef:
        ...
    
    def __copy__(self) -> Self:
        """Returns a shallow copy of the model."""
        ...
    
    def __deepcopy__(self, memo: dict[int, Any] | None = ...) -> Self:
        """Returns a deep copy of the model."""
        ...
    
    if not TYPE_CHECKING:
        ...
    def __getstate__(self) -> dict[Any, Any]:
        ...
    
    def __setstate__(self, state: dict[Any, Any]) -> None:
        ...
    
    if not TYPE_CHECKING:
        ...
    if TYPE_CHECKING:
        def __init_subclass__(cls, **kwargs: Unpack[ConfigDict]): # -> None:
            """This signature is included purely to help type-checkers check arguments to class declaration, which
            provides a way to conveniently set model_config key/value pairs.

            ```python
            from pydantic import BaseModel

            class MyModel(BaseModel, extra='allow'): ...
            ```

            However, this may be deceiving, since the _actual_ calls to `__init_subclass__` will not receive any
            of the config arguments, and will only receive any keyword arguments passed during class initialization
            that are _not_ expected keys in ConfigDict. (This is due to the way `ModelMetaclass.__new__` works.)

            Args:
                **kwargs: Keyword arguments passed to the class definition, which set model_config

            Note:
                You may want to override `__pydantic_init_subclass__` instead, which behaves similarly but is called
                *after* the class is fully initialized.
            """
            ...
        
    def __iter__(self) -> TupleGenerator:
        """So `dict(model)` works."""
        ...
    
    def __repr__(self) -> str:
        ...
    
    def __repr_args__(self) -> _repr.ReprArgs:
        ...
    
    __repr_name__ = ...
    __repr_recursion__ = ...
    __repr_str__ = ...
    __pretty__ = ...
    __rich_repr__ = ...
    def __str__(self) -> str:
        ...
    
    @property
    @typing_extensions.deprecated('The `__fields__` attribute is deprecated, use the `model_fields` class property instead.', category=None)
    def __fields__(self) -> dict[str, FieldInfo]:
        ...
    
    @property
    @typing_extensions.deprecated('The `__fields_set__` attribute is deprecated, use `model_fields_set` instead.', category=None)
    def __fields_set__(self) -> set[str]:
        ...
    
    @typing_extensions.deprecated('The `dict` method is deprecated; use `model_dump` instead.', category=None)
    def dict(self, *, include: IncEx | None = ..., exclude: IncEx | None = ..., by_alias: bool = ..., exclude_unset: bool = ..., exclude_defaults: bool = ..., exclude_none: bool = ...) -> Dict[str, Any]:
        ...
    
    @typing_extensions.deprecated('The `json` method is deprecated; use `model_dump_json` instead.', category=None)
    def json(self, *, include: IncEx | None = ..., exclude: IncEx | None = ..., by_alias: bool = ..., exclude_unset: bool = ..., exclude_defaults: bool = ..., exclude_none: bool = ..., encoder: Callable[[Any], Any] | None = ..., models_as_dict: bool = ..., **dumps_kwargs: Any) -> str:
        ...
    
    @classmethod
    @typing_extensions.deprecated('The `parse_obj` method is deprecated; use `model_validate` instead.', category=None)
    def parse_obj(cls, obj: Any) -> Self:
        ...
    
    @classmethod
    @typing_extensions.deprecated('The `parse_raw` method is deprecated; if your data is JSON use `model_validate_json`, ' 'otherwise load the data then use `model_validate` instead.', category=None)
    def parse_raw(cls, b: str | bytes, *, content_type: str | None = ..., encoding: str = ..., proto: DeprecatedParseProtocol | None = ..., allow_pickle: bool = ...) -> Self:
        ...
    
    @classmethod
    @typing_extensions.deprecated('The `parse_file` method is deprecated; load the data from file, then if your data is JSON ' 'use `model_validate_json`, otherwise `model_validate` instead.', category=None)
    def parse_file(cls, path: str | Path, *, content_type: str | None = ..., encoding: str = ..., proto: DeprecatedParseProtocol | None = ..., allow_pickle: bool = ...) -> Self:
        ...
    
    @classmethod
    @typing_extensions.deprecated('The `from_orm` method is deprecated; set ' "`model_config['from_attributes']=True` and use `model_validate` instead.", category=None)
    def from_orm(cls, obj: Any) -> Self:
        ...
    
    @classmethod
    @typing_extensions.deprecated('The `construct` method is deprecated; use `model_construct` instead.', category=None)
    def construct(cls, _fields_set: set[str] | None = ..., **values: Any) -> Self:
        ...
    
    @typing_extensions.deprecated('The `copy` method is deprecated; use `model_copy` instead. ' 'See the docstring of `BaseModel.copy` for details about how to handle `include` and `exclude`.', category=None)
    def copy(self, *, include: AbstractSetIntStr | MappingIntStrAny | None = ..., exclude: AbstractSetIntStr | MappingIntStrAny | None = ..., update: Dict[str, Any] | None = ..., deep: bool = ...) -> Self:
        """Returns a copy of the model.

        !!! warning "Deprecated"
            This method is now deprecated; use `model_copy` instead.

        If you need `include` or `exclude`, use:

        ```python {test="skip" lint="skip"}
        data = self.model_dump(include=include, exclude=exclude, round_trip=True)
        data = {**data, **(update or {})}
        copied = self.model_validate(data)
        ```

        Args:
            include: Optional set or mapping specifying which fields to include in the copied model.
            exclude: Optional set or mapping specifying which fields to exclude in the copied model.
            update: Optional dictionary of field-value pairs to override field values in the copied model.
            deep: If True, the values of fields that are Pydantic models will be deep-copied.

        Returns:
            A copy of the model with included, excluded and updated fields as specified.
        """
        ...
    
    @classmethod
    @typing_extensions.deprecated('The `schema` method is deprecated; use `model_json_schema` instead.', category=None)
    def schema(cls, by_alias: bool = ..., ref_template: str = ...) -> Dict[str, Any]:
        ...
    
    @classmethod
    @typing_extensions.deprecated('The `schema_json` method is deprecated; use `model_json_schema` and json.dumps instead.', category=None)
    def schema_json(cls, *, by_alias: bool = ..., ref_template: str = ..., **dumps_kwargs: Any) -> str:
        ...
    
    @classmethod
    @typing_extensions.deprecated('The `validate` method is deprecated; use `model_validate` instead.', category=None)
    def validate(cls, value: Any) -> Self:
        ...
    
    @classmethod
    @typing_extensions.deprecated('The `update_forward_refs` method is deprecated; use `model_rebuild` instead.', category=None)
    def update_forward_refs(cls, **localns: Any) -> None:
        ...
    


ModelT = TypeVar('ModelT', bound=BaseModel)
@overload
def create_model(model_name: str, /, *, __config__: ConfigDict | None = ..., __doc__: str | None = ..., __base__: None = ..., __module__: str = ..., __validators__: dict[str, Callable[..., Any]] | None = ..., __cls_kwargs__: dict[str, Any] | None = ..., __qualname__: str | None = ..., **field_definitions: Any | tuple[str, Any]) -> type[BaseModel]:
    ...

@overload
def create_model(model_name: str, /, *, __config__: ConfigDict | None = ..., __doc__: str | None = ..., __base__: type[ModelT] | tuple[type[ModelT], ...], __module__: str = ..., __validators__: dict[str, Callable[..., Any]] | None = ..., __cls_kwargs__: dict[str, Any] | None = ..., __qualname__: str | None = ..., **field_definitions: Any | tuple[str, Any]) -> type[ModelT]:
    ...

def create_model(model_name: str, /, *, __config__: ConfigDict | None = ..., __doc__: str | None = ..., __base__: type[ModelT] | tuple[type[ModelT], ...] | None = ..., __module__: str | None = ..., __validators__: dict[str, Callable[..., Any]] | None = ..., __cls_kwargs__: dict[str, Any] | None = ..., __qualname__: str | None = ..., **field_definitions: Any | tuple[str, Any]) -> type[ModelT]:
    """!!! abstract "Usage Documentation"
        [Dynamic Model Creation](../concepts/models.md#dynamic-model-creation)

    Dynamically creates and returns a new Pydantic model, in other words, `create_model` dynamically creates a
    subclass of [`BaseModel`][pydantic.BaseModel].

    Args:
        model_name: The name of the newly created model.
        __config__: The configuration of the new model.
        __doc__: The docstring of the new model.
        __base__: The base class or classes for the new model.
        __module__: The name of the module that the model belongs to;
            if `None`, the value is taken from `sys._getframe(1)`
        __validators__: A dictionary of methods that validate fields. The keys are the names of the validation methods to
            be added to the model, and the values are the validation methods themselves. You can read more about functional
            validators [here](https://docs.pydantic.dev/2.9/concepts/validators/#field-validators).
        __cls_kwargs__: A dictionary of keyword arguments for class creation, such as `metaclass`.
        __qualname__: The qualified name of the newly created model.
        **field_definitions: Field definitions of the new model. Either:

            - a single element, representing the type annotation of the field.
            - a two-tuple, the first element being the type and the second element the assigned value
              (either a default or the [`Field()`][pydantic.Field] function).

    Returns:
        The new [model][pydantic.BaseModel].

    Raises:
        PydanticUserError: If `__base__` and `__config__` are both passed.
    """
    ...

__getattr__ = ...
