"""
This type stub file was generated by pyright.
"""

import weakref
from abc import ABCMeta
from functools import cache
from typing import Any, Callable, Literal, NoReturn, TYPE_CHECKING, TypeVar
from typing_extensions import dataclass_transform, deprecated
from ._config import ConfigWrapper
from ._generics import PydanticGenericMetadata
from ._namespace_utils import NsResolver
from ..fields import Field as PydanticModelField, FieldInfo, ModelPrivateAttr, PrivateAttr as PydanticModelPrivateAttr
from ..main import BaseModel

"""Private logic for creating models."""
if TYPE_CHECKING:
    ...
else:
    ...
object_setattr = ...
class _ModelNamespaceDict(dict):
    """A dictionary subclass that intercepts attribute setting on model classes and
    warns about overriding of decorators.
    """
    def __setitem__(self, k: str, v: object) -> None:
        ...
    


def NoInitField(*, init: Literal[False] = ...) -> Any:
    """Only for typing purposes. Used as default value of `__pydantic_fields_set__`,
    `__pydantic_extra__`, `__pydantic_private__`, so they could be ignored when
    synthesizing the `__init__` signature.
    """
    ...

_T = TypeVar('_T')
@dataclass_transform(kw_only_default=True, field_specifiers=(PydanticModelField, PydanticModelPrivateAttr, NoInitField))
class ModelMetaclass(ABCMeta):
    def __new__(mcs, cls_name: str, bases: tuple[type[Any], ...], namespace: dict[str, Any], __pydantic_generic_metadata__: PydanticGenericMetadata | None = ..., __pydantic_reset_parent_namespace__: bool = ..., _create_model_module: str | None = ..., **kwargs: Any) -> type:
        """Metaclass for creating Pydantic models.

        Args:
            cls_name: The name of the class to be created.
            bases: The base classes of the class to be created.
            namespace: The attribute dictionary of the class to be created.
            __pydantic_generic_metadata__: Metadata for generic models.
            __pydantic_reset_parent_namespace__: Reset parent namespace.
            _create_model_module: The module of the class to be created, if created by `create_model`.
            **kwargs: Catch-all for any other keyword arguments.

        Returns:
            The new class created by the metaclass.
        """
        ...
    
    if not TYPE_CHECKING:
        ...
    @classmethod
    def __prepare__(cls, *args: Any, **kwargs: Any) -> dict[str, object]:
        ...
    
    def register(self, subclass: type[_T]) -> type[_T]:
        ...
    
    __instancecheck__ = ...
    __subclasscheck__ = ...
    @property
    @deprecated('The `__fields__` attribute is deprecated, use the `model_fields` class property instead.', category=None)
    def __fields__(self) -> dict[str, FieldInfo]:
        ...
    
    @property
    def __pydantic_fields_complete__(self) -> bool:
        """Whether the fields where successfully collected (i.e. type hints were successfully resolves).

        This is a private attribute, not meant to be used outside Pydantic.
        """
        ...
    
    def __dir__(self) -> list[str]:
        ...
    


def init_private_attributes(self: BaseModel, context: Any, /) -> None:
    """This function is meant to behave like a BaseModel method to initialise private attributes.

    It takes context as an argument since that's what pydantic-core passes when calling it.

    Args:
        self: The BaseModel instance.
        context: The context.
    """
    ...

def get_model_post_init(namespace: dict[str, Any], bases: tuple[type[Any], ...]) -> Callable[..., Any] | None:
    """Get the `model_post_init` method from the namespace or the class bases, or `None` if not defined."""
    ...

def inspect_namespace(namespace: dict[str, Any], raw_annotations: dict[str, Any], ignored_types: tuple[type[Any], ...], base_class_vars: set[str], base_class_fields: set[str]) -> dict[str, ModelPrivateAttr]:
    """Iterate over the namespace and:
    * gather private attributes
    * check for items which look like fields but are not (e.g. have no annotation) and warn.

    Args:
        namespace: The attribute dictionary of the class to be created.
        raw_annotations: The (non-evaluated) annotations of the model.
        ignored_types: A tuple of ignore types.
        base_class_vars: A set of base class class variables.
        base_class_fields: A set of base class fields.

    Returns:
        A dict contains private attributes info.

    Raises:
        TypeError: If there is a `__root__` field in model.
        NameError: If private attribute name is invalid.
        PydanticUserError:
            - If a field does not have a type annotation.
            - If a field on base class was overridden by a non-annotated attribute.
    """
    ...

def set_default_hash_func(cls: type[BaseModel], bases: tuple[type[Any], ...]) -> None:
    ...

def make_hash_func(cls: type[BaseModel]) -> Any:
    ...

def set_model_fields(cls: type[BaseModel], config_wrapper: ConfigWrapper, ns_resolver: NsResolver | None) -> None:
    """Collect and set `cls.__pydantic_fields__` and `cls.__class_vars__`.

    Args:
        cls: BaseModel or dataclass.
        config_wrapper: The config wrapper instance.
        ns_resolver: Namespace resolver to use when getting model annotations.
    """
    ...

def complete_model_class(cls: type[BaseModel], config_wrapper: ConfigWrapper, ns_resolver: NsResolver, *, raise_errors: bool = ..., call_on_complete_hook: bool = ..., create_model_module: str | None = ...) -> bool:
    """Finish building a model class.

    This logic must be called after class has been created since validation functions must be bound
    and `get_type_hints` requires a class object.

    Args:
        cls: BaseModel or dataclass.
        config_wrapper: The config wrapper instance.
        ns_resolver: The namespace resolver instance to use during schema building.
        raise_errors: Whether to raise errors.
        call_on_complete_hook: Whether to call the `__pydantic_on_complete__` hook.
        create_model_module: The module of the class to be created, if created by `create_model`.

    Returns:
        `True` if the model is successfully completed, else `False`.

    Raises:
        PydanticUndefinedAnnotation: If `PydanticUndefinedAnnotation` occurs in`__get_pydantic_core_schema__`
            and `raise_errors=True`.
    """
    ...

def set_deprecated_descriptors(cls: type[BaseModel]) -> None:
    """Set data descriptors on the class for deprecated fields."""
    ...

class _DeprecatedFieldDescriptor:
    """Read-only data descriptor used to emit a runtime deprecation warning before accessing a deprecated field.

    Attributes:
        msg: The deprecation message to be emitted.
        wrapped_property: The property instance if the deprecated field is a computed field, or `None`.
        field_name: The name of the field being deprecated.
    """
    field_name: str
    def __init__(self, msg: str, wrapped_property: property | None = ...) -> None:
        ...
    
    def __set_name__(self, cls: type[BaseModel], name: str) -> None:
        ...
    
    def __get__(self, obj: BaseModel | None, obj_type: type[BaseModel] | None = ...) -> Any:
        ...
    
    def __set__(self, obj: Any, value: Any) -> NoReturn:
        ...
    


class _PydanticWeakRef:
    """Wrapper for `weakref.ref` that enables `pickle` serialization.

    Cloudpickle fails to serialize `weakref.ref` objects due to an arcane error related
    to abstract base classes (`abc.ABC`). This class works around the issue by wrapping
    `weakref.ref` instead of subclassing it.

    See https://github.com/pydantic/pydantic/issues/6763 for context.

    Semantics:
        - If not pickled, behaves the same as a `weakref.ref`.
        - If pickled along with the referenced object, the same `weakref.ref` behavior
          will be maintained between them after unpickling.
        - If pickled without the referenced object, after unpickling the underlying
          reference will be cleared (`__call__` will always return `None`).
    """
    def __init__(self, obj: Any) -> None:
        ...
    
    def __call__(self) -> Any:
        ...
    
    def __reduce__(self) -> tuple[Callable, tuple[weakref.ReferenceType | None]]:
        ...
    


def build_lenient_weakvaluedict(d: dict[str, Any] | None) -> dict[str, Any] | None:
    """Takes an input dictionary, and produces a new value that (invertibly) replaces the values with weakrefs.

    We can't just use a WeakValueDictionary because many types (including int, str, etc.) can't be stored as values
    in a WeakValueDictionary.

    The `unpack_lenient_weakvaluedict` function can be used to reverse this operation.
    """
    ...

def unpack_lenient_weakvaluedict(d: dict[str, Any] | None) -> dict[str, Any] | None:
    """Inverts the transform performed by `build_lenient_weakvaluedict`."""
    ...

@cache
def default_ignored_types() -> tuple[type[Any], ...]:
    ...

