"""
This type stub file was generated by pyright.
"""

from collections.abc import Iterable
from typing import Any, TYPE_CHECKING
from pydantic_core import CoreSchema

if TYPE_CHECKING:
    ...
STRICT = ...
FAIL_FAST = ...
LENGTH_CONSTRAINTS = ...
INEQUALITY = ...
NUMERIC_CONSTRAINTS = ...
ALLOW_INF_NAN = ...
STR_CONSTRAINTS = ...
BYTES_CONSTRAINTS = ...
LIST_CONSTRAINTS = ...
TUPLE_CONSTRAINTS = ...
SET_CONSTRAINTS = ...
DICT_CONSTRAINTS = ...
GENERATOR_CONSTRAINTS = ...
SEQUENCE_CONSTRAINTS = ...
FLOAT_CONSTRAINTS = ...
DECIMAL_CONSTRAINTS = ...
INT_CONSTRAINTS = ...
BOOL_CONSTRAINTS = ...
UUID_CONSTRAINTS = ...
DATE_TIME_CONSTRAINTS = ...
TIMEDELTA_CONSTRAINTS = ...
TIME_CONSTRAINTS = ...
LAX_OR_STRICT_CONSTRAINTS = ...
ENUM_CONSTRAINTS = ...
COMPLEX_CONSTRAINTS = ...
UNION_CONSTRAINTS = ...
URL_CONSTRAINTS = ...
TEXT_SCHEMA_TYPES = ...
SEQUENCE_SCHEMA_TYPES = ...
NUMERIC_SCHEMA_TYPES = ...
CONSTRAINTS_TO_ALLOWED_SCHEMAS: dict[str, set[str]] = ...
constraint_schema_pairings: list[tuple[set[str], tuple[str, ...]]] = ...
def as_jsonable_value(v: Any) -> Any:
    ...

def expand_grouped_metadata(annotations: Iterable[Any]) -> Iterable[Any]:
    """Expand the annotations.

    Args:
        annotations: An iterable of annotations.

    Returns:
        An iterable of expanded annotations.

    Example:
        ```python
        from annotated_types import Ge, Len

        from pydantic._internal._known_annotated_metadata import expand_grouped_metadata

        print(list(expand_grouped_metadata([Ge(4), Len(5)])))
        #> [Ge(ge=4), MinLen(min_length=5)]
        ```
    """
    ...

def apply_known_metadata(annotation: Any, schema: CoreSchema) -> CoreSchema | None:
    """Apply `annotation` to `schema` if it is an annotation we know about (Gt, Le, etc.).
    Otherwise return `None`.

    This does not handle all known annotations. If / when it does, it can always
    return a CoreSchema and return the unmodified schema if the annotation should be ignored.

    Assumes that GroupedMetadata has already been expanded via `expand_grouped_metadata`.

    Args:
        annotation: The annotation.
        schema: The schema.

    Returns:
        An updated schema with annotation if it is an annotation we know about, `None` otherwise.

    Raises:
        RuntimeError: If a constraint can't be applied to a specific schema type.
        ValueError: If an unknown constraint is encountered.
    """
    ...

def collect_known_metadata(annotations: Iterable[Any]) -> tuple[dict[str, Any], list[Any]]:
    """Split `annotations` into known metadata and unknown annotations.

    Args:
        annotations: An iterable of annotations.

    Returns:
        A tuple contains a dict of known metadata and a list of unknown annotations.

    Example:
        ```python
        from annotated_types import Gt, Len

        from pydantic._internal._known_annotated_metadata import collect_known_metadata

        print(collect_known_metadata([Gt(1), Len(42), ...]))
        #> ({'gt': 1, 'min_length': 42}, [Ellipsis])
        ```
    """
    ...

def check_metadata(metadata: dict[str, Any], allowed: Iterable[str], source_type: Any) -> None:
    """A small utility function to validate that the given metadata can be applied to the target.
    More than saving lines of code, this gives us a consistent error message for all of our internal implementations.

    Args:
        metadata: A dict of metadata.
        allowed: An iterable of allowed metadata.
        source_type: The source type.

    Raises:
        TypeError: If there is metadatas that can't be applied on source type.
    """
    ...

