"""
This type stub file was generated by pyright.
"""

from contextlib import contextmanager
from re import Pattern
from typing import Any, Callable, Literal, TYPE_CHECKING
from pydantic_core import core_schema
from typing_extensions import Self
from ..aliases import AliasGenerator
from ..config import ConfigDict, ExtraValues, JsonDict, JsonEncoder, JsonSchemaExtraCallable
from .._internal._schema_generation_shared import GenerateSchema
from ..fields import ComputedFieldInfo, FieldInfo

if TYPE_CHECKING:
    ...
DEPRECATION_MESSAGE = ...
class ConfigWrapper:
    """Internal wrapper for Config which exposes ConfigDict items as attributes."""
    __slots__ = ...
    config_dict: ConfigDict
    title: str | None
    str_to_lower: bool
    str_to_upper: bool
    str_strip_whitespace: bool
    str_min_length: int
    str_max_length: int | None
    extra: ExtraValues | None
    frozen: bool
    populate_by_name: bool
    use_enum_values: bool
    validate_assignment: bool
    arbitrary_types_allowed: bool
    from_attributes: bool
    loc_by_alias: bool
    alias_generator: Callable[[str], str] | AliasGenerator | None
    model_title_generator: Callable[[type], str] | None
    field_title_generator: Callable[[str, FieldInfo | ComputedFieldInfo], str] | None
    ignored_types: tuple[type, ...]
    allow_inf_nan: bool
    json_schema_extra: JsonDict | JsonSchemaExtraCallable | None
    json_encoders: dict[type[object], JsonEncoder] | None
    strict: bool
    revalidate_instances: Literal['always', 'never', 'subclass-instances']
    ser_json_timedelta: Literal['iso8601', 'float']
    ser_json_temporal: Literal['iso8601', 'seconds', 'milliseconds']
    val_temporal_unit: Literal['seconds', 'milliseconds', 'infer']
    ser_json_bytes: Literal['utf8', 'base64', 'hex']
    val_json_bytes: Literal['utf8', 'base64', 'hex']
    ser_json_inf_nan: Literal['null', 'constants', 'strings']
    validate_default: bool
    validate_return: bool
    protected_namespaces: tuple[str | Pattern[str], ...]
    hide_input_in_errors: bool
    defer_build: bool
    plugin_settings: dict[str, object] | None
    schema_generator: type[GenerateSchema] | None
    json_schema_serialization_defaults_required: bool
    json_schema_mode_override: Literal['validation', 'serialization', None]
    coerce_numbers_to_str: bool
    regex_engine: Literal['rust-regex', 'python-re']
    validation_error_cause: bool
    use_attribute_docstrings: bool
    cache_strings: bool | Literal['all', 'keys', 'none']
    validate_by_alias: bool
    validate_by_name: bool
    serialize_by_alias: bool
    url_preserve_empty_path: bool
    def __init__(self, config: ConfigDict | dict[str, Any] | type[Any] | None, *, check: bool = ...) -> None:
        ...
    
    @classmethod
    def for_model(cls, bases: tuple[type[Any], ...], namespace: dict[str, Any], raw_annotations: dict[str, Any], kwargs: dict[str, Any]) -> Self:
        """Build a new `ConfigWrapper` instance for a `BaseModel`.

        The config wrapper built based on (in descending order of priority):
        - options from `kwargs`
        - options from the `namespace`
        - options from the base classes (`bases`)

        Args:
            bases: A tuple of base classes.
            namespace: The namespace of the class being created.
            raw_annotations: The (non-evaluated) annotations of the model.
            kwargs: The kwargs passed to the class being created.

        Returns:
            A `ConfigWrapper` instance for `BaseModel`.
        """
        ...
    
    if not TYPE_CHECKING:
        ...
    def core_config(self, title: str | None) -> core_schema.CoreConfig:
        """Create a pydantic-core config.

        We don't use getattr here since we don't want to populate with defaults.

        Args:
            title: The title to use if not set in config.

        Returns:
            A `CoreConfig` object created from config.
        """
        ...
    
    def __repr__(self): # -> str:
        ...
    


class ConfigWrapperStack:
    """A stack of `ConfigWrapper` instances."""
    def __init__(self, config_wrapper: ConfigWrapper) -> None:
        ...
    
    @property
    def tail(self) -> ConfigWrapper:
        ...
    
    @contextmanager
    def push(self, config_wrapper: ConfigWrapper | ConfigDict | None): # -> Generator[None, Any, None]:
        ...
    


config_defaults = ...
def prepare_config(config: ConfigDict | dict[str, Any] | type[Any] | None) -> ConfigDict:
    """Create a `ConfigDict` instance from an existing dict, a class (e.g. old class-based config) or None.

    Args:
        config: The input config.

    Returns:
        A ConfigDict object created from config.
    """
    ...

config_keys = ...
V2_REMOVED_KEYS = ...
V2_RENAMED_KEYS = ...
def check_deprecated(config_dict: ConfigDict) -> None:
    """Check for deprecated config keys and warn the user.

    Args:
        config_dict: The input config.
    """
    ...

