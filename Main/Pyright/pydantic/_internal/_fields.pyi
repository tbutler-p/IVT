"""
This type stub file was generated by pyright.
"""

from collections.abc import Mapping
from typing import Any, Callable, TYPE_CHECKING, TypeVar
from typing_extensions import TypeIs
from ._config import ConfigWrapper
from ._namespace_utils import NsResolver
from ._repr import Representation
from annotated_types import BaseMetadata
from ..fields import FieldInfo
from ..main import BaseModel
from ._dataclasses import PydanticDataclass, StandardDataclass

"""Private logic related to fields (the `Field()` function and `FieldInfo` class), and arguments to `Annotated`."""
if TYPE_CHECKING:
    ...
class PydanticMetadata(Representation):
    """Base class for annotation markers like `Strict`."""
    __slots__ = ...


def pydantic_general_metadata(**metadata: Any) -> BaseMetadata:
    """Create a new `_PydanticGeneralMetadata` class with the given metadata.

    Args:
        **metadata: The metadata to add.

    Returns:
        The new `_PydanticGeneralMetadata` class.
    """
    ...

def update_field_from_config(config_wrapper: ConfigWrapper, field_name: str, field_info: FieldInfo) -> None:
    """Update the `FieldInfo` instance from the configuration set on the model it belongs to.

    This will apply the title and alias generators from the configuration.

    Args:
        config_wrapper: The configuration from the model.
        field_name: The field name the `FieldInfo` instance is attached to.
        field_info: The `FieldInfo` instance to update.
    """
    ...

_deprecated_method_names = ...
_deprecated_classmethod_names = ...
def collect_model_fields(cls: type[BaseModel], config_wrapper: ConfigWrapper, ns_resolver: NsResolver | None, *, typevars_map: Mapping[TypeVar, Any] | None = ...) -> tuple[dict[str, FieldInfo], set[str]]:
    """Collect the fields and class variables names of a nascent Pydantic model.

    The fields collection process is *lenient*, meaning it won't error if string annotations
    fail to evaluate. If this happens, the original annotation (and assigned value, if any)
    is stored on the created `FieldInfo` instance.

    The `rebuild_model_fields()` should be called at a later point (e.g. when rebuilding the model),
    and will make use of these stored attributes.

    Args:
        cls: BaseModel or dataclass.
        config_wrapper: The config wrapper instance.
        ns_resolver: Namespace resolver to use when getting model annotations.
        typevars_map: A dictionary mapping type variables to their concrete types.

    Returns:
        A two-tuple containing model fields and class variables names.

    Raises:
        NameError:
            - If there is a conflict between a field name and protected namespaces.
            - If there is a field other than `root` in `RootModel`.
            - If a field shadows an attribute in the parent model.
    """
    ...

def rebuild_model_fields(cls: type[BaseModel], *, config_wrapper: ConfigWrapper, ns_resolver: NsResolver, typevars_map: Mapping[TypeVar, Any]) -> dict[str, FieldInfo]:
    """Rebuild the (already present) model fields by trying to reevaluate annotations.

    This function should be called whenever a model with incomplete fields is encountered.

    Raises:
        NameError: If one of the annotations failed to evaluate.

    Note:
        This function *doesn't* mutate the model fields in place, as it can be called during
        schema generation, where you don't want to mutate other model's fields.
    """
    ...

def collect_dataclass_fields(cls: type[StandardDataclass], *, config_wrapper: ConfigWrapper, ns_resolver: NsResolver | None = ..., typevars_map: dict[Any, Any] | None = ...) -> dict[str, FieldInfo]:
    """Collect the fields of a dataclass.

    Args:
        cls: dataclass.
        config_wrapper: The config wrapper instance.
        ns_resolver: Namespace resolver to use when getting dataclass annotations.
            Defaults to an empty instance.
        typevars_map: A dictionary mapping type variables to their concrete types.

    Returns:
        The dataclass fields.
    """
    ...

def rebuild_dataclass_fields(cls: type[PydanticDataclass], *, config_wrapper: ConfigWrapper, ns_resolver: NsResolver, typevars_map: Mapping[TypeVar, Any]) -> dict[str, FieldInfo]:
    """Rebuild the (already present) dataclass fields by trying to reevaluate annotations.

    This function should be called whenever a dataclass with incomplete fields is encountered.

    Raises:
        NameError: If one of the annotations failed to evaluate.

    Note:
        This function *doesn't* mutate the dataclass fields in place, as it can be called during
        schema generation, where you don't want to mutate other dataclass's fields.
    """
    ...

def is_valid_field_name(name: str) -> bool:
    ...

def is_valid_privateattr_name(name: str) -> bool:
    ...

def takes_validated_data_argument(default_factory: Callable[[], Any] | Callable[[dict[str, Any]], Any]) -> TypeIs[Callable[[dict[str, Any]], Any]]:
    """Whether the provided default factory callable has a validated data parameter."""
    ...

