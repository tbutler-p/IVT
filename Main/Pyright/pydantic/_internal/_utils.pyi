"""
This type stub file was generated by pyright.
"""

import dataclasses
from collections.abc import Callable, Iterable, Mapping, Set as AbstractSet
from inspect import Parameter
from typing import Any, Generic, TYPE_CHECKING, TypeVar, overload
from typing_extensions import TypeAlias, TypeGuard, deprecated
from . import _repr
from ..main import BaseModel

"""Bucket of reusable internal utilities.

This should be reduced as much as possible with functions only used in one place, moved to that place.
"""
if TYPE_CHECKING:
    MappingIntStrAny: TypeAlias = Mapping[int, Any] | Mapping[str, Any]
    AbstractSetIntStr: TypeAlias = AbstractSet[int] | AbstractSet[str]
IMMUTABLE_NON_COLLECTIONS_TYPES: set[type[Any]] = ...
BUILTIN_COLLECTIONS: set[type[Any]] = ...
def can_be_positional(param: Parameter) -> bool:
    """Return whether the parameter accepts a positional argument.

    ```python {test="skip" lint="skip"}
    def func(a, /, b, *, c):
        pass

    params = inspect.signature(func).parameters
    can_be_positional(params['a'])
    #> True
    can_be_positional(params['b'])
    #> True
    can_be_positional(params['c'])
    #> False
    ```
    """
    ...

def sequence_like(v: Any) -> bool:
    ...

def lenient_isinstance(o: Any, class_or_tuple: type[Any] | tuple[type[Any], ...] | None) -> bool:
    ...

def lenient_issubclass(cls: Any, class_or_tuple: Any) -> bool:
    ...

def is_model_class(cls: Any) -> TypeGuard[type[BaseModel]]:
    """Returns true if cls is a _proper_ subclass of BaseModel, and provides proper type-checking,
    unlike raw calls to lenient_issubclass.
    """
    ...

def is_valid_identifier(identifier: str) -> bool:
    """Checks that a string is a valid identifier and not a Python keyword.
    :param identifier: The identifier to test.
    :return: True if the identifier is valid.
    """
    ...

KeyType = TypeVar('KeyType')
def deep_update(mapping: dict[KeyType, Any], *updating_mappings: dict[KeyType, Any]) -> dict[KeyType, Any]:
    ...

def update_not_none(mapping: dict[Any, Any], **update: Any) -> None:
    ...

T = TypeVar('T')
def unique_list(input_list: list[T] | tuple[T, ...], *, name_factory: Callable[[T], str] = ...) -> list[T]:
    """Make a list unique while maintaining order.
    We update the list if another one with the same name is set
    (e.g. model validator overridden in subclass).
    """
    ...

class ValueItems(_repr.Representation):
    """Class for more convenient calculation of excluded or included fields on values."""
    __slots__ = ...
    def __init__(self, value: Any, items: AbstractSetIntStr | MappingIntStrAny) -> None:
        ...
    
    def is_excluded(self, item: Any) -> bool:
        """Check if item is fully excluded.

        :param item: key or index of a value
        """
        ...
    
    def is_included(self, item: Any) -> bool:
        """Check if value is contained in self._items.

        :param item: key or index of value
        """
        ...
    
    def for_element(self, e: int | str) -> AbstractSetIntStr | MappingIntStrAny | None:
        """:param e: key or index of element on value
        :return: raw values for element if self._items is dict and contain needed element
        """
        ...
    
    @classmethod
    def merge(cls, base: Any, override: Any, intersect: bool = ...) -> Any:
        """Merge a `base` item with an `override` item.

        Both `base` and `override` are converted to dictionaries if possible.
        Sets are converted to dictionaries with the sets entries as keys and
        Ellipsis as values.

        Each key-value pair existing in `base` is merged with `override`,
        while the rest of the key-value pairs are updated recursively with this function.

        Merging takes place based on the "union" of keys if `intersect` is
        set to `False` (default) and on the intersection of keys if
        `intersect` is set to `True`.
        """
        ...
    
    @staticmethod
    def is_true(v: Any) -> bool:
        ...
    
    def __repr_args__(self) -> _repr.ReprArgs:
        ...
    


if TYPE_CHECKING:
    def LazyClassAttribute(name: str, get_value: Callable[[], T]) -> T:
        ...
    
else:
    ...
Obj = TypeVar('Obj')
def smart_deepcopy(obj: Obj) -> Obj:
    """Return type as is for immutable built-in types
    Use obj.copy() for built-in empty collections
    Use copy.deepcopy() for non-empty collections and unknown objects.
    """
    ...

_SENTINEL = ...
def all_identical(left: Iterable[Any], right: Iterable[Any]) -> bool:
    """Check that the items of `left` are the same objects as those in `right`.

    >>> a, b = object(), object()
    >>> all_identical([a, b, a], [a, b, a])
    True
    >>> all_identical([a, b, [a]], [a, b, [a]])  # new list object, while "equal" is not "identical"
    False
    """
    ...

def get_first_not_none(a: Any, b: Any) -> Any:
    """Return the first argument if it is not `None`, otherwise return the second argument."""
    ...

@dataclasses.dataclass(frozen=True)
class SafeGetItemProxy:
    """Wrapper redirecting `__getitem__` to `get` with a sentinel value as default

    This makes is safe to use in `operator.itemgetter` when some keys may be missing
    """
    __slots__ = ...
    wrapped: Mapping[str, Any]
    def __getitem__(self, key: str, /) -> Any:
        ...
    
    if TYPE_CHECKING:
        def __contains__(self, key: str, /) -> bool:
            ...
        


_ModelT = TypeVar('_ModelT', bound='BaseModel')
_RT = TypeVar('_RT')
class deprecated_instance_property(Generic[_ModelT, _RT]):
    """A decorator exposing the decorated class method as a property, with a warning on instance access.

    This decorator takes a class method defined on the `BaseModel` class and transforms it into
    an attribute. The attribute can be accessed on both the class and instances of the class. If accessed
    via an instance, a deprecation warning is emitted stating that instance access will be removed in V3.
    """
    def __init__(self, fget: Callable[[type[_ModelT]], _RT], /) -> None:
        ...
    
    @overload
    def __get__(self, instance: None, objtype: type[_ModelT]) -> _RT:
        ...
    
    @overload
    @deprecated('Accessing this attribute on the instance is deprecated, and will be removed in Pydantic V3. ' 'Instead, you should access this attribute from the model class.', category=None)
    def __get__(self, instance: _ModelT, objtype: type[_ModelT]) -> _RT:
        ...
    
    def __get__(self, instance: _ModelT | None, objtype: type[_ModelT]) -> _RT:
        ...
    


