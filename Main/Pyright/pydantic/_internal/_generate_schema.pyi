"""
This type stub file was generated by pyright.
"""

from collections.abc import Generator, Iterable, Iterator, Mapping
from contextlib import contextmanager
from functools import partial
from types import FunctionType, LambdaType, MethodType
from typing import Any, Callable, Literal, TYPE_CHECKING, TypeVar, Union
from pydantic_core import CoreSchema, core_schema
from typing_extensions import TypeAlias
from ..annotated_handlers import GetCoreSchemaHandler
from ..config import JsonEncoder
from ..functional_validators import AfterValidator, BeforeValidator, FieldValidatorModes, PlainValidator, WrapValidator
from ._config import ConfigWrapper
from ._decorators import Decorator, FieldSerializerDecoratorInfo, FieldValidatorDecoratorInfo, ModelValidatorDecoratorInfo, RootValidatorDecoratorInfo, ValidatorDecoratorInfo
from ._namespace_utils import NsResolver
from ..fields import FieldInfo

"""Convert python types to pydantic-core schema."""
if TYPE_CHECKING:
    ...
_SUPPORTS_TYPEDDICT = ...
FieldDecoratorInfo = Union[ValidatorDecoratorInfo, FieldValidatorDecoratorInfo, FieldSerializerDecoratorInfo]
FieldDecoratorInfoType = TypeVar('FieldDecoratorInfoType', bound=FieldDecoratorInfo)
AnyFieldDecorator = Union[Decorator[ValidatorDecoratorInfo], Decorator[FieldValidatorDecoratorInfo], Decorator[FieldSerializerDecoratorInfo],]
ModifyCoreSchemaWrapHandler: TypeAlias = GetCoreSchemaHandler
GetCoreSchemaFunction: TypeAlias = Callable[[Any, ModifyCoreSchemaWrapHandler], core_schema.CoreSchema]
ParametersCallback: TypeAlias = "Callable[[int, str, Any], Literal['skip'] | None]"
TUPLE_TYPES: list[type] = ...
LIST_TYPES: list[type] = ...
SET_TYPES: list[type] = ...
FROZEN_SET_TYPES: list[type] = ...
DICT_TYPES: list[type] = ...
IP_TYPES: list[type] = ...
SEQUENCE_TYPES: list[type] = ...
ITERABLE_TYPES: list[type] = ...
TYPE_TYPES: list[type] = ...
PATTERN_TYPES: list[type] = ...
PATH_TYPES: list[type] = ...
MAPPING_TYPES = ...
COUNTER_TYPES = ...
DEQUE_TYPES: list[type] = ...
ValidateCallSupportedTypes = Union[LambdaType, FunctionType, MethodType, partial,]
VALIDATE_CALL_SUPPORTED_TYPES = ...
UNSUPPORTED_STANDALONE_FIELDINFO_ATTRIBUTES: list[tuple[str, Any]] = ...
_mode_to_validator: dict[FieldValidatorModes, type[BeforeValidator | AfterValidator | PlainValidator | WrapValidator]] = ...
def check_validator_fields_against_field_name(info: FieldDecoratorInfo, field: str) -> bool:
    """Check if field name is in validator fields.

    Args:
        info: The field info.
        field: The field name to check.

    Returns:
        `True` if field name is in validator fields, `False` otherwise.
    """
    ...

def check_decorator_fields_exist(decorators: Iterable[AnyFieldDecorator], fields: Iterable[str]) -> None:
    """Check if the defined fields in decorators exist in `fields` param.

    It ignores the check for a decorator if the decorator has `*` as field or `check_fields=False`.

    Args:
        decorators: An iterable of decorators.
        fields: An iterable of fields name.

    Raises:
        PydanticUserError: If one of the field names does not exist in `fields` param.
    """
    ...

def filter_field_decorator_info_by_field(validator_functions: Iterable[Decorator[FieldDecoratorInfoType]], field: str) -> list[Decorator[FieldDecoratorInfoType]]:
    ...

def apply_each_item_validators(schema: core_schema.CoreSchema, each_item_validators: list[Decorator[ValidatorDecoratorInfo]]) -> core_schema.CoreSchema:
    ...

JsonEncoders = dict[type[Any], JsonEncoder]
class InvalidSchemaError(Exception):
    """The core schema is invalid."""
    ...


class GenerateSchema:
    """Generate core schema for a Pydantic model, dataclass and types like `str`, `datetime`, ... ."""
    __slots__ = ...
    def __init__(self, config_wrapper: ConfigWrapper, ns_resolver: NsResolver | None = ..., typevars_map: Mapping[TypeVar, Any] | None = ...) -> None:
        ...
    
    def __init_subclass__(cls) -> None:
        ...
    
    def clean_schema(self, schema: CoreSchema) -> CoreSchema:
        ...
    
    def generate_schema(self, obj: Any) -> core_schema.CoreSchema:
        """Generate core schema.

        Args:
            obj: The object to generate core schema for.

        Returns:
            The generated core schema.

        Raises:
            PydanticUndefinedAnnotation:
                If it is not possible to evaluate forward reference.
            PydanticSchemaGenerationError:
                If it is not possible to generate pydantic-core schema.
            TypeError:
                - If `alias_generator` returns a disallowed type (must be str, AliasPath or AliasChoices).
                - If V1 style validator with `each_item=True` applied on a wrong field.
            PydanticUserError:
                - If `typing.TypedDict` is used instead of `typing_extensions.TypedDict` on Python < 3.12.
                - If `__modify_schema__` method is used instead of `__get_pydantic_json_schema__`.
        """
        ...
    
    def match_type(self, obj: Any) -> core_schema.CoreSchema:
        """Main mapping of types to schemas.

        The general structure is a series of if statements starting with the simple cases
        (non-generic primitive types) and then handling generics and other more complex cases.

        Each case either generates a schema directly, calls into a public user-overridable method
        (like `GenerateSchema.tuple_variable_schema`) or calls into a private method that handles some
        boilerplate before calling into the user-facing method (e.g. `GenerateSchema._tuple_schema`).

        The idea is that we'll evolve this into adding more and more user facing methods over time
        as they get requested and we figure out what the right API for them is.
        """
        ...
    


_VALIDATOR_F_MATCH: Mapping[tuple[FieldValidatorModes, Literal['no-info', 'with-info']], Callable[[Callable[..., Any], core_schema.CoreSchema], core_schema.CoreSchema],] = ...
def apply_validators(schema: core_schema.CoreSchema, validators: Iterable[Decorator[RootValidatorDecoratorInfo]] | Iterable[Decorator[ValidatorDecoratorInfo]] | Iterable[Decorator[FieldValidatorDecoratorInfo]]) -> core_schema.CoreSchema:
    """Apply validators to a schema.

    Args:
        schema: The schema to apply validators on.
        validators: An iterable of validators.
        field_name: The name of the field if validators are being applied to a model field.

    Returns:
        The updated schema.
    """
    ...

def apply_model_validators(schema: core_schema.CoreSchema, validators: Iterable[Decorator[ModelValidatorDecoratorInfo]], mode: Literal['inner', 'outer', 'all']) -> core_schema.CoreSchema:
    """Apply model validators to a schema.

    If mode == 'inner', only "before" validators are applied
    If mode == 'outer', validators other than "before" are applied
    If mode == 'all', all validators are applied

    Args:
        schema: The schema to apply validators on.
        validators: An iterable of validators.
        mode: The validator mode.

    Returns:
        The updated schema.
    """
    ...

def wrap_default(field_info: FieldInfo, schema: core_schema.CoreSchema) -> core_schema.CoreSchema:
    """Wrap schema with default schema if default value or `default_factory` are available.

    Args:
        field_info: The field info object.
        schema: The schema to apply default on.

    Returns:
        Updated schema by default value or `default_factory`.
    """
    ...

def resolve_original_schema(schema: CoreSchema, definitions: _Definitions) -> CoreSchema | None:
    ...

class _Definitions:
    """Keeps track of references and definitions."""
    _recursively_seen: set[str]
    _definitions: dict[str, core_schema.CoreSchema]
    def __init__(self) -> None:
        ...
    
    @contextmanager
    def get_schema_or_ref(self, tp: Any, /) -> Generator[tuple[str, core_schema.DefinitionReferenceSchema | None]]:
        """Get a definition for `tp` if one exists.

        If a definition exists, a tuple of `(ref_string, CoreSchema)` is returned.
        If no definition exists yet, a tuple of `(ref_string, None)` is returned.

        Note that the returned `CoreSchema` will always be a `DefinitionReferenceSchema`,
        not the actual definition itself.

        This should be called for any type that can be identified by reference.
        This includes any recursive types.

        At present the following types can be named/recursive:

        - Pydantic model
        - Pydantic and stdlib dataclasses
        - Typed dictionaries
        - Named tuples
        - `TypeAliasType` instances
        - Enums
        """
        ...
    
    def get_schema_from_ref(self, ref: str) -> CoreSchema | None:
        """Resolve the schema from the given reference."""
        ...
    
    def create_definition_reference_schema(self, schema: CoreSchema) -> core_schema.DefinitionReferenceSchema:
        """Store the schema as a definition and return a `'definition-reference'` schema pointing to it.

        The schema must have a reference attached to it.
        """
        ...
    
    def unpack_definitions(self, schema: core_schema.DefinitionsSchema) -> CoreSchema:
        """Store the definitions of the `'definitions'` core schema and return the inner core schema."""
        ...
    
    def finalize_schema(self, schema: CoreSchema) -> CoreSchema:
        """Finalize the core schema.

        This traverses the core schema and referenced definitions, replaces `'definition-ref'` schemas
        by the referenced definition if possible, and applies deferred discriminators.
        """
        ...
    


class _FieldNameStack:
    __slots__ = ...
    def __init__(self) -> None:
        ...
    
    @contextmanager
    def push(self, field_name: str) -> Iterator[None]:
        ...
    
    def get(self) -> str | None:
        ...
    


class _ModelTypeStack:
    __slots__ = ...
    def __init__(self) -> None:
        ...
    
    @contextmanager
    def push(self, type_obj: type) -> Iterator[None]:
        ...
    
    def get(self) -> type | None:
        ...
    


