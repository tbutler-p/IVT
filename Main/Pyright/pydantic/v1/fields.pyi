"""
This type stub file was generated by pyright.
"""

from typing import Any, Dict, Optional, Set, TYPE_CHECKING, Tuple, Type, TypeVar, Union
from pydantic.v1.class_validators import Validator
from pydantic.v1.error_wrappers import ErrorList
from pydantic.v1.types import ModelOrDc
from pydantic.v1.typing import AbstractSetIntStr, MappingIntStrAny, NoArgAnyCallable, ReprArgs
from pydantic.v1.utils import Representation
from pydantic.v1.config import BaseConfig

Required: Any = ...
T = TypeVar('T')
class UndefinedType:
    def __repr__(self) -> str:
        ...
    
    def __copy__(self: T) -> T:
        ...
    
    def __reduce__(self) -> str:
        ...
    
    def __deepcopy__(self: T, _: Any) -> T:
        ...
    


Undefined = ...
if TYPE_CHECKING:
    ValidateReturn = Tuple[Optional[Any], Optional[ErrorList]]
    LocStr = Union[Tuple[Union[int, str], ...], str]
    BoolUndefined = Union[bool, UndefinedType]
class FieldInfo(Representation):
    """
    Captures extra information about a field.
    """
    __slots__ = ...
    __field_constraints__ = ...
    def __init__(self, default: Any = ..., **kwargs: Any) -> None:
        ...
    
    def __repr_args__(self) -> ReprArgs:
        ...
    
    def get_constraints(self) -> Set[str]:
        """
        Gets the constraints set on the field by comparing the constraint value with its default value

        :return: the constraints set on field_info
        """
        ...
    
    def update_from_config(self, from_config: Dict[str, Any]) -> None:
        """
        Update this FieldInfo based on a dict from get_field_info, only fields which have not been set are dated.
        """
        ...
    


def Field(default: Any = ..., *, default_factory: Optional[NoArgAnyCallable] = ..., alias: Optional[str] = ..., title: Optional[str] = ..., description: Optional[str] = ..., exclude: Optional[Union[AbstractSetIntStr, MappingIntStrAny, Any]] = ..., include: Optional[Union[AbstractSetIntStr, MappingIntStrAny, Any]] = ..., const: Optional[bool] = ..., gt: Optional[float] = ..., ge: Optional[float] = ..., lt: Optional[float] = ..., le: Optional[float] = ..., multiple_of: Optional[float] = ..., allow_inf_nan: Optional[bool] = ..., max_digits: Optional[int] = ..., decimal_places: Optional[int] = ..., min_items: Optional[int] = ..., max_items: Optional[int] = ..., unique_items: Optional[bool] = ..., min_length: Optional[int] = ..., max_length: Optional[int] = ..., allow_mutation: bool = ..., regex: Optional[str] = ..., discriminator: Optional[str] = ..., repr: bool = ..., **extra: Any) -> Any:
    """
    Used to provide extra information about a field, either for the model schema or complex validation. Some arguments
    apply only to number fields (``int``, ``float``, ``Decimal``) and some apply only to ``str``.

    :param default: since this is replacing the field’s default, its first argument is used
      to set the default, use ellipsis (``...``) to indicate the field is required
    :param default_factory: callable that will be called when a default value is needed for this field
      If both `default` and `default_factory` are set, an error is raised.
    :param alias: the public name of the field
    :param title: can be any string, used in the schema
    :param description: can be any string, used in the schema
    :param exclude: exclude this field while dumping.
      Takes same values as the ``include`` and ``exclude`` arguments on the ``.dict`` method.
    :param include: include this field while dumping.
      Takes same values as the ``include`` and ``exclude`` arguments on the ``.dict`` method.
    :param const: this field is required and *must* take it's default value
    :param gt: only applies to numbers, requires the field to be "greater than". The schema
      will have an ``exclusiveMinimum`` validation keyword
    :param ge: only applies to numbers, requires the field to be "greater than or equal to". The
      schema will have a ``minimum`` validation keyword
    :param lt: only applies to numbers, requires the field to be "less than". The schema
      will have an ``exclusiveMaximum`` validation keyword
    :param le: only applies to numbers, requires the field to be "less than or equal to". The
      schema will have a ``maximum`` validation keyword
    :param multiple_of: only applies to numbers, requires the field to be "a multiple of". The
      schema will have a ``multipleOf`` validation keyword
    :param allow_inf_nan: only applies to numbers, allows the field to be NaN or infinity (+inf or -inf),
        which is a valid Python float. Default True, set to False for compatibility with JSON.
    :param max_digits: only applies to Decimals, requires the field to have a maximum number
      of digits within the decimal. It does not include a zero before the decimal point or trailing decimal zeroes.
    :param decimal_places: only applies to Decimals, requires the field to have at most a number of decimal places
      allowed. It does not include trailing decimal zeroes.
    :param min_items: only applies to lists, requires the field to have a minimum number of
      elements. The schema will have a ``minItems`` validation keyword
    :param max_items: only applies to lists, requires the field to have a maximum number of
      elements. The schema will have a ``maxItems`` validation keyword
    :param unique_items: only applies to lists, requires the field not to have duplicated
      elements. The schema will have a ``uniqueItems`` validation keyword
    :param min_length: only applies to strings, requires the field to have a minimum length. The
      schema will have a ``minLength`` validation keyword
    :param max_length: only applies to strings, requires the field to have a maximum length. The
      schema will have a ``maxLength`` validation keyword
    :param allow_mutation: a boolean which defaults to True. When False, the field raises a TypeError if the field is
      assigned on an instance.  The BaseModel Config must set validate_assignment to True
    :param regex: only applies to strings, requires the field match against a regular expression
      pattern string. The schema will have a ``pattern`` validation keyword
    :param discriminator: only useful with a (discriminated a.k.a. tagged) `Union` of sub models with a common field.
      The `discriminator` is the name of this common field to shorten validation and improve generated schema
    :param repr: show this field in the representation
    :param **extra: any additional keyword arguments will be added as is to the schema
    """
    ...

SHAPE_SINGLETON = ...
SHAPE_LIST = ...
SHAPE_SET = ...
SHAPE_MAPPING = ...
SHAPE_TUPLE = ...
SHAPE_TUPLE_ELLIPSIS = ...
SHAPE_SEQUENCE = ...
SHAPE_FROZENSET = ...
SHAPE_ITERABLE = ...
SHAPE_GENERIC = ...
SHAPE_DEQUE = ...
SHAPE_DICT = ...
SHAPE_DEFAULTDICT = ...
SHAPE_COUNTER = ...
SHAPE_NAME_LOOKUP = ...
MAPPING_LIKE_SHAPES: Set[int] = ...
class ModelField(Representation):
    __slots__ = ...
    def __init__(self, *, name: str, type_: Type[Any], class_validators: Optional[Dict[str, Validator]], model_config: Type[BaseConfig], default: Any = ..., default_factory: Optional[NoArgAnyCallable] = ..., required: BoolUndefined = ..., final: bool = ..., alias: Optional[str] = ..., field_info: Optional[FieldInfo] = ...) -> None:
        ...
    
    def get_default(self) -> Any:
        ...
    
    @classmethod
    def infer(cls, *, name: str, value: Any, annotation: Any, class_validators: Optional[Dict[str, Validator]], config: Type[BaseConfig]) -> ModelField:
        ...
    
    def set_config(self, config: Type[BaseConfig]) -> None:
        ...
    
    @property
    def alt_alias(self) -> bool:
        ...
    
    def prepare(self) -> None:
        """
        Prepare the field but inspecting self.default, self.type_ etc.

        Note: this method is **not** idempotent (because _type_analysis is not idempotent),
        e.g. calling it it multiple times may modify the field and configure it incorrectly.
        """
        ...
    
    def prepare_discriminated_union_sub_fields(self) -> None:
        """
        Prepare the mapping <discriminator key> -> <ModelField> and update `sub_fields`
        Note that this process can be aborted if a `ForwardRef` is encountered
        """
        ...
    
    def populate_validators(self) -> None:
        """
        Prepare self.pre_validators, self.validators, and self.post_validators based on self.type_'s  __get_validators__
        and class validators. This method should be idempotent, e.g. it should be safe to call multiple times
        without mis-configuring the field.
        """
        ...
    
    def validate(self, v: Any, values: Dict[str, Any], *, loc: LocStr, cls: Optional[ModelOrDc] = ...) -> ValidateReturn:
        ...
    
    def is_complex(self) -> bool:
        """
        Whether the field is "complex" eg. env variables should be parsed as JSON.
        """
        ...
    
    def __repr_args__(self) -> ReprArgs:
        ...
    


class ModelPrivateAttr(Representation):
    __slots__ = ...
    def __init__(self, default: Any = ..., *, default_factory: Optional[NoArgAnyCallable] = ...) -> None:
        ...
    
    def get_default(self) -> Any:
        ...
    
    def __eq__(self, other: Any) -> bool:
        ...
    


def PrivateAttr(default: Any = ..., *, default_factory: Optional[NoArgAnyCallable] = ...) -> Any:
    """
    Indicates that attribute is only used internally and never mixed with regular fields.

    Types or values of private attrs are not checked by pydantic and it's up to you to keep them relevant.

    Private attrs are stored in model __slots__.

    :param default: the attribute’s default value
    :param default_factory: callable that will be called when a default value is needed for this attribute
      If both `default` and `default_factory` are set, an error is raised.
    """
    ...

class DeferredType:
    """
    Used to postpone field preparation, while creating recursive generic models.
    """
    ...


def is_finalvar_with_default_val(type_: Type[Any], val: Any) -> bool:
    ...

