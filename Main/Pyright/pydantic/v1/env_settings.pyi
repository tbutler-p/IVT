"""
This type stub file was generated by pyright.
"""

from pathlib import Path
from typing import Any, Callable, ClassVar, Dict, List, Mapping, Optional, Tuple, Type, Union
from pydantic.v1.config import BaseConfig, Extra
from pydantic.v1.fields import ModelField
from pydantic.v1.main import BaseModel
from pydantic.v1.typing import StrPath

env_file_sentinel = ...
SettingsSourceCallable = Callable[['BaseSettings'], Dict[str, Any]]
DotenvType = Union[StrPath, List[StrPath], Tuple[StrPath, ...]]
class SettingsError(ValueError):
    ...


class BaseSettings(BaseModel):
    """
    Base class for settings, allowing values to be overridden by environment variables.

    This is useful in production for secrets you do not wish to save in code, it plays nicely with docker(-compose),
    Heroku and any 12 factor app design.
    """
    def __init__(__pydantic_self__, _env_file: Optional[DotenvType] = ..., _env_file_encoding: Optional[str] = ..., _env_nested_delimiter: Optional[str] = ..., _secrets_dir: Optional[StrPath] = ..., **values: Any) -> None:
        ...
    
    class Config(BaseConfig):
        env_prefix: str = ...
        env_file: Optional[DotenvType] = ...
        env_file_encoding: Optional[str] = ...
        env_nested_delimiter: Optional[str] = ...
        secrets_dir: Optional[StrPath] = ...
        validate_all: bool = ...
        extra: Extra = ...
        arbitrary_types_allowed: bool = ...
        case_sensitive: bool = ...
        @classmethod
        def prepare_field(cls, field: ModelField) -> None:
            ...
        
        @classmethod
        def customise_sources(cls, init_settings: SettingsSourceCallable, env_settings: SettingsSourceCallable, file_secret_settings: SettingsSourceCallable) -> Tuple[SettingsSourceCallable, ...]:
            ...
        
        @classmethod
        def parse_env_var(cls, field_name: str, raw_val: str) -> Any:
            ...
        
    
    
    __config__: ClassVar[Type[Config]]


class InitSettingsSource:
    __slots__ = ...
    def __init__(self, init_kwargs: Dict[str, Any]) -> None:
        ...
    
    def __call__(self, settings: BaseSettings) -> Dict[str, Any]:
        ...
    
    def __repr__(self) -> str:
        ...
    


class EnvSettingsSource:
    __slots__ = ...
    def __init__(self, env_file: Optional[DotenvType], env_file_encoding: Optional[str], env_nested_delimiter: Optional[str] = ..., env_prefix_len: int = ...) -> None:
        ...
    
    def __call__(self, settings: BaseSettings) -> Dict[str, Any]:
        """
        Build environment variables suitable for passing to the Model.
        """
        ...
    
    def field_is_complex(self, field: ModelField) -> Tuple[bool, bool]:
        """
        Find out if a field is complex, and if so whether JSON errors should be ignored
        """
        ...
    
    def explode_env_vars(self, field: ModelField, env_vars: Mapping[str, Optional[str]]) -> Dict[str, Any]:
        """
        Process env_vars and extract the values of keys containing env_nested_delimiter into nested dictionaries.

        This is applied to a single field, hence filtering by env_var prefix.
        """
        ...
    
    def __repr__(self) -> str:
        ...
    


class SecretsSettingsSource:
    __slots__ = ...
    def __init__(self, secrets_dir: Optional[StrPath]) -> None:
        ...
    
    def __call__(self, settings: BaseSettings) -> Dict[str, Any]:
        """
        Build fields from "secrets" files.
        """
        ...
    
    def __repr__(self) -> str:
        ...
    


def read_env_file(file_path: StrPath, *, encoding: str = ..., case_sensitive: bool = ...) -> Dict[str, Optional[str]]:
    ...

def find_case_path(dir_path: Path, file_name: str, case_sensitive: bool) -> Optional[Path]:
    """
    Find a file within path's directory matching filename, optionally ignoring case.
    """
    ...

