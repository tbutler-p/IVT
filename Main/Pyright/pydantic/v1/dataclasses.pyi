"""
This type stub file was generated by pyright.
"""

import dataclasses
import sys
from contextlib import contextmanager
from typing import Any, Callable, ClassVar, Dict, Generator, Optional, TYPE_CHECKING, Type, TypeVar, Union, overload
from typing_extensions import dataclass_transform
from pydantic.v1.config import BaseConfig, ConfigDict
from pydantic.v1.fields import Field
from pydantic.v1.main import BaseModel
from pydantic.v1.typing import CallableGenerator

"""
The main purpose is to enhance stdlib dataclasses by adding validation
A pydantic dataclass can be generated from scratch or from a stdlib one.

Behind the scene, a pydantic dataclass is just like a regular one on which we attach
a `BaseModel` and magic methods to trigger the validation of the data.
`__init__` and `__post_init__` are hence overridden and have extra logic to be
able to validate input data.

When a pydantic dataclass is generated from scratch, it's just a plain dataclass
with validation triggered at initialization

The tricky part if for stdlib dataclasses that are converted after into pydantic ones e.g.

```py
@dataclasses.dataclass
class M:
    x: int

ValidatedM = pydantic.dataclasses.dataclass(M)
```

We indeed still want to support equality, hashing, repr, ... as if it was the stdlib one!

```py
assert isinstance(ValidatedM(x=1), M)
assert ValidatedM(x=1) == M(x=1)
```

This means we **don't want to create a new dataclass that inherits from it**
The trick is to create a wrapper around `M` that will act as a proxy to trigger
validation without altering default `M` behaviour.
"""
if TYPE_CHECKING:
    DataclassT = TypeVar('DataclassT', bound='Dataclass')
    DataclassClassOrWrapper = Union[Type['Dataclass'], 'DataclassProxy']
    class Dataclass:
        __dataclass_fields__: ClassVar[Dict[str, Any]]
        __dataclass_params__: ClassVar[Any]
        __post_init__: ClassVar[Callable[..., None]]
        __pydantic_run_validation__: ClassVar[bool]
        __post_init_post_parse__: ClassVar[Callable[..., None]]
        __pydantic_initialised__: ClassVar[bool]
        __pydantic_model__: ClassVar[Type[BaseModel]]
        __pydantic_validate_values__: ClassVar[Callable[[Dataclass], None]]
        __pydantic_has_field_info_default__: ClassVar[bool]
        def __init__(self, *args: object, **kwargs: object) -> None:
            ...
        
        @classmethod
        def __get_validators__(cls: Type[Dataclass]) -> CallableGenerator:
            ...
        
        @classmethod
        def __validate__(cls: Type[DataclassT], v: Any) -> DataclassT:
            ...
        
    
    
__all__ = ['dataclass', 'set_validation', 'create_pydantic_model_from_dataclass', 'is_builtin_dataclass', 'make_dataclass_validator']
_T = TypeVar('_T')
if sys.version_info >= (3, 10):
    @dataclass_transform(field_specifiers=(dataclasses.field, Field))
    @overload
    def dataclass(*, init: bool = ..., repr: bool = ..., eq: bool = ..., order: bool = ..., unsafe_hash: bool = ..., frozen: bool = ..., config: Union[ConfigDict, Type[object], None] = ..., validate_on_init: Optional[bool] = ..., use_proxy: Optional[bool] = ..., kw_only: bool = ...) -> Callable[[Type[_T]], DataclassClassOrWrapper]:
        ...
    
    @dataclass_transform(field_specifiers=(dataclasses.field, Field))
    @overload
    def dataclass(_cls: Type[_T], *, init: bool = ..., repr: bool = ..., eq: bool = ..., order: bool = ..., unsafe_hash: bool = ..., frozen: bool = ..., config: Union[ConfigDict, Type[object], None] = ..., validate_on_init: Optional[bool] = ..., use_proxy: Optional[bool] = ..., kw_only: bool = ...) -> DataclassClassOrWrapper:
        ...
    
else:
    ...
@dataclass_transform(field_specifiers=(dataclasses.field, Field))
def dataclass(_cls: Optional[Type[_T]] = ..., *, init: bool = ..., repr: bool = ..., eq: bool = ..., order: bool = ..., unsafe_hash: bool = ..., frozen: bool = ..., config: Union[ConfigDict, Type[object], None] = ..., validate_on_init: Optional[bool] = ..., use_proxy: Optional[bool] = ..., kw_only: bool = ...) -> Union[Callable[[Type[_T]], DataclassClassOrWrapper], DataclassClassOrWrapper]:
    """
    Like the python standard lib dataclasses but with type validation.
    The result is either a pydantic dataclass that will validate input data
    or a wrapper that will trigger validation around a stdlib dataclass
    to avoid modifying it directly
    """
    ...

@contextmanager
def set_validation(cls: Type[DataclassT], value: bool) -> Generator[Type[DataclassT], None, None]:
    ...

class DataclassProxy:
    __slots__ = ...
    def __init__(self, dc_cls: Type[Dataclass]) -> None:
        ...
    
    def __call__(self, *args: Any, **kwargs: Any) -> Any:
        ...
    
    def __getattr__(self, name: str) -> Any:
        ...
    
    def __setattr__(self, __name: str, __value: Any) -> None:
        ...
    
    def __instancecheck__(self, instance: Any) -> bool:
        ...
    
    def __copy__(self) -> DataclassProxy:
        ...
    
    def __deepcopy__(self, memo: Any) -> DataclassProxy:
        ...
    


def create_pydantic_model_from_dataclass(dc_cls: Type[Dataclass], config: Type[Any] = ..., dc_cls_doc: Optional[str] = ...) -> Type[BaseModel]:
    ...

if sys.version_info >= (3, 8):
    ...
else:
    ...
def is_builtin_dataclass(_cls: Type[Any]) -> bool:
    """
    Whether a class is a stdlib dataclass
    (useful to discriminated a pydantic dataclass that is actually a wrapper around a stdlib dataclass)

    we check that
    - `_cls` is a dataclass
    - `_cls` is not a processed pydantic dataclass (with a basemodel attached)
    - `_cls` is not a pydantic dataclass inheriting directly from a stdlib dataclass
    e.g.
    ```
    @dataclasses.dataclass
    class A:
        x: int

    @pydantic.dataclasses.dataclass
    class B(A):
        y: int
    ```
    In this case, when we first check `B`, we make an extra check and look at the annotations ('y'),
    which won't be a superset of all the dataclass fields (only the stdlib fields i.e. 'x')
    """
    ...

def make_dataclass_validator(dc_cls: Type[Dataclass], config: Type[BaseConfig]) -> CallableGenerator:
    """
    Create a pydantic.dataclass from a builtin dataclass to add type validation
    and yield the validators
    It retrieves the parameters of the dataclass and forwards them to the newly created dataclass
    """
    ...

