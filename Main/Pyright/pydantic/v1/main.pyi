"""
This type stub file was generated by pyright.
"""

from abc import ABCMeta
from pathlib import Path
from typing import Any, Callable, ClassVar, Dict, List, Mapping, Optional, TYPE_CHECKING, Tuple, Type, TypeVar, Union, no_type_check, overload
from typing_extensions import dataclass_transform
from pydantic.v1.config import BaseConfig
from pydantic.v1.error_wrappers import ValidationError
from pydantic.v1.fields import Field, ModelField, ModelPrivateAttr
from pydantic.v1.parse import Protocol
from pydantic.v1.types import ModelOrDc, StrBytes
from pydantic.v1.typing import AbstractSetIntStr, AnyCallable, AnyClassMethod, CallableGenerator, DictAny, DictStrAny, MappingIntStrAny, ReprArgs, SetStr, TupleGenerator
from pydantic.v1.utils import Representation
from inspect import Signature

if TYPE_CHECKING:
    Model = TypeVar('Model', bound='BaseModel')
__all__ = ('BaseModel', 'create_model', 'validate_model')
_T = TypeVar('_T')
def validate_custom_root_type(fields: Dict[str, ModelField]) -> None:
    ...

def generate_hash_function(frozen: bool) -> Optional[Callable[[Any], int]]:
    ...

ANNOTATED_FIELD_UNTOUCHED_TYPES: Tuple[Any, ...] = ...
UNTOUCHED_TYPES: Tuple[Any, ...] = ...
_is_base_model_class_defined = ...
@dataclass_transform(kw_only_default=True, field_specifiers=(Field, ))
class ModelMetaclass(ABCMeta):
    @no_type_check
    def __new__(mcs, name, bases, namespace, **kwargs):
        ...
    
    def __instancecheck__(self, instance: Any) -> bool:
        """
        Avoid calling ABC _abc_subclasscheck unless we're pretty sure.

        See #3829 and python/cpython#92810
        """
        ...
    


object_setattr = ...
class BaseModel(Representation, metaclass=ModelMetaclass):
    if TYPE_CHECKING:
        __fields__: ClassVar[Dict[str, ModelField]] = ...
        __include_fields__: ClassVar[Optional[Mapping[str, Any]]] = ...
        __exclude_fields__: ClassVar[Optional[Mapping[str, Any]]] = ...
        __validators__: ClassVar[Dict[str, AnyCallable]] = ...
        __pre_root_validators__: ClassVar[List[AnyCallable]]
        __post_root_validators__: ClassVar[List[Tuple[bool, AnyCallable]]]
        __config__: ClassVar[Type[BaseConfig]] = ...
        __json_encoder__: ClassVar[Callable[[Any], Any]] = ...
        __schema_cache__: ClassVar[DictAny] = ...
        __custom_root_type__: ClassVar[bool] = ...
        __signature__: ClassVar[Signature]
        __private_attributes__: ClassVar[Dict[str, ModelPrivateAttr]]
        __class_vars__: ClassVar[SetStr]
        __fields_set__: ClassVar[SetStr] = ...
    Config = BaseConfig
    __slots__ = ...
    __doc__ = ...
    def __init__(__pydantic_self__, **data: Any) -> None:
        """
        Create a new model by parsing and validating input data from keyword arguments.

        Raises ValidationError if the input data cannot be parsed to form a valid model.
        """
        ...
    
    @no_type_check
    def __setattr__(self, name, value): # -> None:
        ...
    
    def __getstate__(self) -> DictAny:
        ...
    
    def __setstate__(self, state: DictAny) -> None:
        ...
    
    def dict(self, *, include: Optional[Union[AbstractSetIntStr, MappingIntStrAny]] = ..., exclude: Optional[Union[AbstractSetIntStr, MappingIntStrAny]] = ..., by_alias: bool = ..., skip_defaults: Optional[bool] = ..., exclude_unset: bool = ..., exclude_defaults: bool = ..., exclude_none: bool = ...) -> DictStrAny:
        """
        Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.

        """
        ...
    
    def json(self, *, include: Optional[Union[AbstractSetIntStr, MappingIntStrAny]] = ..., exclude: Optional[Union[AbstractSetIntStr, MappingIntStrAny]] = ..., by_alias: bool = ..., skip_defaults: Optional[bool] = ..., exclude_unset: bool = ..., exclude_defaults: bool = ..., exclude_none: bool = ..., encoder: Optional[Callable[[Any], Any]] = ..., models_as_dict: bool = ..., **dumps_kwargs: Any) -> str:
        """
        Generate a JSON representation of the model, `include` and `exclude` arguments as per `dict()`.

        `encoder` is an optional function to supply as `default` to json.dumps(), other arguments as per `json.dumps()`.
        """
        ...
    
    @classmethod
    def parse_obj(cls: Type[Model], obj: Any) -> Model:
        ...
    
    @classmethod
    def parse_raw(cls: Type[Model], b: StrBytes, *, content_type: str = ..., encoding: str = ..., proto: Protocol = ..., allow_pickle: bool = ...) -> Model:
        ...
    
    @classmethod
    def parse_file(cls: Type[Model], path: Union[str, Path], *, content_type: str = ..., encoding: str = ..., proto: Protocol = ..., allow_pickle: bool = ...) -> Model:
        ...
    
    @classmethod
    def from_orm(cls: Type[Model], obj: Any) -> Model:
        ...
    
    @classmethod
    def construct(cls: Type[Model], _fields_set: Optional[SetStr] = ..., **values: Any) -> Model:
        """
        Creates a new model setting __dict__ and __fields_set__ from trusted or pre-validated data.
        Default values are respected, but no other validation is performed.
        Behaves as if `Config.extra = 'allow'` was set since it adds all passed values
        """
        ...
    
    def copy(self: Model, *, include: Optional[Union[AbstractSetIntStr, MappingIntStrAny]] = ..., exclude: Optional[Union[AbstractSetIntStr, MappingIntStrAny]] = ..., update: Optional[DictStrAny] = ..., deep: bool = ...) -> Model:
        """
        Duplicate a model, optionally choose which fields to include, exclude and change.

        :param include: fields to include in new model
        :param exclude: fields to exclude from new model, as with values this takes precedence over include
        :param update: values to change/add in the new model. Note: the data is not validated before creating
            the new model: you should trust this data
        :param deep: set to `True` to make a deep copy of the model
        :return: new model instance
        """
        ...
    
    @classmethod
    def schema(cls, by_alias: bool = ..., ref_template: str = ...) -> DictStrAny:
        ...
    
    @classmethod
    def schema_json(cls, *, by_alias: bool = ..., ref_template: str = ..., **dumps_kwargs: Any) -> str:
        ...
    
    @classmethod
    def __get_validators__(cls) -> CallableGenerator:
        ...
    
    @classmethod
    def validate(cls: Type[Model], value: Any) -> Model:
        ...
    
    @classmethod
    def __try_update_forward_refs__(cls, **localns: Any) -> None:
        """
        Same as update_forward_refs but will not raise exception
        when forward references are not defined.
        """
        ...
    
    @classmethod
    def update_forward_refs(cls, **localns: Any) -> None:
        """
        Try to update ForwardRefs on fields based on this Model, globalns and localns.
        """
        ...
    
    def __iter__(self) -> TupleGenerator:
        """
        so `dict(model)` works
        """
        ...
    
    def __eq__(self, other: Any) -> bool:
        ...
    
    def __repr_args__(self) -> ReprArgs:
        ...
    


_is_base_model_class_defined = ...
@overload
def create_model(__model_name: str, *, __config__: Optional[Type[BaseConfig]] = ..., __base__: None = ..., __module__: str = ..., __validators__: Dict[str, AnyClassMethod] = ..., __cls_kwargs__: Dict[str, Any] = ..., **field_definitions: Any) -> Type[BaseModel]:
    ...

@overload
def create_model(__model_name: str, *, __config__: Optional[Type[BaseConfig]] = ..., __base__: Union[Type[Model], Tuple[Type[Model], ...]], __module__: str = ..., __validators__: Dict[str, AnyClassMethod] = ..., __cls_kwargs__: Dict[str, Any] = ..., **field_definitions: Any) -> Type[Model]:
    ...

def create_model(__model_name: str, *, __config__: Optional[Type[BaseConfig]] = ..., __base__: Union[None, Type[Model], Tuple[Type[Model], ...]] = ..., __module__: str = ..., __validators__: Dict[str, AnyClassMethod] = ..., __cls_kwargs__: Dict[str, Any] = ..., __slots__: Optional[Tuple[str, ...]] = ..., **field_definitions: Any) -> Type[Model]:
    """
    Dynamically create a model.
    :param __model_name: name of the created model
    :param __config__: config class to use for the new model
    :param __base__: base class for the new model to inherit from
    :param __module__: module of the created model
    :param __validators__: a dict of method names and @validator class methods
    :param __cls_kwargs__: a dict for class creation
    :param __slots__: Deprecated, `__slots__` should not be passed to `create_model`
    :param field_definitions: fields of the model (or extra fields if a base is supplied)
        in the format `<name>=(<type>, <default default>)` or `<name>=<default value>, e.g.
        `foobar=(str, ...)` or `foobar=123`, or, for complex use-cases, in the format
        `<name>=<Field>` or `<name>=(<type>, <FieldInfo>)`, e.g.
        `foo=Field(datetime, default_factory=datetime.utcnow, alias='bar')` or
        `foo=(str, FieldInfo(title='Foo'))`
    """
    ...

_missing = ...
def validate_model(model: Type[BaseModel], input_data: DictStrAny, cls: ModelOrDc = ...) -> Tuple[DictStrAny, SetStr, Optional[ValidationError]]:
    """
    validate data against a model.
    """
    ...

