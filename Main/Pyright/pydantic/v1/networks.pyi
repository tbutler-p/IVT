"""
This type stub file was generated by pyright.
"""

from ipaddress import IPv4Address, IPv4Interface, IPv4Network, IPv6Address, IPv6Interface, IPv6Network, _BaseAddress, _BaseNetwork
from typing import Any, Collection, Dict, Generator, List, Optional, Pattern, Set, TYPE_CHECKING, Tuple, Type, Union, no_type_check
from pydantic.v1.utils import Representation
from typing_extensions import TypedDict
from pydantic.v1.config import BaseConfig
from pydantic.v1.fields import ModelField
from pydantic.v1.typing import AnyCallable

if TYPE_CHECKING:
    CallableGenerator = Generator[AnyCallable, None, None]
    class Parts(TypedDict, total=False):
        scheme: str
        user: Optional[str]
        password: Optional[str]
        ipv4: Optional[str]
        ipv6: Optional[str]
        domain: Optional[str]
        port: Optional[str]
        path: Optional[str]
        query: Optional[str]
        fragment: Optional[str]
        ...
    
    
    class HostParts(TypedDict, total=False):
        host: str
        tld: Optional[str]
        host_type: Optional[str]
        port: Optional[str]
        rebuild: bool
        ...
    
    
else:
    ...
NetworkType = Union[str, bytes, int, Tuple[Union[str, bytes, int], Union[str, int]]]
__all__ = ['AnyUrl', 'AnyHttpUrl', 'FileUrl', 'HttpUrl', 'stricturl', 'EmailStr', 'NameEmail', 'IPvAnyAddress', 'IPvAnyInterface', 'IPvAnyNetwork', 'PostgresDsn', 'CockroachDsn', 'AmqpDsn', 'RedisDsn', 'MongoDsn', 'KafkaDsn', 'validate_email']
_url_regex_cache = ...
_multi_host_url_regex_cache = ...
_ascii_domain_regex_cache = ...
_int_domain_regex_cache = ...
_host_regex_cache = ...
_host_regex = ...
_scheme_regex = ...
_user_info_regex = ...
_path_regex = ...
_query_regex = ...
_fragment_regex = ...
def url_regex() -> Pattern[str]:
    ...

def multi_host_url_regex() -> Pattern[str]:
    """
    Compiled multi host url regex.

    Additionally to `url_regex` it allows to match multiple hosts.
    E.g. host1.db.net,host2.db.net
    """
    ...

def ascii_domain_regex() -> Pattern[str]:
    ...

def int_domain_regex() -> Pattern[str]:
    ...

def host_regex() -> Pattern[str]:
    ...

class AnyUrl(str):
    strip_whitespace = ...
    min_length = ...
    max_length = ...
    allowed_schemes: Optional[Collection[str]] = ...
    tld_required: bool = ...
    user_required: bool = ...
    host_required: bool = ...
    hidden_parts: Set[str] = ...
    __slots__ = ...
    @no_type_check
    def __new__(cls, url: Optional[str], **kwargs) -> object:
        ...
    
    def __init__(self, url: str, *, scheme: str, user: Optional[str] = ..., password: Optional[str] = ..., host: Optional[str] = ..., tld: Optional[str] = ..., host_type: str = ..., port: Optional[str] = ..., path: Optional[str] = ..., query: Optional[str] = ..., fragment: Optional[str] = ...) -> None:
        ...
    
    @classmethod
    def build(cls, *, scheme: str, user: Optional[str] = ..., password: Optional[str] = ..., host: str, port: Optional[str] = ..., path: Optional[str] = ..., query: Optional[str] = ..., fragment: Optional[str] = ..., **_kwargs: str) -> str:
        ...
    
    @classmethod
    def __modify_schema__(cls, field_schema: Dict[str, Any]) -> None:
        ...
    
    @classmethod
    def __get_validators__(cls) -> CallableGenerator:
        ...
    
    @classmethod
    def validate(cls, value: Any, field: ModelField, config: BaseConfig) -> AnyUrl:
        ...
    
    @classmethod
    def validate_parts(cls, parts: Parts, validate_port: bool = ...) -> Parts:
        """
        A method used to validate parts of a URL.
        Could be overridden to set default values for parts if missing
        """
        ...
    
    @classmethod
    def validate_host(cls, parts: Parts) -> Tuple[str, Optional[str], str, bool]:
        ...
    
    @staticmethod
    def get_default_parts(parts: Parts) -> Parts:
        ...
    
    @classmethod
    def apply_default_parts(cls, parts: Parts) -> Parts:
        ...
    
    def __repr__(self) -> str:
        ...
    


class AnyHttpUrl(AnyUrl):
    allowed_schemes = ...
    __slots__ = ...


class HttpUrl(AnyHttpUrl):
    tld_required = ...
    max_length = ...
    hidden_parts = ...
    @staticmethod
    def get_default_parts(parts: Parts) -> Parts:
        ...
    


class FileUrl(AnyUrl):
    allowed_schemes = ...
    host_required = ...
    __slots__ = ...


class MultiHostDsn(AnyUrl):
    __slots__ = ...
    def __init__(self, *args: Any, hosts: Optional[List[HostParts]] = ..., **kwargs: Any) -> None:
        ...
    
    @classmethod
    def validate_parts(cls, parts: Parts, validate_port: bool = ...) -> Parts:
        ...
    


class PostgresDsn(MultiHostDsn):
    allowed_schemes = ...
    user_required = ...
    __slots__ = ...


class CockroachDsn(AnyUrl):
    allowed_schemes = ...
    user_required = ...


class AmqpDsn(AnyUrl):
    allowed_schemes = ...
    host_required = ...


class RedisDsn(AnyUrl):
    __slots__ = ...
    allowed_schemes = ...
    host_required = ...
    @staticmethod
    def get_default_parts(parts: Parts) -> Parts:
        ...
    


class MongoDsn(AnyUrl):
    allowed_schemes = ...
    @staticmethod
    def get_default_parts(parts: Parts) -> Parts:
        ...
    


class KafkaDsn(AnyUrl):
    allowed_schemes = ...
    @staticmethod
    def get_default_parts(parts: Parts) -> Parts:
        ...
    


def stricturl(*, strip_whitespace: bool = ..., min_length: int = ..., max_length: int = ..., tld_required: bool = ..., host_required: bool = ..., allowed_schemes: Optional[Collection[str]] = ...) -> Type[AnyUrl]:
    ...

def import_email_validator() -> None:
    ...

class EmailStr(str):
    @classmethod
    def __modify_schema__(cls, field_schema: Dict[str, Any]) -> None:
        ...
    
    @classmethod
    def __get_validators__(cls) -> CallableGenerator:
        ...
    
    @classmethod
    def validate(cls, value: Union[str]) -> str:
        ...
    


class NameEmail(Representation):
    __slots__ = ...
    def __init__(self, name: str, email: str) -> None:
        ...
    
    def __eq__(self, other: Any) -> bool:
        ...
    
    @classmethod
    def __modify_schema__(cls, field_schema: Dict[str, Any]) -> None:
        ...
    
    @classmethod
    def __get_validators__(cls) -> CallableGenerator:
        ...
    
    @classmethod
    def validate(cls, value: Any) -> NameEmail:
        ...
    
    def __str__(self) -> str:
        ...
    


class IPvAnyAddress(_BaseAddress):
    __slots__ = ...
    @classmethod
    def __modify_schema__(cls, field_schema: Dict[str, Any]) -> None:
        ...
    
    @classmethod
    def __get_validators__(cls) -> CallableGenerator:
        ...
    
    @classmethod
    def validate(cls, value: Union[str, bytes, int]) -> Union[IPv4Address, IPv6Address]:
        ...
    


class IPvAnyInterface(_BaseAddress):
    __slots__ = ...
    @classmethod
    def __modify_schema__(cls, field_schema: Dict[str, Any]) -> None:
        ...
    
    @classmethod
    def __get_validators__(cls) -> CallableGenerator:
        ...
    
    @classmethod
    def validate(cls, value: NetworkType) -> Union[IPv4Interface, IPv6Interface]:
        ...
    


class IPvAnyNetwork(_BaseNetwork):
    @classmethod
    def __modify_schema__(cls, field_schema: Dict[str, Any]) -> None:
        ...
    
    @classmethod
    def __get_validators__(cls) -> CallableGenerator:
        ...
    
    @classmethod
    def validate(cls, value: NetworkType) -> Union[IPv4Network, IPv6Network]:
        ...
    


pretty_email_regex = ...
MAX_EMAIL_LENGTH = ...
def validate_email(value: Union[str]) -> Tuple[str, str]:
    """
    Email address validation using https://pypi.org/project/email-validator/
    Notes:
    * raw ip address (literal) domain parts are not allowed.
    * "John Doe <local_part@domain.com>" style "pretty" email addresses are processed
    * spaces are striped from the beginning and end of addresses but no error is raised
    """
    ...

