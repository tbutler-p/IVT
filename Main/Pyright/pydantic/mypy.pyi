"""
This type stub file was generated by pyright.
"""

from typing import Any, Callable
from mypy.nodes import Argument, AssignmentStmt, ClassDef, Context, Expression, JsonDict, Statement, TypeInfo, Var
from mypy.options import Options
from mypy.plugin import CheckerPluginInterface, ClassDefContext, MethodContext, Plugin, ReportConfigContext, SemanticAnalyzerPluginInterface
from mypy.type_visitor import TypeTranslator
from mypy.types import AnyType, Type, TypeVarType

"""This module includes classes and functions designed specifically for use with the mypy plugin."""
CONFIGFILE_KEY = ...
METADATA_KEY = ...
BASEMODEL_FULLNAME = ...
BASESETTINGS_FULLNAME = ...
ROOT_MODEL_FULLNAME = ...
MODEL_METACLASS_FULLNAME = ...
FIELD_FULLNAME = ...
DATACLASS_FULLNAME = ...
MODEL_VALIDATOR_FULLNAME = ...
DECORATOR_FULLNAMES = ...
IMPLICIT_CLASSMETHOD_DECORATOR_FULLNAMES = ...
MYPY_VERSION_TUPLE = ...
BUILTINS_NAME = ...
__version__ = ...
def plugin(version: str) -> type[Plugin]:
    """`version` is the mypy version string.

    We might want to use this to print a warning if the mypy version being used is
    newer, or especially older, than we expect (or need).

    Args:
        version: The mypy version string.

    Return:
        The Pydantic mypy plugin type.
    """
    ...

class PydanticPlugin(Plugin):
    """The Pydantic mypy plugin."""
    def __init__(self, options: Options) -> None:
        ...
    
    def get_base_class_hook(self, fullname: str) -> Callable[[ClassDefContext], None] | None:
        """Update Pydantic model class."""
        ...
    
    def get_metaclass_hook(self, fullname: str) -> Callable[[ClassDefContext], None] | None:
        """Update Pydantic `ModelMetaclass` definition."""
        ...
    
    def get_method_hook(self, fullname: str) -> Callable[[MethodContext], Type] | None:
        """Adjust return type of `from_orm` method call."""
        ...
    
    def report_config_data(self, ctx: ReportConfigContext) -> dict[str, Any]:
        """Return all plugin config data.

        Used by mypy to determine if cache needs to be discarded.
        """
        ...
    


class PydanticPluginConfig:
    """A Pydantic mypy plugin config holder.

    Attributes:
        init_forbid_extra: Whether to add a `**kwargs` at the end of the generated `__init__` signature.
        init_typed: Whether to annotate fields in the generated `__init__`.
        warn_required_dynamic_aliases: Whether to raise required dynamic aliases error.
        debug_dataclass_transform: Whether to not reset `dataclass_transform_spec` attribute
            of `ModelMetaclass` for testing purposes.
    """
    __slots__ = ...
    init_forbid_extra: bool
    init_typed: bool
    warn_required_dynamic_aliases: bool
    debug_dataclass_transform: bool
    def __init__(self, options: Options) -> None:
        ...
    
    def to_data(self) -> dict[str, Any]:
        """Returns a dict of config names to their values."""
        ...
    


def from_attributes_callback(ctx: MethodContext) -> Type:
    """Raise an error if from_attributes is not enabled."""
    ...

class PydanticModelField:
    """Based on mypy.plugins.dataclasses.DataclassAttribute."""
    def __init__(self, name: str, alias: str | None, is_frozen: bool, has_dynamic_alias: bool, has_default: bool, strict: bool | None, line: int, column: int, type: Type | None, info: TypeInfo) -> None:
        ...
    
    def to_argument(self, current_info: TypeInfo, typed: bool, model_strict: bool, force_optional: bool, use_alias: bool, api: SemanticAnalyzerPluginInterface, force_typevars_invariant: bool, is_root_model_root: bool) -> Argument:
        """Based on mypy.plugins.dataclasses.DataclassAttribute.to_argument."""
        ...
    
    def expand_type(self, current_info: TypeInfo, api: SemanticAnalyzerPluginInterface, force_typevars_invariant: bool = ..., include_root_type: bool = ...) -> Type | None:
        """Based on mypy.plugins.dataclasses.DataclassAttribute.expand_type."""
        ...
    
    def to_var(self, current_info: TypeInfo, api: SemanticAnalyzerPluginInterface, use_alias: bool, force_typevars_invariant: bool = ...) -> Var:
        """Based on mypy.plugins.dataclasses.DataclassAttribute.to_var."""
        ...
    
    def serialize(self) -> JsonDict:
        """Based on mypy.plugins.dataclasses.DataclassAttribute.serialize."""
        ...
    
    @classmethod
    def deserialize(cls, info: TypeInfo, data: JsonDict, api: SemanticAnalyzerPluginInterface) -> PydanticModelField:
        """Based on mypy.plugins.dataclasses.DataclassAttribute.deserialize."""
        ...
    
    def expand_typevar_from_subtype(self, sub_type: TypeInfo, api: SemanticAnalyzerPluginInterface) -> None:
        """Expands type vars in the context of a subtype when an attribute is inherited
        from a generic super type.
        """
        ...
    


class PydanticModelClassVar:
    """Based on mypy.plugins.dataclasses.DataclassAttribute.

    ClassVars are ignored by subclasses.

    Attributes:
        name: the ClassVar name
    """
    def __init__(self, name) -> None:
        ...
    
    @classmethod
    def deserialize(cls, data: JsonDict) -> PydanticModelClassVar:
        """Based on mypy.plugins.dataclasses.DataclassAttribute.deserialize."""
        ...
    
    def serialize(self) -> JsonDict:
        """Based on mypy.plugins.dataclasses.DataclassAttribute.serialize."""
        ...
    


class PydanticModelTransformer:
    """Transform the BaseModel subclass according to the plugin settings.

    Attributes:
        tracked_config_fields: A set of field configs that the plugin has to track their value.
    """
    tracked_config_fields: set[str] = ...
    def __init__(self, cls: ClassDef, reason: Expression | Statement, api: SemanticAnalyzerPluginInterface, plugin_config: PydanticPluginConfig) -> None:
        ...
    
    def transform(self) -> bool:
        """Configures the BaseModel subclass according to the plugin settings.

        In particular:

        * determines the model config and fields,
        * adds a fields-aware signature for the initializer and construct methods
        * freezes the class if frozen = True
        * stores the fields, config, and if the class is settings in the mypy metadata for access by subclasses
        """
        ...
    
    def adjust_decorator_signatures(self) -> None:
        """When we decorate a function `f` with `pydantic.validator(...)`, `pydantic.field_validator`
        or `pydantic.serializer(...)`, mypy sees `f` as a regular method taking a `self` instance,
        even though pydantic internally wraps `f` with `classmethod` if necessary.

        Teach mypy this by marking any function whose outermost decorator is a `validator()`,
        `field_validator()` or `serializer()` call as a `classmethod`.
        """
        ...
    
    def collect_config(self) -> ModelConfigData:
        """Collects the values of the config attributes that are used by the plugin, accounting for parent classes."""
        ...
    
    def collect_fields_and_class_vars(self, model_config: ModelConfigData, is_root_model: bool) -> tuple[list[PydanticModelField] | None, list[PydanticModelClassVar] | None]:
        """Collects the fields for the model, accounting for parent classes."""
        ...
    
    def collect_field_or_class_var_from_stmt(self, stmt: AssignmentStmt, model_config: ModelConfigData, class_vars: dict[str, PydanticModelClassVar]) -> PydanticModelField | PydanticModelClassVar | None:
        """Get pydantic model field from statement.

        Args:
            stmt: The statement.
            model_config: Configuration settings for the model.
            class_vars: ClassVars already known to be defined on the model.

        Returns:
            A pydantic model field if it could find the field in statement. Otherwise, `None`.
        """
        ...
    
    def add_initializer(self, fields: list[PydanticModelField], config: ModelConfigData, is_settings: bool, is_root_model: bool) -> None:
        """Adds a fields-aware `__init__` method to the class.

        The added `__init__` will be annotated with types vs. all `Any` depending on the plugin settings.
        """
        ...
    
    def add_model_construct_method(self, fields: list[PydanticModelField], config: ModelConfigData, is_settings: bool, is_root_model: bool) -> None:
        """Adds a fully typed `model_construct` classmethod to the class.

        Similar to the fields-aware __init__ method, but always uses the field names (not aliases),
        and does not treat settings fields as optional.
        """
        ...
    
    def set_frozen(self, fields: list[PydanticModelField], api: SemanticAnalyzerPluginInterface, frozen: bool) -> None:
        """Marks all fields as properties so that attempts to set them trigger mypy errors.

        This is the same approach used by the attrs and dataclasses plugins.
        """
        ...
    
    def get_config_update(self, name: str, arg: Expression, lax_extra: bool = ...) -> ModelConfigData | None:
        """Determines the config update due to a single kwarg in the ConfigDict definition.

        Warns if a tracked config attribute is set to a value the plugin doesn't know how to interpret (e.g., an int)
        """
        ...
    
    @staticmethod
    def get_has_default(stmt: AssignmentStmt) -> bool:
        """Returns a boolean indicating whether the field defined in `stmt` is a required field."""
        ...
    
    @staticmethod
    def get_strict(stmt: AssignmentStmt) -> bool | None:
        """Returns a the `strict` value of a field if defined, otherwise `None`."""
        ...
    
    @staticmethod
    def get_alias_info(stmt: AssignmentStmt) -> tuple[str | None, bool]:
        """Returns a pair (alias, has_dynamic_alias), extracted from the declaration of the field defined in `stmt`.

        `has_dynamic_alias` is True if and only if an alias is provided, but not as a string literal.
        If `has_dynamic_alias` is True, `alias` will be None.
        """
        ...
    
    @staticmethod
    def is_field_frozen(stmt: AssignmentStmt) -> bool:
        """Returns whether the field is frozen, extracted from the declaration of the field defined in `stmt`.

        Note that this is only whether the field was declared to be frozen in a `<field_name> = Field(frozen=True)`
        sense; this does not determine whether the field is frozen because the entire model is frozen; that is
        handled separately.
        """
        ...
    
    def get_field_arguments(self, fields: list[PydanticModelField], typed: bool, model_strict: bool, use_alias: bool, requires_dynamic_aliases: bool, is_settings: bool, is_root_model: bool, force_typevars_invariant: bool = ...) -> list[Argument]:
        """Helper function used during the construction of the `__init__` and `model_construct` method signatures.

        Returns a list of mypy Argument instances for use in the generated signatures.
        """
        ...
    
    def should_init_forbid_extra(self, fields: list[PydanticModelField], config: ModelConfigData) -> bool:
        """Indicates whether the generated `__init__` should get a `**kwargs` at the end of its signature.

        We disallow arbitrary kwargs if the extra config setting is "forbid", or if the plugin config says to,
        *unless* a required dynamic alias is present (since then we can't determine a valid signature).
        """
        ...
    
    @staticmethod
    def is_dynamic_alias_present(fields: list[PydanticModelField], has_alias_generator: bool) -> bool:
        """Returns whether any fields on the model have a "dynamic alias", i.e., an alias that cannot be
        determined during static analysis.
        """
        ...
    


class ChangeExplicitTypeOfAny(TypeTranslator):
    """A type translator used to change type of Any's, if explicit."""
    def __init__(self, type_of_any: int) -> None:
        ...
    
    def visit_any(self, t: AnyType) -> Type:
        ...
    


class ModelConfigData:
    """Pydantic mypy plugin model config class."""
    def __init__(self, forbid_extra: bool | None = ..., frozen: bool | None = ..., from_attributes: bool | None = ..., populate_by_name: bool | None = ..., validate_by_alias: bool | None = ..., validate_by_name: bool | None = ..., has_alias_generator: bool | None = ..., strict: bool | None = ...) -> None:
        ...
    
    def get_values_dict(self) -> dict[str, Any]:
        """Returns a dict of Pydantic model config names to their values.

        It includes the config if config value is not `None`.
        """
        ...
    
    def update(self, config: ModelConfigData | None) -> None:
        """Update Pydantic model config values."""
        ...
    
    def setdefault(self, key: str, value: Any) -> None:
        """Set default value for Pydantic model config if config value is `None`."""
        ...
    


def is_root_model(info: TypeInfo) -> bool:
    """Return whether the type info is a root model subclass (or the `RootModel` class itself)."""
    ...

ERROR_ORM = ...
ERROR_CONFIG = ...
ERROR_ALIAS = ...
ERROR_UNEXPECTED = ...
ERROR_UNTYPED = ...
ERROR_FIELD_DEFAULTS = ...
ERROR_EXTRA_FIELD_ROOT_MODEL = ...
def error_from_attributes(model_name: str, api: CheckerPluginInterface, context: Context) -> None:
    """Emits an error when the model does not have `from_attributes=True`."""
    ...

def error_invalid_config_value(name: str, api: SemanticAnalyzerPluginInterface, context: Context) -> None:
    """Emits an error when the config value is invalid."""
    ...

def error_required_dynamic_aliases(api: SemanticAnalyzerPluginInterface, context: Context) -> None:
    """Emits required dynamic aliases error.

    This will be called when `warn_required_dynamic_aliases=True`.
    """
    ...

def error_unexpected_behavior(detail: str, api: CheckerPluginInterface | SemanticAnalyzerPluginInterface, context: Context) -> None:
    """Emits unexpected behavior error."""
    ...

def error_untyped_fields(api: SemanticAnalyzerPluginInterface, context: Context) -> None:
    """Emits an error when there is an untyped field in the model."""
    ...

def error_extra_fields_on_root_model(api: CheckerPluginInterface, context: Context) -> None:
    """Emits an error when there is more than just a root field defined for a subclass of RootModel."""
    ...

def add_method(api: SemanticAnalyzerPluginInterface | CheckerPluginInterface, cls: ClassDef, name: str, args: list[Argument], return_type: Type, self_type: Type | None = ..., tvar_def: TypeVarType | None = ..., is_classmethod: bool = ...) -> None:
    """Very closely related to `mypy.plugins.common.add_method_to_class`, with a few pydantic-specific changes."""
    ...

def parse_toml(config_file: str) -> dict[str, Any] | None:
    """Returns a dict of config keys to values.

    It reads configs from toml file and returns `None` if the file is not a toml file.
    """
    ...

